**2026 / C**

# 26.01.06

## [Top 10 errors found in C projects in 2025 - DEV Community](https://dev.to/pvsdev/top-10-errors-found-in-c-projects-in-2025-10ml)

정적 분석 도구인 PVS-Studio 팀에서 발표한 **"2025년 오픈소스 C# 프로젝트에서 발견된 10가지 주요 에러"** 아티클을 정리하고 번역해 드립니다.

### 10위. 단순 복사-붙여넣기 실수 (Copy-paste)

* **오류:** `TypeCode.UInt64` 케이스에서 `ToUInt64()`가 아닌 `ToInt64()` 메서드를 호출함.
* **원인:** 유사한 코드를 반복해서 작성하다가 메서드 이름을 수정하지 않은 전형적인 복붙 에러입니다.

```cs
public static void SetAsIConvertible(this ref ComVariant variant,
                                     IConvertible value)
{
  TypeCode tc = value.GetTypeCode();
  CultureInfo ci = CultureInfo.CurrentCulture;

  switch (tc)
  {
    case TypeCode.Empty: break;
    case TypeCode.Object: 
      variant = ComVariant.CreateRaw(....); break;
    case TypeCode.DBNull: 
      variant = ComVariant.Null; break;
    case TypeCode.Boolean: 
      variant = ComVariant.Create<bool>(....)); break;
    case TypeCode.Char: 
      variant = ComVariant.Create<ushort>(value.ToChar(ci)); break;
    case TypeCode.SByte: 
      variant = ComVariant.Create<sbyte>(value.ToSByte(ci)); break;
    case TypeCode.Byte: 
      variant = ComVariant.Create<byte>(value.ToByte(ci)); break;
    case TypeCode.Int16: 
      variant = ComVariant.Create(value.ToInt16(ci)); break;
    case TypeCode.UInt16: 
      variant = ComVariant.Create(value.ToUInt16(ci)); break;
    case TypeCode.Int32: 
      variant = ComVariant.Create(value.ToInt32(ci)); break;
    case TypeCode.UInt32: 
      variant = ComVariant.Create(value.ToUInt32(ci)); break;
    case TypeCode.Int64: 
      variant = ComVariant.Create(value.ToInt64(ci)); break;
    case TypeCode.UInt64: 
      variant = ComVariant.Create(value.ToInt64(ci)); break; // <-- Here
    case TypeCode.Single: 
      variant = ComVariant.Create(value.ToSingle(ci)); break;
    case TypeCode.Double: 
      variant = ComVariant.Create(value.ToDouble(ci)); break;
    case TypeCode.Decimal: 
      variant = ComVariant.Create(value.ToDecimal(ci)); break;
    case TypeCode.DateTime: 
      variant = ComVariant.Create(value.ToDateTime(ci)); break;
    case TypeCode.String: 
      variant = ComVariant.Create(....); break;

    default:
      throw new NotSupportedException();
  }
}
```

### 9위. 잘못된 문자열 포맷팅 (AppendFormat)

* **오류:** `sb.AppendFormat("{1:X04}...", arg1, arg2...)` 호출 시 예외 발생.
* **원인:** 1.  포맷 플레이스홀더(`{3}`, `{4}`) 개수보다 전달된 인자가 적음.
2.  C# 포맷 인덱스는 **1이 아닌 0부터 시작**해야 하는데 `{1}`부터 시작함.

### 8위. Equals와 GetHashCode의 불일치 (1)

* **오류:** `GetHashCode`에서는 `Legs` 속성을 사용해 해시를 계산하지만, `Equals`에서는 이를 비교하지 않음.
* **원인:** 특히 이 사례에서는 `Dictionary`를 만들 때 자기 자신의 컬렉션을 다시 참조하여 "컬렉션의 요소가 같은 컬렉션에 있는지" 확인하는 무의미한 로직이 포함되었습니다.

```cs
public override int GetHashCode()
{
  unchecked
  {
    var hashCode = Definition.GetHashCode();
    var arr = new int[Legs.Count];
    for (int i = 0; i < Legs.Count; i++)
    {
      arr[i] = Legs[i].GetHashCode();
    }

    Array.Sort(arr);

    for (int i = 0; i < arr.Length; i++)
    {
      hashCode = (hashCode * 397) ^ arr[i];
    }

    return hashCode;
  }
}

public override bool Equals(object obj)
{
    ....

    return Equals((OptionStrategyDefinitionMatch) obj);
}
```

### 7위. 속성이 누락된 Equals 구현

* **오류:** `Equals` 메서드에서 `Min` 속성만 두 번 비교하고 `Max` 비교를 누락함.
* **분석:** `Equals(Min, other.Min) && Equals(Min, other.Min)`과 같이 작성된 코드입니다. `GetHashCode`에는 `Max`가 포함되어 있어 분석기가 불일치를 감지했습니다.

### 6위. 도달할 수 없는 비트 연산 코드 (Switch Pattern)

* **오류:** `keys & ~Keys.Modifiers` 연산 후 `Keys.Shift` 등을 체크하는 switch 문에서 특정 case가 절대 실행되지 않음.
* **원인:** `Keys.Modifiers` 비트 마스크에 `Shift`, `Control`, `Alt` 비트가 이미 포함되어 있어, 이를 제거하면 해당 값들과 일치할 수 없게 됩니다.

```cs
public static Interactivity.Key GetKey(this Keys keys)
{

  Keys keyCode = keys & ~Keys.Modifiers;                   // <=
  Interactivity.Key key = keyCode switch
  {
    Keys.Alt => Interactivity.StandardKeys.Alt,            // <=
    Keys.Menu => Interactivity.StandardKeys.Alt,
    Keys.Shift => Interactivity.StandardKeys.Shift,        // <=
    Keys.ShiftKey => Interactivity.StandardKeys.Shift,
    Keys.LShiftKey => Interactivity.StandardKeys.Shift,
    Keys.RShiftKey => Interactivity.StandardKeys.Shift,
    Keys.Control => Interactivity.StandardKeys.Control,    // <=
    Keys.ControlKey => Interactivity.StandardKeys.Control,
    Keys.Down => Interactivity.StandardKeys.Down,
    Keys.Up => Interactivity.StandardKeys.Up,
    Keys.Left => Interactivity.StandardKeys.Left,
    Keys.Right => Interactivity.StandardKeys.Right,
    _ => Interactivity.StandardKeys.Unknown,
  };

  ....
}
```

### 5위. 값 형식(Struct)의 ReferenceEquals 사용

* **오류:** `struct StackValue`의 `Equals` 메서드 내에서 `ReferenceEquals(this, obj)` 호출.
* **원인:** `this`가 값 형식이므로 `ReferenceEquals`에 전달되는 순간 **박싱(Boxing)**이 발생합니다. 힙에 새로 생성된 참조는 절대 같을 수 없으므로 이 비교는 항상 `false`를 반환합니다.

### 4위. 익명 함수를 이용한 이벤트 구독 해제 실패

* **오류:** `Event -= () => Action();` 형태의 코드.
* **원인:** 익명 함수는 선언될 때마다 **새로운 델리게이트 인스턴스**를 생성합니다. 구독할 때의 인스턴스와 해제할 때의 인스턴스가 다르므로 구독 해제가 작동하지 않습니다.

```cs
private static void SubscribeImmutablePathsInitialized()
{
  NotifyOnScopingReadiness?.Invoke();

  FileClassifier.Shared.OnImmutablePathsInitialized -= () =>
    NotifyOnScopingReadiness?.Invoke();
}
```

### 3위. 연산자 우선순위 혼동 (?? vs +)

* **오류:** `base.Size + nullableObj?.Size ?? 0`
* **원인:** `+` 연산자가 `??`보다 우선순위가 높습니다. 따라서 `(base.Size + null) ?? 0`이 되어 왼쪽 항이 `null`이면 결과가 항상 `0`이 됩니다. 의도한 대로라면 괄호를 써서 `base.Size + (nullableObj?.Size ?? 0)`이 되어야 합니다.

```cs
public override int Size =>   base.Size
                            + ChangeViewMessages?.Values.GetVarSize() ?? 0
                            + 1 + PrepareRequestMessage?.Size ?? 0
                            + PreparationHash?.Size ?? 0
                            + PreparationMessages?.Values.GetVarSize() ?? 0
                            + CommitMessages?.Values.GetVarSize() ?? 0;
```

### 2위. 논리 패턴 매칭의 함정 (not 0 or 1)

* **오류:** `itemCount is not 0 or 1`
* **원인:** 개발자는 "0도 아니고 1도 아님"을 의도했겠지만, C# 컴파일러는 이를 **`(is not 0) or (is 1)`**로 해석합니다. 1인 경우에도 참이 되는 논리적 오류입니다. 정확하게는 `is not (0 or 1)`로 써야 합니다.

```cs
protected void ChangeMode(OmnibarMode? oldMode, OmnibarMode newMode)
{
  ....
  var modeSeparatorWidth = 
    itemCount is not 0 or 1 
      ? _modesHostGrid.Children[1] is FrameworkElement frameworkElement
        ? frameworkElement.ActualWidth
        : 0
      : 0;
  ....
}
```

### 1위. LINQ 지연 실행과 변수 캡처의 결합

* **오류:** `Select` 내부에서 외부 변수 `lineNumber++`를 수행하고, 이후 `foreach` 루프에서도 동일한 변수를 `++` 함.
* **원인:** `Select`는 **지연 실행(Deferred Execution)** 메서드입니다. 실제 값이 계산되는 시점은 `foreach` 문이 돌 때입니다. 결과적으로 루프 한 번에 변수가 두 번씩 증가하거나, 초기화 시점이 꼬여 예상치 못한 값을 가지게 됩니다.

```cs
public void FutureMarginModel_MarginEntriesValid(string market)
{
  ....
  var lineNumber = 0;
  var errorMessageTemplate = $"Error encountered in file " + 
                             $"{marginFile.Name} on line ";
  var csv = File.ReadLines(marginFile.FullName)
                .Where(x =>    !x.StartsWithInvariant("#") 
                            && !string.IsNullOrWhiteSpace(x))
                .Skip(1)
                .Select(x =>
  {
    lineNumber++;                                                  // <=

    ....
  });

  lineNumber = 0;                                                  // <=
  foreach (var line in csv)
  {
    lineNumber++;                                                  // <=

    ....
  }
}
```
