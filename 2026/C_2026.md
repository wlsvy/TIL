**2026 / C**

# 26.01.06

## [Top 10 errors found in C projects in 2025 - DEV Community](https://dev.to/pvsdev/top-10-errors-found-in-c-projects-in-2025-10ml)

정적 분석 도구인 PVS-Studio 팀에서 발표한 **"2025년 오픈소스 C# 프로젝트에서 발견된 10가지 주요 에러"** 아티클을 정리하고 번역해 드립니다.

### 10위. 단순 복사-붙여넣기 실수 (Copy-paste)

* **오류:** `TypeCode.UInt64` 케이스에서 `ToUInt64()`가 아닌 `ToInt64()` 메서드를 호출함.
* **원인:** 유사한 코드를 반복해서 작성하다가 메서드 이름을 수정하지 않은 전형적인 복붙 에러입니다.

```cs
public static void SetAsIConvertible(this ref ComVariant variant,
                                     IConvertible value)
{
  TypeCode tc = value.GetTypeCode();
  CultureInfo ci = CultureInfo.CurrentCulture;

  switch (tc)
  {
    case TypeCode.Empty: break;
    case TypeCode.Object: 
      variant = ComVariant.CreateRaw(....); break;
    case TypeCode.DBNull: 
      variant = ComVariant.Null; break;
    case TypeCode.Boolean: 
      variant = ComVariant.Create<bool>(....)); break;
    case TypeCode.Char: 
      variant = ComVariant.Create<ushort>(value.ToChar(ci)); break;
    case TypeCode.SByte: 
      variant = ComVariant.Create<sbyte>(value.ToSByte(ci)); break;
    case TypeCode.Byte: 
      variant = ComVariant.Create<byte>(value.ToByte(ci)); break;
    case TypeCode.Int16: 
      variant = ComVariant.Create(value.ToInt16(ci)); break;
    case TypeCode.UInt16: 
      variant = ComVariant.Create(value.ToUInt16(ci)); break;
    case TypeCode.Int32: 
      variant = ComVariant.Create(value.ToInt32(ci)); break;
    case TypeCode.UInt32: 
      variant = ComVariant.Create(value.ToUInt32(ci)); break;
    case TypeCode.Int64: 
      variant = ComVariant.Create(value.ToInt64(ci)); break;
    case TypeCode.UInt64: 
      variant = ComVariant.Create(value.ToInt64(ci)); break; // <-- Here
    case TypeCode.Single: 
      variant = ComVariant.Create(value.ToSingle(ci)); break;
    case TypeCode.Double: 
      variant = ComVariant.Create(value.ToDouble(ci)); break;
    case TypeCode.Decimal: 
      variant = ComVariant.Create(value.ToDecimal(ci)); break;
    case TypeCode.DateTime: 
      variant = ComVariant.Create(value.ToDateTime(ci)); break;
    case TypeCode.String: 
      variant = ComVariant.Create(....); break;

    default:
      throw new NotSupportedException();
  }
}
```

### 9위. 잘못된 문자열 포맷팅 (AppendFormat)

* **오류:** `sb.AppendFormat("{1:X04}...", arg1, arg2...)` 호출 시 예외 발생.
* **원인:** 1.  포맷 플레이스홀더(`{3}`, `{4}`) 개수보다 전달된 인자가 적음.
2.  C# 포맷 인덱스는 **1이 아닌 0부터 시작**해야 하는데 `{1}`부터 시작함.

### 8위. Equals와 GetHashCode의 불일치 (1)

* **오류:** `GetHashCode`에서는 `Legs` 속성을 사용해 해시를 계산하지만, `Equals`에서는 이를 비교하지 않음.
* **원인:** 특히 이 사례에서는 `Dictionary`를 만들 때 자기 자신의 컬렉션을 다시 참조하여 "컬렉션의 요소가 같은 컬렉션에 있는지" 확인하는 무의미한 로직이 포함되었습니다.

```cs
public override int GetHashCode()
{
  unchecked
  {
    var hashCode = Definition.GetHashCode();
    var arr = new int[Legs.Count];
    for (int i = 0; i < Legs.Count; i++)
    {
      arr[i] = Legs[i].GetHashCode();
    }

    Array.Sort(arr);

    for (int i = 0; i < arr.Length; i++)
    {
      hashCode = (hashCode * 397) ^ arr[i];
    }

    return hashCode;
  }
}

public override bool Equals(object obj)
{
    ....

    return Equals((OptionStrategyDefinitionMatch) obj);
}
```

### 7위. 속성이 누락된 Equals 구현

* **오류:** `Equals` 메서드에서 `Min` 속성만 두 번 비교하고 `Max` 비교를 누락함.
* **분석:** `Equals(Min, other.Min) && Equals(Min, other.Min)`과 같이 작성된 코드입니다. `GetHashCode`에는 `Max`가 포함되어 있어 분석기가 불일치를 감지했습니다.

### 6위. 도달할 수 없는 비트 연산 코드 (Switch Pattern)

* **오류:** `keys & ~Keys.Modifiers` 연산 후 `Keys.Shift` 등을 체크하는 switch 문에서 특정 case가 절대 실행되지 않음.
* **원인:** `Keys.Modifiers` 비트 마스크에 `Shift`, `Control`, `Alt` 비트가 이미 포함되어 있어, 이를 제거하면 해당 값들과 일치할 수 없게 됩니다.

```cs
public static Interactivity.Key GetKey(this Keys keys)
{

  Keys keyCode = keys & ~Keys.Modifiers;                   // <=
  Interactivity.Key key = keyCode switch
  {
    Keys.Alt => Interactivity.StandardKeys.Alt,            // <=
    Keys.Menu => Interactivity.StandardKeys.Alt,
    Keys.Shift => Interactivity.StandardKeys.Shift,        // <=
    Keys.ShiftKey => Interactivity.StandardKeys.Shift,
    Keys.LShiftKey => Interactivity.StandardKeys.Shift,
    Keys.RShiftKey => Interactivity.StandardKeys.Shift,
    Keys.Control => Interactivity.StandardKeys.Control,    // <=
    Keys.ControlKey => Interactivity.StandardKeys.Control,
    Keys.Down => Interactivity.StandardKeys.Down,
    Keys.Up => Interactivity.StandardKeys.Up,
    Keys.Left => Interactivity.StandardKeys.Left,
    Keys.Right => Interactivity.StandardKeys.Right,
    _ => Interactivity.StandardKeys.Unknown,
  };

  ....
}
```

### 5위. 값 형식(Struct)의 ReferenceEquals 사용

* **오류:** `struct StackValue`의 `Equals` 메서드 내에서 `ReferenceEquals(this, obj)` 호출.
* **원인:** `this`가 값 형식이므로 `ReferenceEquals`에 전달되는 순간 **박싱(Boxing)**이 발생합니다. 힙에 새로 생성된 참조는 절대 같을 수 없으므로 이 비교는 항상 `false`를 반환합니다.

### 4위. 익명 함수를 이용한 이벤트 구독 해제 실패

* **오류:** `Event -= () => Action();` 형태의 코드.
* **원인:** 익명 함수는 선언될 때마다 **새로운 델리게이트 인스턴스**를 생성합니다. 구독할 때의 인스턴스와 해제할 때의 인스턴스가 다르므로 구독 해제가 작동하지 않습니다.

```cs
private static void SubscribeImmutablePathsInitialized()
{
  NotifyOnScopingReadiness?.Invoke();

  FileClassifier.Shared.OnImmutablePathsInitialized -= () =>
    NotifyOnScopingReadiness?.Invoke();
}
```

### 3위. 연산자 우선순위 혼동 (?? vs +)

* **오류:** `base.Size + nullableObj?.Size ?? 0`
* **원인:** `+` 연산자가 `??`보다 우선순위가 높습니다. 따라서 `(base.Size + null) ?? 0`이 되어 왼쪽 항이 `null`이면 결과가 항상 `0`이 됩니다. 의도한 대로라면 괄호를 써서 `base.Size + (nullableObj?.Size ?? 0)`이 되어야 합니다.

```cs
public override int Size =>   base.Size
                            + ChangeViewMessages?.Values.GetVarSize() ?? 0
                            + 1 + PrepareRequestMessage?.Size ?? 0
                            + PreparationHash?.Size ?? 0
                            + PreparationMessages?.Values.GetVarSize() ?? 0
                            + CommitMessages?.Values.GetVarSize() ?? 0;
```

### 2위. 논리 패턴 매칭의 함정 (not 0 or 1)

* **오류:** `itemCount is not 0 or 1`
* **원인:** 개발자는 "0도 아니고 1도 아님"을 의도했겠지만, C# 컴파일러는 이를 **`(is not 0) or (is 1)`**로 해석합니다. 1인 경우에도 참이 되는 논리적 오류입니다. 정확하게는 `is not (0 or 1)`로 써야 합니다.

```cs
protected void ChangeMode(OmnibarMode? oldMode, OmnibarMode newMode)
{
  ....
  var modeSeparatorWidth = 
    itemCount is not 0 or 1 
      ? _modesHostGrid.Children[1] is FrameworkElement frameworkElement
        ? frameworkElement.ActualWidth
        : 0
      : 0;
  ....
}
```

### 1위. LINQ 지연 실행과 변수 캡처의 결합

* **오류:** `Select` 내부에서 외부 변수 `lineNumber++`를 수행하고, 이후 `foreach` 루프에서도 동일한 변수를 `++` 함.
* **원인:** `Select`는 **지연 실행(Deferred Execution)** 메서드입니다. 실제 값이 계산되는 시점은 `foreach` 문이 돌 때입니다. 결과적으로 루프 한 번에 변수가 두 번씩 증가하거나, 초기화 시점이 꼬여 예상치 못한 값을 가지게 됩니다.

```cs
public void FutureMarginModel_MarginEntriesValid(string market)
{
  ....
  var lineNumber = 0;
  var errorMessageTemplate = $"Error encountered in file " + 
                             $"{marginFile.Name} on line ";
  var csv = File.ReadLines(marginFile.FullName)
                .Where(x =>    !x.StartsWithInvariant("#") 
                            && !string.IsNullOrWhiteSpace(x))
                .Skip(1)
                .Select(x =>
  {
    lineNumber++;                                                  // <=

    ....
  });

  lineNumber = 0;                                                  // <=
  foreach (var line in csv)
  {
    lineNumber++;                                                  // <=

    ....
  }
}
```

# 26.01.08

## [IO is no longer the bottleneck](https://stoppels.ch/2022/11/27/io-is-no-longer-the-bottleneck.html)

Ben Hoyt's blog refers to an [earlier post](https://benhoyt.com/writings/count-words/) which includes a faster C version of the word frequency counter. I compiled optimized.c with GCC 12, using -O3 -march=native flags, and ran it on the 425MB input file (100 copies of the King James Version of the Bible).

이 글은 "현대 시스템에서 데이터 처리의 병목은 디스크 읽기(I/O)가 아니라 CPU 성능"이라는 주장을 검증하기 위해, 단어 수 세기(Word Count) 프로그램을 극한으로 최적화해 본 과정을 담고 있습니다. (2022. 11. 27)

### 1. 배경: 현대 디스크의 속도

최근 벤 호이트(Ben Hoyt)는 "순차 읽기(Sequential Read) 속도는 엄청나게 빨라진 반면, CPU 속도는 정체되었기 때문에 I/O가 병목이라는 믿음은 더 이상 사실이 아니다"라고 주장했습니다.

* **저자의 측정 결과:** * **Cold Cache(디스크에서 직접 읽기):** 약 1.6 GB/s
* **Warm Cache(메모리에 로드된 상태):** 약 12.8 GB/s

### 2. 최적화된 C 코드의 한계

벤 호이트가 작성한 최적화된 C 언어 단어 빈도 계산 코드를 테스트해 본 결과, 웜 캐시 상태에서도 **278 MB/s**라는 실망스러운 속도가 나왔습니다. 디스크 읽기 속도(1.6 GB/s)에 한참 못 미치는 수치입니다.

* **원인 분석:** 루프 내에 많은 분기문(Branch)이 있어 컴파일러의 **자동 벡터화(Auto-vectorization)**를 방해하고 있었습니다.
* **개선 시도:** 소문자 변환 로직을 루프 밖으로 빼는 등 약간의 수정을 거쳐 **330 MB/s**까지 끌어올렸으나, 여전히 디스크 속도보다 5배나 느렸습니다.

### 3. 리눅스 기본 도구 `wc -w`의 성능

가장 단순한 작업인 단어 수 세기 전용 도구 `wc`는 어떨까요?

* **결과:** **245.2 MB/s**로 생각보다 매우 느렸습니다.
* **이유:** `wc`는 단순 공백(' ')뿐만 아니라 탭, 줄 바꿈, 로케일별 특수 문자 등을 모두 처리해야 하므로 범용적인 대신 느립니다.

### 4. 극한의 최적화: AVX2 벡터화

저자는 지난 10년간 비약적으로 발전한 CPU의 기능을 활용하기 위해 **SIMD(AVX2)**를 직접 사용하여 코드를 작성하기로 했습니다.

* **핵심 기술:**
1. **256비트 레지스터:** 한 번에 32개의 문자를 처리.
2. **VPCMPEQB:** 레지스터 내에서 공백 문자를 찾아 마스크(Mask)를 생성.
3. **PMOVMSKB & 비트 트릭:** 생성된 마스크를 32비트 정수로 변환한 뒤, 비트 연산(`ffs` 등)을 통해 단어의 시작과 끝을 빠르게 계산.
4. **루프 언롤링(Unrolling):** 루프를 4배로 풀어 한 번에 128바이트의 데이터를 처리.

- 결과적으로 Warm Cache 기준 **1.45 GB/s** CPU가 거의 100% 사용됨

### ### 결론

* **I/O는 더 이상 병목이 아니다:** 단일 스레드에서 가장 빠른 벡터화 명령어를 사용하여 단어 수만 세는 단순 작업을 수행하더라도, 겨우 **Cold Cache 디스크 읽기 속도(1.6 GB/s)의 약 90%** 정도만 따라잡을 수 있었습니다.
* **웜 캐시 기준:** CPU 처리 속도(1.45 GB/s)는 메모리에 올라온 데이터 읽기 속도(12.8 GB/s)의 **약 11%** 수준에 불과합니다.
* **시사점:** 이제 하드웨어(NVMe SSD 등)의 발전 속도가 소프트웨어와 CPU의 처리 능력을 앞질렀습니다. 복잡한 로직이 들어가는 프로그램이라면 병목은 십중팔구 I/O가 아닌 CPU에서 발생할 것입니다.
