#pragma once
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include <map>
#include <string>
#include <array>
#include <set>
#include <memory>

//동적으로 할당한 배열보다는 vector와 string이 낫다

namespace Item13 {
	using namespace std;

	/*
		언제든 배열을 동적으로 할당할 자세를 잡고 코딩에 들어가기 전에(이를테면 "new T[...]"라고 쓰려고 생각했다든지), 그 대신 vector나, string을 고려해 보세요
		(대개 T가 문자 타입이면 string을, T가 이외의 타입이면 vector를 사용합니다).

		- vector와 string은 자체적으로 메모리 관리를 하기 때문에 프로그래머가 져야 부담을 없애줍니다.
	*/

	/*
		많은 제품들이 string을 참조 카운팅이 동작되도록 구현함으로써(이 부분은 항목 15를 참고하시고요), 
		불필요한 메모리 할당과 문자 복사를 없앰으로써 많은 어플리케이션에서 높은 수행성능을 낼 수 있도록 하고 있습니다. 
		
		이 또한 동적으로 할당한 문자 배열 대신에 string을 사용해야할 이유가 됩니다.

		여러분이 사용하고 있는 STL 제품에서 구현된 string이 참조 카운팅이 되는 것인지 확인하는 가장 쉬운 방법은 해당 라이브러리 문서를 찾아보는 것입니다.
		
		다른 방법은(추천하는 방법은 아니지만, 꼭 필요하다면 어쩔 수 없이 봐야 하는 경우가 있습니다) string이 구현된 라이브러리 소스를 직접 살펴보는 것입니다.
		
		string은 basic_string<char>의 typedef 타입이라는 것만 잊지 마시고(wstring은 basic_string<w_char>의 typedef 타입입니다), 
		소스를 볼 때는 basic_string의 템플릿 소스를 찾으십시오.
		
		소스를 볼 때 참조 카운팅 여부를 체크할 수 있는 포인트는 클래스의 복사 생성자입니다. 
		이 부분에서 참조 카운트 값을 증가시키는 코드 비슷한 것이 있나 찾으면 됩니다.

		사용하고 계신 string이 참조 카운팅이 되는데 이것을 다중 쓰레드 환경에서 사용하기에는 수행 성능의 저하가 만만치 않다고 생각하셔도, 
		STL을 버리지 않고 선택할 수 있는 길이 세 가지나 있습니다.

		라이브러리에서 참조 카운팅 기능을 끌 수 있는 방법이 있는지 조사하는 것입니다. 
		대개 전처리자의 변수 값을 바꿈으로 이것이 가능하게 되어 있습니다. 물론 이렇게 만든 코드는 이식이 되지 않습니다만, 
		필요한 수작업의 양을 고려한다면 충분히 가치는 있습니다.

		참조 카운팅을 사용하지 않는 다른 string을 구현(아니면 부분만 구현)하는 것입니다.
		string 대신에 vector<char>를 고려해 보는 것입니다. 
		vector는 원래부터 참조 카운팅을 하지 않도록 구현되어 있어서 다중 쓰레드 환경에서의 수행 성능 문제가 발생할 틈이 없습니다. 
		물론, string만 가지고 있는 깔끔한 멤버 함수들(substr이나 find_if 등등)은 쓸 수 없는 아픔이 있지만 대부분의 기능은 STL 표준 알고리즘으로 어떻게든 구현되기 때문에, string스럽지 않은 모양을 제외하면 잃은 것이 별로 없습니다.
	
	*/
}