#include <iostream>
#include <vector>
#include <string>
using namespace std;

namespace Item30 {
	//인라인 함수는 미주알고주알 따져서 이해해 두자

	/*
		인라인 함수의 원리는 함수 호출문을 그대로 함수의 본문으로 바꿔치기 하는 것
		함수 호출의 오버헤드를 없애고, 문맥별(context-specific) 최적화를 걸기가 용이해진다

		만약 길이가 짧은 함수가 아니라면 위의 방법은 오히려 코드의 길이가 늘어나게하기 때문에 오히려 비효율적
		메모리를 많이 잡아먹을 뿐만 아니라 가상 메모리 사용시 페이징 횟수가 늘어나고 명령어 캐시 적중률이 떨어진다

		때문에 inline 키워드는 컴파일러에게 해당 함수를 인라인화 해달라고 '요청'하는 것이지, '명령'이 아니다.
		inline을 붙이더라도 인라인 함수가 되지 않는 경우가 있고, inline이 없어도 컴파일러가 암시적으로 인라인 함수로 만드는 경우가 있다.


		함수 인라인은 작고, 자주 호출되는 함수에 대해서만 하는 것으로 묶어둡시다. 
		이렇게 하면 디버깅 및 라이브러리이 바이너리 업그레이드가 용이해지고, 자칫 생길 수 있는 코드 부풀림 현상이 최소화되며, 
		프로그램의 속력이 더 빨라질 수 있는 여지가 최고로 많아집니다.

		※ 생성자와 소멸자는 인라인으로 만들기에 그리 좋지 않은 함수입니다. 
		왜냐하면 생성자나 소멸자 내에는 부모 클래스의 생성자나 소멸자, 그리고 멤버 객체들의 생성자나 소멸자를 호출하는 코드가 포함되기 때문입니다
		(생성자와 소멸자는 크기가 클 가능성이 큽니다).

		함수 템플릿이 대개 헤더 파일에 들어간다는 일반적인 부분만 생각해서 이들을 inline으로 선언하면 안 됩니다.
	*/

	class Person {
	public:
		int age() const { return theAge; }	//클래스 정의 내부에서 정의된 멤버 함수는 암시적으로 인라인 요청된다.
	private:
		int theAge;
	};

	/*
		인라인 함수와 템플릿은 대개 헤더 파일 안에 정의한다.
		두 가지 모두 컴파일 시간에 컴파일러가 알아야 하기 때문에 main() 함수가 호출되기 이전 헤더파일에 정의 되어야 한다.

		생성자와 소멸자 같은 경우는 인라인하기에 좋다고 볼 수 없다. 
		-> 생성자와 소멸자 동작에는 컴파일러에 따라 객체 생성과 소멸과 연관되는 예외처리 및 다른 동작들이 들어갈 수 있기 때문

		컴파일러에서 인라인화 해주지 않는 특별한 경우가 있다.
		-> 가상함수 호출
		
		인라인화 해주면서도 인라인 함수 본문을 기계어로 만드는 경우가 있다.
		-> 인라인 함수의 주소를 취하는 함수 포인터가 있는 경우
	*/

	inline void f() {}	//컴파일러 인라인화 해주는 조건을 만족했을 시

	void func() {
		void(*pf)() = f;	//f 를 가리키는 함수 포인터

		f();	//이 호출은 인라인된다. "평범한" 함수 호출
		pf();	//이 호출은 인라인화 되지 않는다. 함수 포인터를 통해 호출
	}

	/*
		라이브러리 설계에서도 인라인 함수는 중요하다.

		특정 라이브러리를 사용하는 입장에서 인라인 함수 f()를 사용하는데
		라이브러리 개발자가 f()의 내부를 변경해야 한다면, 해당 라이브러리 명령어를 사용하는 모든 프로그램이 재컴파일을 해야한다.

		하지만 f()가 인라인 함수가 아닐 때에는 내부가 변경되어도, 재컴파일이 아닌 링킹 과정만 다시 수행해 주면 문제없다.
	*/
}