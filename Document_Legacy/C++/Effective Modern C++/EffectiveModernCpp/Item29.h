#pragma once
#include <iostream>
#include <vector>
#include <string>
#include <array>

//이동 연산들이 존재하지 않고, 저렴하지 않고, 적용되지 않을 것이라고 가정하라.

namespace Item29 {

	/*
		 이동 의미론을 지원하지 않는 타입들이 적지 않다
		
		C++11은 C++98 표준 라이브러리를 전체적으로 개정했는데, 
		특히 이동을 복사보다 빠르게 구현할 수 있는 타입들에는 이동 연산들을 추가했다. 
		또한 라이브러리 구성요소들의 구현을 그런 연산들의 장점을 취하도록 개정했다.

		일부 프로그래머들이 다루는 코드 기반은 C++11의 장점을 취하도록 완전히 개정되지 않았을 가능성이 있다. 
		여러분의 응용 프로그램(또는 여러분이 사용하는 라이브러리)에 있는 타입들이 C++11에 맞게 완전히 수정되지 않았다면, 
		컴파일러가 이동을 지원한다고 해도 응용 프로그램의 성능이 저절로 높아지지는 않을 것이다.

		*클래스 내 소멸자/사용자 정의 복사 연산이 선언되었을 시 이동연산자가 자동 생성되지 않는 점
		* C++11 표준 라이브러리의 모든 컨테이너는 이동을 지원하지만, 모든 컨테이너의 이동이 저렴하지는 않다는 것

		-> std::array : 내장 배열에 std 인터페이스를 씌운 것으로 내용물을 힙에 저장하는 다른 컨테이너들과 다르다.
		이동 연산이 저렴한 것은 힙에 할당된 메모리를 가리키는 포인터 복사 비용만 지불하기 때문이지만, 
		std::array에는 그런 포인터가 없고 배열값이 객체 자체에 전달된다. 따라서 원소들을 전부 일일이 이동시켜야 한다.

		-> std::string 문자열 구현 중에는 작은 문자열 최적화(small string optimization, SSO)를 사용하는 것이 많다.
		SSO 의 경우 크기가 작은 문자열(예를 들어 용량이 15자 이하)에 대해서는 값들을 힙에 할당하지 않고 string 객체 안에 저장하는 것이다.
		이 경우, 이동 연산이 복사연산에 비해 크게 빠르다고 볼 수 없다.

		빠른 이동을 지원하는 타입에서도, 겉으로 보기에 이동이 일어날 만한 상황에서 사실은 복사가 일어나는 경우가 생기기도 한다.

		-> 표준 라이브러리의 일부 컨테이너 연산들은 강한 예외 안전성을 보장한다.
		이를 위해 이동 연산들이 예외를 던지지 않음이 확실한 경우에만 바탕 복사 연산들을 이동 연산들로 대체한다.

		이 때문에, 해당 복사 연산보다 효율적인 이동 연산을 제공하는 타입이라고 해도,
		그리고 코드의 특성 지점에서 일반적으로 이동 연산이 적합하다고 해도,
		해당 이동 연산이 noexcept로 선언되어 있지 않으면 컴파일러는 여전히 복사 연산을 호출할 수 있다.

	*/


	/*
		
		C++11에서 이동 의미론이 크게 도움이 되지 않는 시나리오
		- 이동 연산이 없다: 이동할 객체가 이동 연산들을 제공하지 않는다. 이 경우 이동 요청은 복사 요청이 된다.
		- 이동이 더 빠르지 않다: 이동할 객체의 이동 연산이 해당 복사 연산보다 빠르지 않다.
		- 이동을 사용할 수 없다: 이동이 일어나려면 이동 연산이 예외를 방출하지 않아야 하는 문맥에서, 해당 연산이 noexcept로 선언되어 있지 않다.
		- 원본 객체가 좌측값이다: 아주 드문 경우(이를테면 항목 25)이지만, 오직 우측값만 이동 연산의 원본이 될 수 있는 경우도 있다.


	*/
}