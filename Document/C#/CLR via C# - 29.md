단순 스레드 동기화 요소는 크게 두 가지로 구분할 수 있습니다.

*   유저모드 동기화 요소
*   커널모드 동기화 요소

# 유저모드 동기화

대표적으로 아래의 두 가지가 있습니다.

*   Volatile
*   Interlocked

## Volatile

C# 의 컴파일 단계에서 수행하는 최적화는 멀티스레딩 환경에서 문제를 유발할 수 있습니다.

*   메모리 load/store 동작의 경우, 비용이 비싼 편이기 때문에 최적화 단계에서 동작의 순서가 변경될 수 있습니다. 싱글스레드라면 이때 문제가 되지는 않겠지만 멀티스레딩 환경에서는 dirtyRead 등의 문제가 발생할 수 있습니다.

Volatile 동기화 요소는 아래의 특징을 가집니다.

*   Volatile.Write/Read 의 경우 c# 컴파일러에서 수행하는 최적화의 대상이 되지 않습니다.
*   메모리 팬스/메모리 배리어 :
    **Volatile.Write** 메서드는 이 메서드를 호출한 위치에서 그 값이 반드시 쓰여질 것임을 보장하고, 프로그램 코드의 순서상 이 코드를 호출한 윛보다 앞쪼겡서 수행된 로드(load)/스토어(store) 과정은 반드시 이 코드보다 앞서 수행될 것임을 보장합니다.
    **Volatile.Read** 메서드는 이 메서드를 호출한 위치에서 그 값이 반드시 읽혀질 것임을 보장하고, 프로그램 코드 순서상 이 코드 이후에 위치한 로드(load)/스토어(store) 과정은 반드시 이 메서드가 수행된 이후에 수행될 것임을 보장합니다.
*   CPU 레지스터 캐싱 방지 : Volatile 키워드를 사용하면 C# 컴파일러와 JIT 컴파일러에게 이 필드의 값을 CPU 레지스터에 캐싱하지 않도록 하며, 항상 메모리로부터 값을 읽고 쓰도록 합니다.

## Interlocked

Interlocked 동기화 요소는 다양한 연산 (Add, And, CompareExchange 등등) 을 원자적으로 처리할 수 있도록 하며 메모리 펜스(memory fence) 기능을 제공합니다.

*   Interlocked 메서드는 CPU 명령어 레벨에서 지원하는 원자적 연산 동작을 사용합니다. 따라서 Interlocked 메서드의 속도는 lock 등의 다른 동기화 요소에 비해 상대적으로 빠른 편입니다.
*   Interlocked 메서드의 메모리 펜스 기능은, Interlocked 메서드를 호출하기 이전에 수행된 쓰기 작업은 반드시 Interlocked 메서드 호출 이전에 호출될 것임을 보장하고, Interlocked 이후에 호출한 읽기 작업은 반드시 Interlocked 메서드 호출 이후에 수행될 것임을 보장하는 것을 말합니다.

## SpinLock

*   스레드간의 경쟁 상태가 발생하면 블록킹되는 스레드가 while 루프문 안에서 반복해서 루프를 돌게 합니다.
*   이때 cpu 시간을 허비하게 되므로 스핀락 방식은 짧고 금방 벗어나는 구간에 대해서 사용하는 것이 좋습니다.

# 커널모드 동기화

커널 모드 동기화 요소는 유저 모드 동기화 요소에 비해서 상당히 느립니다. 커널 모드 동기화 요소들이 운영체제에게 스레드 간의 동기화를 요청하는 것이기 때문입니다.

*   커널 전환 과정은 상당한 cpu 시간 ( 수백 사이클 ) 을 소비하기 때문에, 자주 발생할 경우 응용프로그램의 전체적인 성능에 나쁜 영향을 미치게 됩니다.

유저모드 동기화 요소에 비하면 저수준 레벨에 해당하는 동작이고 유저 모드 동기화와 비교하면 아래의 장점을 제공합니다.

*   리소스에 대한 경쟁 상태를 확인할 수 있어서, 운영체제에게 관련 스레드가 더 이상 CPU 시간으로 허비하지 않도록 하여, 프로세서 자원을 낭비하지 않도록 합니다. ( 커널 레벨에서 스레드를 재워버림 )
*   스레드 보안/ 네이티브 스레드 관리, 다른 프로세스의 스레드 관리 등 저수준 단계의 동작 지원

주요 커널 동기화 요소

*   이벤트(event)
*   세마포어(semaphore)

(뮤텍스의 경우, 위의 두 가지 요소를 근간으로 만들어진 것)

## 이벤트

이벤트는 커널에서 관리되는 단순한 bool 변수입니다. 이벤트가 false이면 스레드가 블로킹되고 true 일때에는 블로킹이 해제됩니다.

## 세마포어

세마포어는 커널에서 관리되는 단순한 int 변수입니다. 세마포어의 값이 0이면 스레드들은 블로킹되고 0보다 크면 블로킹이 해제됩니다. 세마포어를 대기하던 스레드가 블록킹이 해제되면, 세마포어의 값은 1만큼 늘어납니다. 세마포어는 사용자가 설정할 수 있는 최댓값을 가질 수 있어서 현재 세마포어 카운트 값은 이 값을 초과할 수 없습니다.
