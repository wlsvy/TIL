# 제프리 리처의 CLR via C# 4판

## 1장. CLR의 실행 모델

<details>
  <summary>fold/unfold</summary>

### 공용 언어 런타임(CLR, Common Language Runtime)
- 서로 다른 프로그래밍 언어들 사이에서 공동으로 사용할 수 있는 실행환경(Runtime)을 말합니다.
- CLR을 지원하는 언어라면 CLR의 기능(메모리 관리, 어셈블리 로딩, 스레드 동기화 등)을 자유롭게 사용할 수 있습니다.

<img src="https://1.bp.blogspot.com/-g9AYNMBpG1s/U7Qii8mJm_I/AAAAAAAAAqg/bTFteXucTQA/s1600/2014-07-02_111719.png" width="40%" height="40%">

- CLR은 관리모듈을 실행시킵니다. 관리 모듈(managed module)이란 CLR을 지원하는 프로그래밍 언어를 컴파일한 결과물로 크게 IL과 메타데이터로 이루어집니다.

### 메타데이터(metadata)
- 메타데이터는 모듈 내의 타입과 그들의 구성 멤버 등의 대한 데이터 테이블입니다.
  - 테이블은 크게 두 종류로 나누어집니다. 하나는 소스 코드에 포함된 타입들과 그 멤버들의 정보, 다른 하나는 소스 코드가 참조하는 타입들과 멤버들에 대한 정보입니다.
- 프로그램 실행 파일이 생성될 시 메타데이터는 해당 파일 안에 포함됩니다.
- visual studio의 인텔리센스는 메타데이터를 활용합니다.
- 메타데이터는 각각의 객체(object)들이 메모리 블록 안에 serialization 할 수 있도록 합니다. 이후 deserialization을 거쳐서 객체가 원래 상태로 복원될 수 있습니다.
- 가비지 컬렉터(garbage collector)가 객체의 생명주기를 추적할 때 메타데이터를 활용합니다.

### 어셈블리(assembly)
CLR은 실제로 모듈들을 다루지는 않으며, 어셈블리를 다루게 됩니다. 어셈블리는 명확하게 정의하기엔 추상적인 개념이며 아래와 같습니다.

- 하나의 어셈블리는 하나 이상의 모듈이나 리소스 파일들에 대한 논리적 그룹입니다.
- 하나의 어셈블리는 재사용, 보안, 버전 관리의 가장 작은 단위입니다.

<img src="https://i.stack.imgur.com/s6gSO.png" width="60%" height="60%">

위의 그림에서 다수의 모듈과 리소스 파일이 결합되어 하나의 어셈블리로 만들어집니다.
- 매니페스트 : 어셈블리 안의 모듈 및 리소스 파일들의 집합을 설명합니다.

### 어셈블리 실행

<img src="https://i.stack.imgur.com/LXVmH.png" width="60%" height="60%">

위의 그림에서 JIT(just in time) 컴파일러가 IL 명령어를 실행하는 과정은 대략 아래와 같습니다.

1. Main 메서드가 실행되기 바로 직전에, CLR은 main 메서드 안에서 참조된 모든 타입들을 파악합니다. 이때 CLR은 내부적으로 자료구조를 생성해 참조된 타입을 관리하는 용도로 사용합니다.
2. Main 메서드가 WriteLine 메서드를 호출할 때 JIT 컴파일러가 호출됩니다. 컴파일러는 메서드의 IL 코드를 네이티브 CPU 명령어로 컴파일합니다. 
3. CLR은 메모리를 동적할당한 뒤 해당 공간에 네이티브 cpu 명령어를 저장합니다.
4. CLR은 새로 생성된 네이티브 cpu 명령어의 메모리 주소를 저장합니다.
5. 실제 코드를 실행합니다.
6. 두번째로 WriteLine 메서드를 호출할 때 CLR은 이미 WriteLine 메서드에 대한 코드를 이미 검사하였고 컴파일이 완료했다는 사실을 확인합니다. 곧바로 네이티브 cpu 명령어가 저장된 메모리로 이동해 코드를 실행합니다. 추가적인 jit 컴파일러 호출은 없습니다.


- 성능 저하는 메서드가 최초로 호출될 때에만 발생합니다.
- JIT 컴파일러는 생성한 네이티브 cpu 명령어를 동적 메모리상에 저장하며 응용프로그램이 종료될 때 자동으로 반환합니다.

### IL과 검증, 안전하지 않은 코드
- IL은 스택 기반의 언어로 모든 IL 명령어들과 연산자가 실행 스택 위에 쌓이고 꺼내어가는 방식으로 실행됩니다.
- IL의 가장 큰 장점은 cpu 내부로부터 추상화된 동작들에 대한 것이 아닙니다. 응용프로그램의 견고함과 보안을 책임진다는 것에 더 의의가 있습니다.
  - IL을 네이티브 CPU 명령어로 컴파일하는 동안, CLR은 확인(verification) 과정을 통해 코드를 검사하고 안전성을 점검합니다.
  - 확인 과정을 통하여 메모리를 잘못된 방향으로 접근하거나 사용하지 않으며, 다른 응용프로그램 코드에 역으로 영향을 주는 일이 없게 합니다. 대표적인 예로 응용프로그램의 물리 메모리와 가상 메모리 주소가 달라 잘못 접근하는 경우를 방지하는 경우가 있습니다.
- C# 컴파일러는 기본적으로 안전한 코드를 만듭니다. 안전한 코드는 확인 과정을 안전하게 통과할 수 있습니다. 반면에 안전하지 않은 코드를 사용하는 경우도 있는데 unsafe 키워드를 추가해서 작성할 수 있습니다. 직접 메모리에 접근하거나 비관리 코드와의 상호운용을 할때 유용합니다.

### 공용 언어 사양
- 공용 타입 시스템(CTS, Common Type System) : 마이크로소프트는 공용 타입 시스템(CTS) 표준을 정의하여 CLR 에서 타입이 어떻게 정의되어야 하고 동작되어야 하는지 명시하고 있습니다.
  - 모든 타입은 미리 정의된 타입인 System.Object 를 상속받습니다.

- CLR은 서로 다른 언어 사이에서 통신할 수 있게 해주는 것 이상으로 모든 언어들을 연계하고 어떤 언어로 쓰인 객체가 다른 언어에서도 완전히 동일한 의미와 사용법을 가지는 동등한 객체로 인지할 수 있게 해줍니다.
  - 이러한 통합이 가능한 이유는 CLR의 표준 타입 집합들과 메타데이터 그리고 공용 실행 환경(Common Execution Environment) 덕분입니다.
- 공용 언어 사양(CLS, Common Language Specification) : 마이크로소프트는 공용 언어사양을 정의하여 컴파일러를 제조할 때 준수해야 할 최소한의 사항들을 정의합니다. 여기에는 다른 CLR 위에서 동작하는 언어들 사이에서 반드시 지원해야할 내용들을 포함합니다.
  - 공용 언어 사양을 통해 언어 사이의 공통적인 규칙이 필수적으로 포함될 수 있게 되었으며 CLR은 이를 통해서 다양한 언어간의 상호 연계를 가능하게 합니다.

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRLR0g7k3JcNHoagiCnQjDYZEEjiDnLTYpKkQ&usqp=CAU" width="40%" height="40%">

</details>
