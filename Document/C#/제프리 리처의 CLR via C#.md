# 제프리 리처의 CLR via C# 4판

## 1장. CLR의 실행 모델

<details>
  <summary>fold/unfold</summary>

### 공용 언어 런타임(CLR, Common Language Runtime)
- 서로 다른 프로그래밍 언어들 사이에서 공동으로 사용할 수 있는 실행환경(Runtime)을 말합니다.
- CLR을 지원하는 언어라면 CLR의 기능(메모리 관리, 어셈블리 로딩, 스레드 동기화 등)을 자유롭게 사용할 수 있습니다.

<img src="https://1.bp.blogspot.com/-g9AYNMBpG1s/U7Qii8mJm_I/AAAAAAAAAqg/bTFteXucTQA/s1600/2014-07-02_111719.png" width="40%" height="40%">

- CLR은 관리모듈을 실행시킵니다. 관리 모듈(managed module)이란 CLR을 지원하는 프로그래밍 언어를 컴파일한 결과물로 크게 IL과 메타데이터로 이루어집니다.

### 메타데이터(metadata)
- 메타데이터는 모듈 내의 타입과 그들의 구성 멤버 등의 대한 데이터 테이블입니다.
  - 테이블은 크게 두 종류로 나누어집니다. 하나는 소스 코드에 포함된 타입들과 그 멤버들의 정보, 다른 하나는 소스 코드가 참조하는 타입들과 멤버들에 대한 정보입니다.
- 프로그램 실행 파일이 생성될 시 메타데이터는 해당 파일 안에 포함됩니다.
- visual studio의 인텔리센스는 메타데이터를 활용합니다.
- 메타데이터는 각각의 객체(object)들이 메모리 블록 안에 serialization 할 수 있도록 합니다. 이후 deserialization을 거쳐서 객체가 원래 상태로 복원될 수 있습니다.
- 가비지 컬렉터(garbage collector)가 객체의 생명주기를 추적할 때 메타데이터를 활용합니다.

### 어셈블리(assembly)
CLR은 실제로 모듈들을 다루지는 않으며, 어셈블리를 다루게 됩니다. 어셈블리는 명확하게 정의하기엔 추상적인 개념이며 아래와 같습니다.

- 하나의 어셈블리는 하나 이상의 모듈이나 리소스 파일들에 대한 논리적 그룹입니다.
- 하나의 어셈블리는 재사용, 보안, 버전 관리의 가장 작은 단위입니다.

<img src="https://i.stack.imgur.com/s6gSO.png" width="60%" height="60%">

위의 그림에서 다수의 모듈과 리소스 파일이 결합되어 하나의 어셈블리로 만들어집니다.
- 매니페스트 : 어셈블리 안의 모듈 및 리소스 파일들의 집합을 설명합니다.

### 어셈블리 실행

<img src="https://i.stack.imgur.com/LXVmH.png" width="60%" height="60%">

위의 그림에서 JIT(just in time) 컴파일러가 IL 명령어를 실행하는 과정은 대략 아래와 같습니다.

1. Main 메서드가 실행되기 바로 직전에, CLR은 main 메서드 안에서 참조된 모든 타입들을 파악합니다. 이때 CLR은 내부적으로 자료구조를 생성해 참조된 타입을 관리하는 용도로 사용합니다.
2. Main 메서드가 WriteLine 메서드를 호출할 때 JIT 컴파일러가 호출됩니다. 컴파일러는 메서드의 IL 코드를 네이티브 CPU 명령어로 컴파일합니다. 
3. CLR은 메모리를 동적할당한 뒤 해당 공간에 네이티브 cpu 명령어를 저장합니다.
4. CLR은 새로 생성된 네이티브 cpu 명령어의 메모리 주소를 저장합니다.
5. 실제 코드를 실행합니다.
6. 두번째로 WriteLine 메서드를 호출할 때 CLR은 이미 WriteLine 메서드에 대한 코드를 이미 검사하였고 컴파일이 완료했다는 사실을 확인합니다. 곧바로 네이티브 cpu 명령어가 저장된 메모리로 이동해 코드를 실행합니다. 추가적인 jit 컴파일러 호출은 없습니다.


- 성능 저하는 메서드가 최초로 호출될 때에만 발생합니다.
- JIT 컴파일러는 생성한 네이티브 cpu 명령어를 동적 메모리상에 저장하며 응용프로그램이 종료될 때 자동으로 반환합니다.

### IL과 검증, 안전하지 않은 코드
- IL은 스택 기반의 언어로 모든 IL 명령어들과 연산자가 실행 스택 위에 쌓이고 꺼내어가는 방식으로 실행됩니다.
- IL의 가장 큰 장점은 cpu 내부로부터 추상화된 동작들에 대한 것이 아닙니다. 응용프로그램의 견고함과 보안을 책임진다는 것에 더 의의가 있습니다.
  - IL을 네이티브 CPU 명령어로 컴파일하는 동안, CLR은 확인(verification) 과정을 통해 코드를 검사하고 안전성을 점검합니다.
  - 확인 과정을 통하여 메모리를 잘못된 방향으로 접근하거나 사용하지 않으며, 다른 응용프로그램 코드에 역으로 영향을 주는 일이 없게 합니다. 대표적인 예로 응용프로그램의 물리 메모리와 가상 메모리 주소가 달라 잘못 접근하는 경우를 방지하는 경우가 있습니다.
- C# 컴파일러는 기본적으로 안전한 코드를 만듭니다. 안전한 코드는 확인 과정을 안전하게 통과할 수 있습니다. 반면에 안전하지 않은 코드를 사용하는 경우도 있는데 unsafe 키워드를 추가해서 작성할 수 있습니다. 직접 메모리에 접근하거나 비관리 코드와의 상호운용을 할때 유용합니다.

### 공용 언어 사양
- 공용 타입 시스템(CTS, Common Type System) : 마이크로소프트는 공용 타입 시스템(CTS) 표준을 정의하여 CLR 에서 타입이 어떻게 정의되어야 하고 동작되어야 하는지 명시하고 있습니다.
  - 모든 타입은 미리 정의된 타입인 System.Object 를 상속받습니다.

- CLR은 서로 다른 언어 사이에서 통신할 수 있게 해주는 것 이상으로 모든 언어들을 연계하고 어떤 언어로 쓰인 객체가 다른 언어에서도 완전히 동일한 의미와 사용법을 가지는 동등한 객체로 인지할 수 있게 해줍니다.
  - 이러한 통합이 가능한 이유는 CLR의 표준 타입 집합들과 메타데이터 그리고 공용 실행 환경(Common Execution Environment) 덕분입니다.
- 공용 언어 사양(CLS, Common Language Specification) : 마이크로소프트는 공용 언어사양을 정의하여 컴파일러를 제조할 때 준수해야 할 최소한의 사항들을 정의합니다. 여기에는 다른 CLR 위에서 동작하는 언어들 사이에서 반드시 지원해야할 내용들을 포함합니다.
  - 공용 언어 사양을 통해 언어 사이의 공통적인 규칙이 필수적으로 포함될 수 있게 되었으며 CLR은 이를 통해서 다양한 언어간의 상호 연계를 가능하게 합니다.

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRLR0g7k3JcNHoagiCnQjDYZEEjiDnLTYpKkQ&usqp=CAU" width="40%" height="40%">

</details>

## 4장. 타입의 기초

<details>
<summary>fold/unfold</summary>

### 모든 타입은 System.Object를 상속한다.

#### Reference
- [Microsoft : Object Class](https://docs.microsoft.com/en-us/dotnet/api/system.object?view=net-5.0)
---

- 모든 타입들은 궁극적으로 System.Object 타입으로부터 파생됩니다.
- 따라서 C#의 모든 객체는 System.Object의 public/protected 메서드(GetHashCode, ToString 등)를 사용할 수 있습니다.

```cs
//아래 두 클래스 선언은 동일합니다.

class Widget 
{

}

class Widget : System.Object
{

}


```

- CLR은 모든 객체들을 반드시 new 연산자에 의하여 만들어지도록 하고 있습니다. 
```cs
Widget widget = new Widget("Construct Param");
```

- new 연산자는 아래의 일을 합니다.
  - 할당하려는 타입과 System.Object 타입, 그리고 System.Object를 상속받은 모든 기본 타입들에서 정의된 모든 인스턴스 필드들을 메모리에 할당하기 위한 바이트 수를 계산합니다.
     - 힙상의 모든 객체에는 타입 객체 포인터(Type Object Pointer)와 동기화 블록 인덱스(Sync Block Index)가 추가됩니다. CLR은 두 멤버를 통해 객체를 관리합니다.
     - 추가 멤버들을 위한 바이트는 객체의 실제 크기에 포함됩니다.
  - 필요한 만큼 메모리를 할당합니다. 처음 할당할 때 모든 바이트를 0으로 초기화합니다.
  - 객체의 타입 객체 포인터와 동기화 블록 인덱스 멤버를 초기화합니다.
  - 생성자를 호출하고 new 연산자에 서술된 매개변수가 전달됩니다. 파생클래스의 생성자 부터 호출되며 System.Object의 생성자가 가장 마지막에 호출됩니다.


### 타입 간 캐스팅하기

- CLR의 중요한 기능들 중 하나는 타입 안전성입니다. 실행 시점에서 CLR은 객체의 정확한 타입이 무엇인지 항상 파악하고 있습니다.

```cs

    //암시적으로 System.Object를 상속합니다.
    internal class Widget { }
    
    public sealed class Program
    {
        public static void Main()
        {
            Object o = new Widget(); //암시적 변환이며, 안전합니다.

            //Object 타입으로부터 Widget 클래스를 타입이 파생되었기 때문에 명시적 형 변환 연산자가 필요합니다.
            //경우에 따라 런타임 오류가 발생할 수 있습니다.
            Widget w = (Widget)o;
        }
    }

```
### C#의 is와 as 연산자로 캐스팅하기
- C#에서 캐스팅 연산을 다룰 때 is/as 를 활용할 수 있습니다.

```cs
    Object o = new Object();
    Boolean result1 = o is Object;  //true
    Boolean result2 = o is Widget;  //false
```
- 아래와 같이 활용할 수 있으나, 아래의 경우는 CLR 이 타입을 두 번 점검합니다.

```cs
    //if 문에서 한번 검사합니다.
    if(o is Widget)
    {
        //명시적 형변환을 수행하면서 또 한번 검사합니다.
        Widget w = (Widget)o;
    }
```

- 위와 같은 상황을 방지하기 위해 as 연산자를 사용할 수 있습니다.
```cs
    //여기서 한번 타입을 점검합니다.
    Widget w = o as Widget;
    if(w != null)
    {
        //여기서 w를 사용합니다.
    }
```

### 실행 시점과의 연관성

- 아래는 M1 메서드가 호출되기 직전의 스레드 스택의 상태입니다. 할당된 스레드에서 M1 메서드를 호출할 것입니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-2.jpg" width="40%" height="40%">

- 대게 메서드들은 프롤로그 코드(Prologue Code)를 포함하며 메서드 안의 코드가 동작하도록 초기화를 거치게 합니다.
- 여기에 대응되는 에필로그 코드(Epilogue Code)도 있어서 메서드 실행 후의 정리 작업을 수행하게 합니다. 그리고 원래 호출자에게 돌아갈 수 있게 준비합니다.


- 아래에서 프롤로그 코드는 스레드 스택에 지역변수를 위한 메모리 공간을 할당합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-3.jpg" width="40%" height="40%">

- 아래에서 M2 메서드를 호출합니다. 메서드로 넘길 매개변수와 호출이 끝나고 되돌아갈 위치를 나타내는 주소값이 스택에 올라갑니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-4.png" width="40%" height="40%">

- M2 메서드의 지역변수가 스택에 올라갑니다. M2 메서드가 종료되면 리턴 주소를 확인해 다시 M1 메서드를 수행하던 위치로 되돌아갈 것입니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-5.jpg" width="40%" height="40%">



- 이제 아래의 두 클래스가 정의되어 있다고 가정합시다.

```cs

    public internal class Employee
    {
        public Int32 GetYearsEmployed() { ... }
        public virtual string GetProgressReport() { ... }
        public static Employee Lookup(string name) { ... }
    }

    public internal class Manager : Employee
    {
        public override string GetProgressReport() { ... }
    }
```

- 처음에 Windows 프로세스가 실행되고, CLR이 로드되고, managed heap이 초기화되고, 스택공간과 스레드가 할당될 것입니다. 이 스레드는 초기 코드를 실행한 상태고 이제 M3 메서드를 호출하려고 합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-6.png" width="40%" height="40%">

- JIT 컴파일러가 M3 메서드의 IL 코드를 컴파일하면서 M3 메서드 안의 타입들과 변수 정보에 대해서 파악합니다.
  - 이 시점에서 CLR은 이러한 타입들을 포함하는 어셈블리들을 로드할 것이며, 어셈블리의 메타데이터를 통해 타입 정보를 추출하여 타입에 대한 정보를 서술하는 또다른 자료 구조를 생성합니다.
  - 아래 그림에서 Int32와 string 과 같은 기본적인 타입 정보는 이미 올라와 있다고 가정하며 나타내지 않습니다.

- 아래 그림처럼 힙 위에 만들어지는 모든 객체는 타입 객체 포인터와 동기화 블록 인덱스 멤버를 추가적으로 가집니다.
- 타입을 선언할 때 정의된 정적 데이터는 타입 객체 안에 포함됩니다. 그리고 타입 객체가 생성되는 시점에 초기화됩니다.
- 마지막으로 타입 내의 메서드 하나당 한 개의 항목이 포함된 메서드 테이블도 만들어지게 됩니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-7.png" width="40%" height="40%">

- 스레드의 스택상에 지역 변수를 위한 메모리를 할당합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-8.png" width="40%" height="40%">

- 매니저 객체가 생성됩니다. 역시 타입객체 포인터와 동기화 블록 인덱스를 가지며, 타입 객체 포인터는 Manager의 정확한 타입 객체를 가리키도록 초기화됩니다.
- CLR은 객체를 생성하면서 객체의 모든 인스턴스 필드를 0 또는 NULL 값으로 초기화합니다.
- 그 다음 객체의 생성자를 호출하면서 인스턴스의 데이터를 수정합니다.
- 이후 new 연산자는 만들어진 Manager 객체의 메모리 주소를 반환하여 스레드 스택상에 할당된 변수 e에 저장합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-9.png" width="40%" height="40%">

- Lookup 메서드를 호출할 때 JIT 컴파일러는 IL 코드를 컴파일하고 컴파일된 코드를 동적할당된 메모리에 저장합니다.
- joe가 관리직에 해당한다면 새로운 Mananger 객체가 생성되고 지역변수 e에 저장합니다. 
- 이때 처음 만들어진 Manager 객체는 아무도 참조하지 않으므로 가비지 수거 대상이 됩니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-10.png" width="40%" height="40%">

- GetYearsEmployed 메서드를 호출합니다. 마찬가지로 JIT 컴파일을 거친 뒤 코드를 수행합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-11.png" width="40%" height="40%">

- 가상 메서드 GetProgressReport를 호출합니다.
  - 가상 메서드를 호출할 때에는 JIT 컴파일러가 호출에 앞서 추가적인 코드를 메서드를 호출할 때마다 그 안에 추가하게 됩니다.
  - e의 타입은 Employee 이지만 실제 가리키는 객체는 Manager 타입입니다. 코드를 수행할 때 객체 타입 포인터 멤버가 가리키고 있는 타입 객체 정보를 확인하여 실제 어떤 객체를 가리키고 있는지 파악합니다.
  - 이후 실제 객체 타입의 메서드 테이블에서 호출하려는 메서드를 찾아냅니다. 역시 필요하면 JIT 컴파일을 수행합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-12.png" width="40%" height="40%">

- 아래 그림에서 타입 객체 역시 객체에 해당하므로, 타입 객체 포인터를 멤버를 가진다는 것을 확인할 수 있습니다.
  - 해당 타입 객체 포인터의 경우 System.Type 이라는 MSCORLIB.DLL 안의 선언되어 있는 타입 객체를 가리키게 됩니다.
  - System.Type 타입 객체의 경우 타입 객체 포인터 멤버가 자기 자신을 가리킵니다. System.Type 타입 자체가 그 자체로 객체의 타입 객체이기 때문입니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-13.png" width="40%" height="40%">

</details>

## 5장. 기본, 참조, 값 타입

<details>
<summary>fold/unfold</summary>

### 프로그래밍 언어 기본 타입

#### Reference
- [Microsoft : c# 내장 타입](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types)
---

- 컴파일러가 직접 지원하는 데이터 타입들을 기본 타입(Primitive Type)이라고 부릅니다.
  - 대표적인 예로 int 타입이 있으며 아래 코드 4줄은 전부 같은 IL코드를 생성합니다.

```cs
    int a = 0;
    System.Int32 a = 0;
    int a = new int();
    System.Int32 a = new System.Int32();
```

- C#의 기본 타입들은 조금 독특한 특징을 가지고 있습니다. 다른 프로그래밍 언어에서 int는 32비트 운영체제에서는 32비트 정수로 64비트 운영체제에서는 64비트 정수로 취급되는 경우가 있지만, C#에서 int는 System.Int32의 별칭이기 때문에 반드시 32비트 정수로 취급됩니다. 64비트 정수는 System.Int64의 별칭인 long을 사용해야 합니다.

- C# 컴파일러는 기본 타입들을 다루는 작업들에 대해서 몇 가지 기능을 제공해줍니다.

1. 컴파일러는 아래의 타입들에 대해서 암묵적/명시적 형 변환을 지원합니다.
  - 암묵적 변환에 경우 변환 과정에서 데이터 손실이 없는 '안전한' 경우에만 지원합니다.
```cs
Int32 i = 5;        //Int32 -> Int32
Int64 l = i;        //Int32 -> Int64
Single s = i;       //Int32 -> Single
Byte b = (Byte)i;   //Int32 -> Byte(명시적)
Int16 v = (Int16)s; //Single -> Int16(명시적)
```

- 특히 부동 소수점 데이터를 다룰 때 주의해야 하는데 값을 정수형으로 변환할 때 컴파일러에 따라 버림/반올림 연산 중 어떤 것을 적용할지는 컴파일러마다 다릅니다. C#의 경우는 버림 연산이 적용됩니다.

2. 기본 타입은 변수가 아닌 리터럴 상수로 기재할 수 있습니다.
```cs
Console.WriteLine($"{123.ToString()}, {456.ToString()}");
```

3. 리터럴 상수로 구성되는 표현식이 있다면, 컴파일러가 해당되는 표현식을 컴파일 타임에 평가하여 응용프로그램의 성능을 향상시키도록 할 수도 있습니다.
4. 컴파일러는 +, -, *, /, &, ^ 등의  연산자가 사용되었을 때, 자동으로 연산자 처리 우선순위를 결정합니다.

### 기본 타입 연산의 오버플로우 여부 검사
- 언어마다 오버플로우를 처리하는 방식이 다릅니다. 오버플로우를 허용하는 C/C++ 과 다르게 Visual Baisc .NET에서는 오버플로우를 명백한 오류로 취급하고 발견될 경우 이 사실을 알립니다.
  - C#은 오버플로우를 어떻게 처리할지 개발자가 선택할 수 있게 합니다. 컴파일러 옵션을 바꾸거나, checked/unchecked 키워드를 활용합니다.

```cs
UInt32 valid = unchecked((UInt32)(-1)); 

int i = -1;
UInt32 invalid = checked((UInt32)(i));  //overflow exception

//블록 지정도 가능
checked
{
    Byte b = 100;
    b = (Byte)(b + 200);    //overflow exception
}

checked
{
    DoSomething(100);   //오버플로우 검사가 이루어지지 않을 수도 있습니다.
}

```

- checked 블록 안에서 메서드를 호출한다고 가정했을 때, 메서드가 어떻게 컴파일 되는지에 따라 오버플로우 검사가 이루어질 수도, 이루어지지 않을 수도 있습니다. 
  - checked 코드 블록은 단순히 컴파일 시점에 IL 코드의 오버플로우 검사여부를 결정하는 것에 불과하기 때문입니다.
- checked/unchecked 연산자와 코드 블록, 그리고 컴파일러 스위치는 Decimal 타입에 대해서 검사를 지원하지 않습니다. Decimal 타입은 CLR이 다루지 않는 특수한 타입이며, c# 내부적으로 Decimal 에 대해서는 특별히 다르게 취급하기 때문입니다.(Decimal을 연산하기 위한 정적메서드와 연산자 오버로딩이 추가적으로 존재합니다.)
  - System.Numerics.BigInteger 타입도 마찬가지입니다.

### 참조 타입과 값 타입

- 모든 클래스는 참조타입입니다.
- 모든 구조체와 열거타입은 값 타입입니다. 구조체는 System.ValueType을 상속받고, 열거형은 System.Enum 을 상속받습니다. 여기서 System.Enum 역시 System.ValueType을 상속받습니다.
  - 모든 값 타입은 Sealed 타입입니다. 어떤 타입도 값 타입을 상속받을 수 없습니다.
  - 값 타입이 스택에 할당될 때에는 참조 타입과 달리 타입 객체 포인터와 동기화 블록 인덱스가 멤버로 포함되는 오버헤드가 존재하지 않습니다.

- 어떤 상황에서 값 타입을 쓰는게 좋을지는 [MoreEffective CSharp 4장](https://github.com/wlsvy/TIL/blob/master/Document/C%23/MoreEffectiveCSharp/MoreEffectiveCSharp/Item04.cs) 을 참고합시다.
- 값 타입의 경우, GetHashCode 메서드의 결과값은 타입의 멤버 값을 통해 평가합니다. 서로 다른 두 값 타입 객체가 똑같은 hash 코드 결과값을 반환할 수도 있는 것입니다.

#### CLR의 메모리 레이아웃
- System.Runtime.InteropServices 네임스페이스를 참조합시다. 메모리 레이아웃을 개발자가 임의로 지정한다면 아래와 같은 방식으로 공용체를 만드는 것도 가능합니다.

```cs
using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Explicit)]
    public struct Union
    {
        [FieldOffset(0)]
        public int i;
        [FieldOffset(0)]
        public byte b;
        [FieldOffset(0)]
        public long l;
        [FieldOffset(4)]
        public int i2;
    }
```

### 박싱된 값 타입과 박싱되지 않은 값 타입

- 특정 인터페이스를 상속받은 값 타입에 대해서, 해당 값 타입 객체를 임의의 인터페이스 타입으로 캐스팅할 때 박싱이 필요합니다.
  - 인터페이스 변수는 참조타입입니다.

```cs
 int i = 1;
IComparable c = i;  //boxing
```

- 값 타입에 대해서 GetType, MemberwiseClone 과 같은 System.Object 에 정의된 비가상 메서드를 호출하려 할 때 박싱이 일어납니다. 힙에 할당된 참조 객체만이 해당 메서드를 호출할 수 있기 때문입니다.
- 박싱되지 않은 값 타입들은 동기화 블록 인덱스가 없기 때문에, 다중 스레드 환경에서 lock 구문 등의 설정 대상으로 지정할 수 없습니다.
- 값 타입은 sealed 타입이기 때문에 값 타입 객체가 ToString, Equals, GetHashCode 같은 가상 메서드를 재정의된 후 호출하려 하면 CLR이 이들을 비가상 메서드로서 호출하게 합니다. 추가적인 상속이 없는 것을 확신할 수 있기에 다형성을 무시하는 것입니다.

### 객체의 동일함과 식별
- [More Effective CSharp Item09](https://github.com/wlsvy/TIL/blob/master/Document/C%23/MoreEffectiveCSharp/MoreEffectiveCSharp/Item09.cs)를 확인합시다.

### 객체 해시 코드

### dynamic 기본 타입
- dynamic 타입을 확인하면, 컴파일러는 해당 소스에 대해 조금 특별한 IL코드(페이로드payload)를 만들어 냅니다. dynamic 타입은 런타임 바인더에 의하여, 런타임에 입력되는 값에 따라 타입이 변하게 됩니다.

</details>

## 6장. 타입과 멤버의 기본

<details>
<summary>fold/unfold</summary>

### 서로 다른 종류의 타입 멤버들
- 상수 : 절대불변의 데이터 값을 식별하는 기호입니다. 상수들은 항상 타입과 관계를 가지지만 타입의 인스턴스와는 무관합니다. 논리적 관점에서 정적 멤버입니다.
- 필드 : 일기 전용 혹은 읽기 / 쓰기 겸용 데이터 값에 대한 표현입니다. 필드는 타입의 상태를 정의하기 위하여 정적 멤버로 또는 인스턴스의 상태를 정의하기 위해 인스턴스 멤버로 선언될 수 있습니다.
- 인스턴스 생성자 : 인스턴스 생성자는 객체의 인스턴스 필드를 의도하는 대로 초기화하기 위한 목적으로 선언할 수 있는 메서드입니다.
- 타입 생성자 : 타입 생성자는 타입의 정적 필드들을 의도대로 초기화하기 위한 목적으로 선언할 수 있는 특별한 메서드입니다.
- 메서드 : 멤버로 추가할 수 있는 함수로, 특정한 타입에대한 상태를 변경하기 위하여 정적 메서드를 선언하거나 특정한 인스턴스에 대한 상태를 변경하기 위하여 인스턴스 메서드로 선언할 수 있습니다.
- 연산자 오버로드 : 서로 다른 두 객체애 대해 조작하는 방법을 정의하는 메서드입니다. 공용 언어 사양(CLS) 에는 포함되지 않습니다.
- 변환 연산자 : 암묵적/명시적으로 어떤 객체를 다른 객체 타입으로 변환할 수 있는 방법을 정의하는 메서드입니다. 공용 언어 사양(CLS) 에는 포함되지 않습니다.
- 속성 : 속성은 필드와 비슷한 문법을 사용하여 타입 내의 필드를 변경하거나 상태를 조회하기 위한 정적 속성, 객체 내의 필드를 변경하거나 상태를 조회하기 위한 인스턴스 속성으로 나눌 수 있습니다.
- 이벤트 : 정적 이벤트와 인스턴스 (비정적) 이벤트는 특정한 타입이 다른 정적 메서드 또는 인스턴스 메서드로 통지를 보낼 수 있는 방법을 제공합니다.
- 타입 : 타입 안에 또 다른 타입을 중첩해서 선언할 수도 있습니다. 규모가 큰 타입을 작은 타입들로 분해하여 단순화 시키기 위함입니다.

```cs
    public sealed class SomeType
    {
        //중첩된 클래스
        private class SomeNestedType { }

        //상수 필드, 읽기 전용 필드. 그리고 읽기/쓰기가 가능한 정적 필드
        private const int someConstant = 1;
        private readonly string someReadonlyFiled = "str";
        private static int someReadWriteField = 3;

        //타입 생성자
        static SomeType() { }

        //인스턴스 생성자
        public SomeType(int x) { }
        public SomeType() { }

        //인스턴스 및 정적 메서드
        private string InstanceMethod() { return null; }
        public static void StaticMethod() { }

        //인스턴스 속성
        public int SomeProperty
        {
            get { return 0; }
            set { }
        }

        //매개변수를 요구하는 인스턴스 속성(인덱서)
        public int this[string s]
        {
            get { return 0; }
            set { }
        }

        //인스턴스 이벤트
        public event Action SomeEvent;
    }
```

### 타입의 가시성
이웃 어셈블리
- TeamB 에서 작성한 어셈블리가 TeamA의 어셈블리 안에 들어있는 타입들을 사용하려면 TeamA가 만든 어셈블리 안의 타입들은 모드 public으로 선언해야만 합니다. 하지만, 이렇게 되었을 경우 TeamA가 public으로 선언한 모든 타입들은 TeamB 뿐만 아니라 다른 모든 이들에게도 공개가 됨을 의미하므로 의도하지 않은 결과일 수 있습니다. TeamB가 쓴 코드에서만 TeamA가 작성한 타입들을 사용하도록 의도되었을 때 TeamA가 만든 타입을 internal로 유지하면서도 TeamB에 대해서만 독점적으로 접근권한을 할당할 수 있도록 해야 합니다. CLR과 c#은 이러한 기능을 이웃 어셈블리(friend assmbly)라고 정의합니다.

### 멤버 접근성
- 타입 내의 중첩 타입과 멤버를 정의할 때에는 해당 타입과 멤버의 접근성을 설정할 수 있습니다.
IL 코드를 검증함으로써 참조하는 멤버의 접근성이 설령 컴파일러 수준에서 접근성에 대한 점검이 누락되었다고 할지라도 실행 중에 이를 검사하므로 기능성을 보장받을 수 있습니다. 

- C#에서 선언하는 멤버에 명시적으로 한정자를 지정하지 않을 경우, 컴파일러는 모든 경우는 아니지만 대개 private 한정자를 자동으로 선택하여 적용하게 됩니다. 그리고 CLR에서는 인터페이스에 선언되는 모든 멤버들은 반드시 public 한정자만을 사용할 수 있도록 하고 있습니다. c# 컴파일러는 이를 반영하여 인터페스 내의 멤버들에 명시적으로 한정자를 지정할 수 없도록 제한합니다. 대신 인터페이스 멤버들의 접근 한정자는 자동적으로 public이 됩니다.
- 상속받은 타입에서 기본 타입에 선언된 멤버를 재정의하는 경우, C# 컴파일러는 기존 멤버의 접근성을 그대로 가져옵니다. 예를 들어 기본 클래스의 protected 메서드를 파생클래스에서 재정의한다면 재정의된 메서드의 접근 한정자 역시 protected 입니다.
  - 이는 C#의 제약사항이며 CLR에서는 재정의하는 멤버의 접근성을 상위 타입보다 더 개방할 수 있습니다.

### 정적 클래스
- Console, Math 등 인스턴스로 생성되지 않도록 보호되는 클래스들은 정적 클래스입니다. 이러한 클래스들은 반드시 정적 멤버들만을 포함할 수 있습니다.
  - static 키워드는 값 타입에 대해서는 사용할 수 없습니다. CLR은 값 타입을 항상 인스턴스로 선언하여 사용하도록 제한하였기 때문입니다.
  - 정적 클래스는 반드시 System.Object 에서만 상속을 받도록 제한되었습니다. (자동적으로 sealed, abstract 특성이 부여됩니다)
  - 정적 클래스는 인터페이스를 구현할 수 없도록 제한되었습니다. 인터페이스 메서드는 클래스의 인스턴스로 생성될 때에만 호출할 수 있기 때문입니다.
  - 정적 클래스 안에서는 필드, 메서드, 속성, 이벤트 모두 정적 멤버로 선언되어야만 합니다.
  - 정적 클래스는 필드, 메서드 매개변수, 또는 지역 변수의 타입으로 사용될 수 없습니다. 이러한 작업은 모두 클래스 인스턴스화와 연관이 있기 때문입니다.

### 부분 클래스, 부분 구조체, 부분 인터페이스
- partial 키워드를 사용하면 한 소스 코드 파일 내에서 여러 조각으로 타입의 선언을 분할하거나 여러 소스 코드 파일에 걸쳐 여러 조각으로 타입의 선언을 분할할 수 있게 합니다.

### 컴포넌트, 다형성, 버전관리
컴포넌트 소프트웨어 프로그래밍(Component Software Programming, CSP)은 객체 지향 프로그래밍(OOP)의 수준을 끌어올렸습니다. <br>
다음은 컴포넌트로서 가져야 할 성격들입니다.
- 하나의 컴포넌트(.NET Framework에서는 하나의 어셈블리)는 "출판(Published)"된 것으로 간주합니다.
- 하나의 컴포넌트에는 식별할 수 있는 아이덴티티(이름, 버전, 문화권, 그리고 공개 키)가 존재합니다.
- 하나의 컴포넌트에는 영원히 유지되는 고유한 아이덴티티가 존재합니다. 어셈블리 안에 들어있는 코드는 다른 어셈블리에 정적으로 링크되는 일이 없으며, .NET 환경에서는 항상 동적 링크만 발생합니다.
- 하나의 컴포넌트는 의지하는 다른 컴포넌트들에 대해 정확한 정보를 표시합니다.(참조 메타데이터 테이블)
- 하나의 컴포넌트는 반드시 그 안에 들어있는 클래스와 멤버들에 대해 문서를 만들 수 있어야 합니다. C#에서는 소스 코드 내부에 XML 주석을 추가하여 컴파일러의 /doc 명령 줄 스위치를 사용하여 이러한 목적을 성취할 수 있습니다.
- 하나의 컴포넌트는 반드시 필요로 하는 권한에 대해 자세히 서술하고 있어야 합니다. CLR의 코드 액세스 보안(CAS) 기능을 통해 이를 달성할 수 있습니다.
- 하나의 컴포넌트는 새로운 서비스를 제공하더라도 변하지 않는 인터페이스나 객체 모델을 제공해야 합니다. 서비스 제공이라 함은 원래의 컴포넌트 버전과 호환성을 유지할 수 있는 새로운 버전의 컴포넌트를 제공하는 것입니다.

---

C#의 각 키워드와 컴포넌트 버전 관리에 주는 영향

| C# 키워드 | 타입에 대한 적용 | 메서드/속성/이벤트에 대한 적용 | 상수/필드에 대한 적용 |
|:---: | :--- | :--- | :---: |
|abstract| 여기에 해당하는 타입은 인스턴스로 만들 수 없게 된다. | 이 키워드로 선언된 멤버가 있는 타입을 상속받은 타입이 인스턴스로 생성될 수 있도록 하기 위해서는 반드시 해당 멤버를 구현해야만 한다. | (적용 불가) |
|virtual| (적용 불가) | 이 키워드로 선언된 멤버가 있는 타입을 상속받은 타입에서 이 멤버를 재정의할 수 있다. | (적용 불가) |
|override| (적용 불가) | 기본 타입의 가상 멤버를 현재 타입에서 재정의한다. | (적용 불가) |
|sealed| 여기에 해당하는 타입은 다른 타입의 기본 타입이 될 수 없다. | 이 키워드로 선언된 멤버는 상속 이후에 재정의할 수 없다. 이 키워드는 가상 메서드를 재정의하는 메서드에 대해서만 지정할 수 있다. | (적용 불가) |
|new| 중첩 타입에 적용되는 경우, 기본 타입에 존재할 수 있는 비슷한 멤버 메서드, 속성, 이벤트, 상수, 필드와는 전혀 관계가 없음을 명시하게 된다. |  |  |

### CLR이 가상 메서드, 속성, 이벤트를 호출하는 방법
- CLR은 한 타입 내에 같은 이름의 메서드 여러 개를 서로 다른 매개변수 또는 반환 타입을 사용하여 구분하는 것을 허용합니다.
  - 하지만 C#의 경우 메서드의 반환 타입은 무시하고 매개변수 목록의 차이를 통해 고유성을 식별합니다.

컴파일러가 코드를 컴파일할 때 메서드를 메서드 정의 테이블에 항목으로 추가하며, 각 항목들이 인스턴스 메서드인지, 가상 메서드인지, 정적 메서드인지의 여부를 플래그로 기록합니다.
- CLR은 다음의 두 IL 명령어를 사용하여 메서드를 호출합니다.
  - call : 정적/인스턴스/가상 메서드를 호출하기 위해 사용될 수 있습니다. 정적메서드 호출 시, 메서드가 정의된 타입을 정확하게 지정해야 합니다. 인스턴스/가상 메서드 호출 시 객체를 가리키는 변수를 반드시 지정해야 하며 이때 해당 변수는 절대 null이 아니어야 합니다. CLR은 넘겨받은 변수의 타입을 확인하여 일치하는 메서드를 찾는 데 사용합니다. 만약 해당 타입에서 발견하지 못했다면 상속 계통을 올라가면서 탐색합니다.
  - callvirt : 인스턴스/가상/비정적 메서드 호출에 사용됩니다. 인스턴스/가상 메서드 호출시 객체애 대한 참조를 반드시 지정해야 합니다. 비가상 인스턴스 메서드를 호출할 때 넘겨받은 객체 참조 변수의 타입을 통하여 CLR이 호출할 실제 메서드를 찾습니다. 이때 해당 참조 변수는 null일 수 있습니다. JIT 컴파일러는 메서드를 호출하기 전에 객체 참조가 null인지 검증하는 절차를 거칩니다.(null 이면 오류를 던집니다) 이런 추가적인 검사과정으로 인해 callvirt는 call 보다 조금 더 느리게 동작합니다.

컴파일러는 call 명령어를 값 타입에 정의된 메서드를 호출할 때 주로 사용하는 경향이 있습니다. 값 타입은 상속이 불가능하며 null 값을 가질 수 없기 때문입니다. <br><br>
타입을 설계할 때는 반드시 정의하는 가상 메서드의 수를 최소화해야 합니다.
1. 가상 메서드는 비가상 메서드보다 호출 속도가 느리다.
2. 가상 메서드는 JIT 컴파일러에 의하여 인라인으로 번역될 수 없어 성능에 영향을 줄 수 있습니다.
3. 가상 메서드는 컴포넌트 버전 관리를 어렵게 합니다.
4. 기본 타입을 선언할 때에는 편의를 위한 오버로드 메서드들의 집합을 제공하는 것이 보편적입니다.

### 타입의 가시성과 멤버의 접근성을 지능적으로 활용하는 방법
- 타입은 가능하면 sealed 타입으로, 멤버는 가능하면 priavte으로 -> 아래의 장점이 있습니다.
  - 버전관리 : 상속이 봉인된 클래스는 추후에 봉인을 해제할 수 있습니다만, 반대의 경우는 안됩니다.
  - 성능 : sealed 타입의 경우 컴파일러가 확인해서 가상메서드를 호출할 때에도 callvirt 대신 call을 활용할 수 있습니다. (가상 메서드를 비가상 메서드처럼 호출/타입이 봉인되 있다면 상속 계통을 전부 확인할 필요가 없기 때문에)
  - 보안 향상과 예측의 용이성 : 봉인되지 않은 클래스 타입의 경우, 추후 파생클래스에서 정의된 메서드로 인해 기본 클래스의 멤버가 의도치 않게 변경될 수 있습니다.

- 오래된 객체 지향 프로그래밍에 관한 격언 : 너무 복잡해지는 것 같다면 더 많은 타입을 만들라

### 타입에 대한 버전관리와 가상 메서드 사이의 조율
...


</details>

## 7장. 상수와 필드

<details>
<summary>fold/unfold</summary>

### 상수
- 절대 변하지 않는 값에 대한 기호
- 상수 기호를 정의할 때는 그 값이 반드시 컴파일 시점에서 확인할 수 있어야 합니다. 기본 타입으로 취급될 수 있는 경우 상수로 사용할 수 있습니다.(Int32, Boolean 등)
- 상수 기호를 참조하는 코드가 있을 때, 컴파일러는 어셈블리의 메타데이터 안에 정의된 상수 기호를 검색하여 상수의 실제 값을 추출한 후 만들어진 IL 코드에 값을 직접 첨부합니다.
  - 코드에 상수 값을 직접 첨부하므로 실행 시점에 상수 값을 위해서 추가로 메모리를 할당하지 않습니다.
  - 상수 값에 대해서 주소를 얻거나 이를 참조로 지정할 수 없습니다.

## 필드
- 필드는 값 타입의 인스턴스 또는 참조 타입에 대한 참조를 저장하는 데이터 멤버입니다.

<br>
필드 한정자
<br>

| CLR 키워드 | C# 키워드 | 설명 |
| :---: | :---: | :--- |
| Static | static | 타입의 상태의 일부로서 필드가 선언되며, 객체의 상태의 일부가 되는 것과는 반대되는 개념 |
| Instance | (기본값, 생략) | 타입 인스턴스(객체)의 상태의 일부로서 필드가 선언되며, 타입 그 자체와는 무관하다. |
| InitOnly | readonly | 해당 필드는 반드시 생성자 메서드에 의해서만 초기화가 가능하다. |
| Volatile | volatile | 해당 필드는 컴파일러, CLR, 하드웨어에 의하여 이루어지는 스레드 비안정성 최적화의 대상에서 제외된다.|

* C#은 성능상의 문제 때문에 필드를 인라인 문법을 사용하여 초기화하는 것과 생성자 안에서 대입 문법을 사용하여 초기화하는 것에 차등을 두고 있습니다.(8장에서 자세히)


</details>


## 8장. 메서드

<details>
<summary>fold/unfold</summary>

### 인스턴스 생성자와 클래스(참조 타입)
- 생성자는 특별한 유형의 메서드로 타입의 인스턴스를 올바른 상태로 초기화하는 것을 돕습니다. .ctor라는 이름으로 메타데이터에 등록됩니다.
- 참조 타입으로 객체의 인스턴스를 생성하면, 인스턴스의 데이터 필드들을 저장하기 위해서 메모리가 할당되는데, 먼저 객체의 오버헤드 필드(타입 객체 포인터, 동기화 블록 인덱스)가 초기화되고, 그 다음으로 타입의 인스턴스 생성자가 호출됩니다.
  - 인스턴스 생성자는 재정의할 수 없습니다.
  - 클래스를 abstract로 선언하면 컴파일러는 기본 생성자를 protected로 선언하며, 그렇지 않은 경우에는 public으로 선언된 것으로 간주합니다.
  - C# 컴파일러는 상속한 클래스가 명시적으로 기본 클래스의 생성자를 호출하지 않으면, 기본 클래스 생성자를 자동으로 호출하도록 코드를 생성합니다.

- 특별한 상황에서는 타입의 인스턴스 생성자가 호출되지 않고도, 해당 타입의 인스턴스가 생성될 수 있습니다.
  - Object 타입의 MemberwiseClone 메서드를 호출하여 메모리를 할당하고, 객체의 오버헤드 필드를 초기화한 다음, 원본 객체의 바이트들을 새 객체로 직접 복사해 넣습니다.
  - 또한 런타임 Serialization을 통하여 만들어진 데이터를 deserialization하는 경우에도 생성자 호출이 별도로 이루어지지 않습니다.

- 생성자에서 가상 메서드를 호출하지 않습니다. 하위 타입 멤버의 초기화가 덜 끝난 상태에서 재정의된 메서드를 호출한다면 의도하지 않은 결과가 나타날 수 있습니다.
  - C#에서는 객체 멤버에 대해서 인라인 초기화 문구가 작성되어져 있다면, 생성자를 호출하기 전에 해당 멤버에 초기화 데이터를 대입하게 됩니다.

```cs
        //만약 인스턴스 필드를 초기화하는 인라인 코드가 여럿 있고, 오버로드된 생성자를 많이 만들어야 한다면, 
        //필드 초기화 구문 대신, 공통적인 초기화 작업을 수행하는 단일의 생성자를 생성하는 것이 좋습니다.
        class SomeType
        {
            //인라인 초기화 구문은 전부 제거
            private int x;
            private string s;
            private double d;
            private byte b;

            // 기본 생성자에서는 모든 필드를 기본값으로 설정하고 있습니다.
            // 나머지 다른 생성자들은 이 생성자를 명시적으로 호출합니다.
            public SomeType()
            {
                x = 5;
                s = "Hi, There";
                d = 3.1459;
                b = 0xff;
            }

            public SomeType(int x) : this()
            {
                this.x = x;
            }

            public SomeType(string s) : this()
            {
                this.s = s;
            }
        }
```

### 인스턴스 생성자와 구조체(값 타입)
- CLR 에서는 값 타입의 인스턴스를 언제든 생성할 수 있도록 허용므로 값 타입은 내부에 생성자를 정의할 필요가 없습니다. C# 컴파일러에는 값 타입에 대해서는 매개변수가 없는 기본 생성자 코드를 생성하지 않습니다.
  - 컴파일러가 값 타입의 기본 생성자를 자동으로 생성해줄 것처럼 예상할 수도 있지만 사실 애플리케이션의 성능을 개선하기 위해서 c# 은 자동으로 생성자를 작성하지 않습니다.
  - 따라서 컴파일러는 애당초 생성자를 자동으로 호출해야 할 의무가 사라지게 됩니다.
- 신뢰할 수 있는 코드를 위하여 값 타입의 모든 필드들은 읽기 작업을 수행하기 전에 반드시 쓰기 작업을 한번 거쳐야 합니다. 따라서 생성자는 반드시 해당 타입 내의 모든 필드들을 명시적으로 초기화해줘야 합니다.

```cs
        struct widget
        {
            public int x, y, z, w;

            //문제 없이 컴파일됩니다.
            public widget(int x)
            {
                //참조 타입에서 this는 읽기 전용이지만, 값 타입에서는 this가 인스턴스 그 자체를 나타내며 새 인스턴스를 대입하는 것이 가능
                this = new widget();
                this.x = x;
            }


            //모든 필드를 초기화하지 않는 경우. -> 컴파일 X
            public widget(int x, int y)
            {
                this.x = x;
                this.y = y;
            }
        }
```

### 타입 생성자
- 타입 생성자는 static 키워드를 사용해서 정의되며 C# 에 의해 자동으로 private으로 지정됩니다. (외부에서 임의로 호출되지 못하도록 보호)
- JIT 컴파일러가 메서드를 컴파일 할 때 메서드 내의 코드가 어떤 타입들을 참조하는지 확인합니다. 만약 타입 생성자를 정의하고 있는 타입을 참조하고 있다면, JIT 컴파일러는 이 타입의 타입 생성자가 현재의 앱 도메인에서 실행된 적이 있는지 검사합니다. 만약 한 번도 실행되지 않았다면 JIT 컴파일러는 타입 생성자를 호출하는 코드를 네이티브 코드에 추가합니다.
  - 컴파일된 코드를 스레드가 실행할 때 여러 스레드가 동시에 타입 생성자를 실행하는 경우를 방지하기 위해 이 메서드를 호출하는 스레드가 상호 배타적인 락을 획득할 수 있도록 요구합니다. 
  - 정적 생성자는 CLR이 앱 도메인 당 단 한 번씩만 수행할 수 있도록 스레드 안정성을 보장하기 때문에 필요하다면 싱글톤 객체를 초기화 하기에 최적의 위치라고 할 수 있습니다.

```cs
        struct SomeValueType
        {
            // C#은 값 타입에 대해 매개변수 없는 값 타입 생성자를 정의할 수 있도록 허용합니다.
            // 하지만 CLR은 값 타입의 정적타입 생성자를 호출하지 않습니다.
            static SomeValueType()
            {
                Console.WriteLine("This never gets displayed");
            }
        }
        class SomeRefType
        {
            static SomeRefType()
            {
                //해당 타입을 처음 사용하는 경우 실행됩니다.
                Console.WriteLine("SomeRefType type ctor");
            }
        }

```
- 타입 생성자로 생성된 타입 객체의 경우 앱도메인이 언로드하는 경우에만 가비지 컬렉터의 수거대상이 됩니다.
  - CLR은 따로 정적 소멸자를 지원하지 않습니다. 

### 연산자 오버로드 메서드
- CLR에서는 연산자 오버로딩 개념이 존재하지 않습니다. 또한 연산자라는 개념 역시 없습니다. C#에서는 연산자를 대응되는 다른 이름의 메서드로 치환해서 사용합니다.
  - C#에서 +는 op_UnaryPlus, -는 op_UnaryNegation 등으로 호환되는 메서드가 존재합니다. 해당 메서드들은 specialname 플래그 셋을 포함하며, 만약 플래그가 true 이면 연산자 오버로딩에 활용되는 것을 나타냅니다.
  - CLR에서는 연산자 오버로드는 반드시 public 접근자를 사용하면서 정적 메서드로 사용되어야 합니다.


### 변환 연산자 메서드
- 변환 연산자(Conversion method)는 어떤 타입에서 다른 타입으로의 변환을 담당하는 메서드입니다.
  - 변환 연산자는 명시적(explicit)/암시적(implicit) 연산을 구현할 수 있습니다.
  - 자릿수나 정밀도에 손상을 주거나 정보를 잃어버리는 변환의 경우, 암시적 변환보다 명시적 변환 연산을 활용하는 것이 좋습니다.
  - is/as 연산자는 변환 연산자 메서드를 호출하지 않습니다.

### 확장 메서드
- 확장 메서드는 사용자가 정의한 정적 메서드를 인스턴스 메서드의 일부인 것처럼 보이게 합니다.
  - 컴파일러가 메서드를 바인딩할 때, 특정 메서드에 해당하는 인스턴스 메서드가 있을 경우, 컴파일러는 해당 메서드를 호출하는 IL 코드를 만들어냅니다. 하지만 인스턴스 메서드가 없는 경우, 컴파일러는 첫 번째 매개변수로 호출하려는 대상 타입의 인스턴스를 받는 정적 메서드를 포함하는 정적 클래스가 있는지 확인합니다. 이때 첫 번재 인자는 반드시 this 키워드로 표시되어야 합니다.
- 확장 메서드는(첫 번째 매ㅐ개변수에 this 키워드가 붙는 메서드)는 반드시 제네릭이 아닌 정적 클래스 위에서 정의되어야만 합니다.
- 확장 메서드는 단순히 정적 메서드에 대한 호출에 불과하기 때문에 CLR은 호출 과정에서 전달되는 객체가 null인지 검사하는 코드를 내보내지 않습니다.
- 정적 클래스의 이름은 임의로 작명할 수 있기 때문에 C# 컴파일러는 파일 수준의 모든 정적 클래스를 확인해야 하며 확장 메서드를 찾는데 시간이 필요합니다.
  - 검색 성능을 개선하기 위해 c# 컴파일러는 확장 메서드에 ExtensionAttribute를 내부적으로 추가합니다. 더 나아가 확장 메서드를 하나라도 포함하고 있는 정적 클래스/어셈블리에도 해당 특성이 추가됩니다. 컴파일러는 해당 특성이 부여된 정적 클래스/메서드들을 확인해나가면서 검색의 범위를 좁힙니다.

### 부분 메서드
...

</details>

## 9장. 매개변수

<details>
<summary>fold/unfold</summary>

### 선택적 매개변수와 명명된 매개변수
...
- 메서드로 매개변수를 전달할 때, 컴파일러는 각각의 매개변수에 대한 식을 왼쪽에서 오른쪽의 순서로 평가합니다.
- 매개변수에 지정하는 기본값들은 모두 컴파일 시점에서 알 수 있는 상수 값이어야 합니다.
- 모듈 외부에서 불리는 메서드의 매개변수의 기본값을 바꾸는 것은 위험성을 내포합니다. 호출하는 측의 코드가 재컴파일 되지 않는다면 이전에 사용되던 매개변수의 기본값을 그대로 사용하게 됩니다.

```cs
        //이 방법은 위험합니다.
        private static string MakePath(string fileName = "Untitled")
        {
            return string.Format(@"C:\{0}.txt", fileName);
        }

        //대신 이렇게 하는 것이 좋습니다.
        private static string MakePath(string filename = null)
        {
            return string.Format(@"C:\{0}.txt", filename ?? "Untitled");
        }

```
<br>
- ref, out 키워드를 사용하는 매개변수에는 기본값을 지정할 수 없습니다.
- c#의 경우 선택적 매개변수에 기본값을 지정할 경우, 컴파일러가 내부적으로 System.Runtime.InteropServices.OptionalAttribute 특성을 해당 매개변수에 자동으로 붙이고 메타데이터에 기록합니다.
  - 추가적으로 System.Runtime.InteropServices.DefaultParameterValueAttribute 특성을 해당 매개변수에 붙이고 메타데이터에 기록합니다. 이후에 DefaultParameterValueAttribute 특성의 생성자에는 소스 코드상에서 지정한 기본 상수 값을 전달합니다.


### 암시적으로 타입화된 지역 변수
...

### 메서드에 참조로 매개변수 전달
- out/ref 키워드는 매개변수로 넘겨받은 변수의 레퍼런스를 전달합니다.
- CLR에서 두 키워드는 동일한 의미를 가집니다. 하지만 C# 컴파일러는 두 키워드를 엄격하게 구분합니다.
  - ref 매개변수를 전달하기 전에 해당 변수는 초기화가 되어 있어야 하지만, out 매개변수로 전달될 때는 초기화 되어있을 필요가 없습니다.
- out 과 ref 키워드 간 오버로딩은 지원되지 않습니다. 메타데이터 관점에서는 out과 ref 키워드간의 차이가 없기 때문입니다.

### 메서드에 가변 매개변수 전달하기
- params 키워드는 메서드에 전달하는 인자의 개수를 가변적으로 취합니다.
  - 해당 키워드는 컴파일러가 System.ParamArrayAttribute 특성을 해당 매개변수에 붙이도록 지시합니다.

- null을 전달하지 않는 이상 params 키워드는 성능적 오버헤드가 존재합니다. 가변 매개변수를 위해 힙 상에는 배열 객체가 생성되어야 합니다.
  - 성능상의 손해를 최소화하고 싶다면 적절한 오버로딩 버전을 준비합시다.

### 매개변수 타입과 반환 타입에 대한 지침
...

### 상수화
- CLR은 매개변수를 상수로 선언하는 기능을 지원하지 않습니다.
- 마이크로소프트가 상수화된 객체나 매개변수가 변경되지 않았음을 검증하는 기능을 CLR에 추가하기는 매우 어렵습니다. 이를 가능하게 하려면 CLR은 상수화된 객체에 대해 쓰기 작업이 발생하지 않는지 매번 확인해야하며 이는 곧 성능상의 오버헤드가 됩니다. 또한 이러한 검증 과정은 개발자들에게 수 많은 복잡성을 가중시키게 됩니다.
  - 이러한 이유로 CLR은 객체나 매개변수에 대한 상수화를 지원하지 않습니다.

#### 스터디
- in, out, ref 키워드의 사용
  - 매개변수로 참조를 전달할 때 사용한다. 값 타입도 박싱이 일어나지 않습니다.
  - in :내부에서 참조 변경을 불가능하게 할 때 사용한다.
  - out : 할당되지 않은 변수를 전달해서, 내부에서 할당할 때 사용한다.

- multiple Return : Tuple vs out
  - Tuple이 편하지만, 패턴에 따라 out을 사용해 구현하는 것이 편한 경우도 있다.( TryGet 등… ), async 메서드는 out 사용하지 못합니다.

- 기본 매개변수는 사용하지 않는 것을 권장. 메서드 오버로딩이 충분한 대안이 될 수 있으며, 기본 매개변수로 인한 부작용이 나타날 수 있기 때문


</details>

## 10장. 속성

<details>
<summary>fold/unfold</summary>

- 속성은 메서드를 소스 코드상에서 호출하는 방법을 단순하게 만들어줍니다. CLR에서는 두 가지 유형의 속성을 지원하는데 매개변수를 포함하는 속성(인덱서)와 매개변수를 받지 않는 속성(기본 속성Default Property)로 분류됩니다.

### 매개변수가 없는 속성
- C#은 속성에 대한 지원을 내장하고 있습니다. C# 컴파일러가 속성으로부터 값을 가져오거나 설정하려는 코드를 만나면, 컴파일러는 적절한 메서드를 호출하는 코드로 이를 변경합니다.
- C# 컴파일러는 접근자 메서드를 만드는 것에 더하여 소스 코드상의 각 속성에 대한 정의 항목을 어셈블리의 메타데이터에 추가합니다.
  - 이 항목에는 속성 자체에 대한 몇 가지 플래그와 속성의 타입, get과 set 접근자 메서드에 댛나 참조를 포함합니다.
- 속성을 구현하면서 get/set 메서드의 구현부를 생략하면 C# 컴파일러는 자동으로 속성과 연결되는 private 필드(지원 필드backing field)를 정의해 줍니다.

<br>

필드와 속성의 차이
- 속성은 마치 필드처럼 보이지만 사실은 메서드입니다.
- 속성은 읽기 전용일 수 있지만 필드에 대한 접근은 항상 읽기와 쓰기가 모두 가능합니다.
- 속성 메서드는 예외를 발생시킬 수 있지만 필드에 대한 접근은 절대 그럴 일이 없습니다.
- 속성을 메서드에 out이나 ref 매개변수로 전달할 수는 없지만, 필드로는 그렇게 할 수 있습니다.
- 속성 메서드는 실행하는 데 시간이 오래 걸릴 수 있지만 필드에 대한 접근은 언제나 신속하게 실행됩니다.
- 만약 속성을 한 줄에서 여러 번 호출하면, 속성 메서드는 매번 다른 값을 반환할 수 있지만, 필드는 항상 같은 값을 반환합니다.
- 속성의 접근자 메서드는 객체의 상태와는 무관하게 추가적인 메모리를 필요로 하거나 속성을 포함하는 객체의 상태와는 무관한 다른 객체를 반환할 수도 있습니다.

<br>

#### 객체와 컬렉션 이니셜라이저
```cs
        public class Cat
        {
            // Auto-implemented properties.
            public int Age { get; set; }
            public string Name { get; set; }

            public Cat()
            {
                Console.WriteLine("Cat Contructor");
            }

            public Cat(string name)
            {
                Console.WriteLine("Cat Contructor with name");

                this.Name = name;
            }
        }

        public static void Main()
        {
            Cat cat = new Cat { Age = 10, Name = "Fluffy" };
            Cat sameCat = new Cat("Fluffy") { Age = 10 };
        }
```

- 컬렉션 이니셜라이저의 경우, 특정 타입이 IEnumerable 인터페이스와 Add() 메서드를 구현하고 있어야 합니다.


#### 기타
- new Tupel<> -> 튜플 클래스 타입, (value, value) -> 튜플 구조체 타입
- (value, value) 형식은 튜플 디스트럭션등의 편리한 기능도 있다.


</details>

## 11장. 이벤트

<details>
<summary>fold/unfold</summary>

이벤트 멤버를 타입 내에 정의한다는 것은 다음의 기능을 제공하는 것입니다.
- 관심 있는 이벤트의 메서드를 등록할 수 있습니다.
- 관심 있는 이벤트로부터 메서드를 등록 해제할 수 있습니다.
- 이벤트가 발생하면 등록된 메서드들에 이벤트가 발생하였음을 알려줍니다.

<br>

CLR의 이벤트 모델은 델리게이트(Delegate)에 기반을 두고 있습니다. 델리게이트는 타입 안정성을 유지한 채로 콜백 메서드를 호출하는 방법입니다. 콜백 메서드는 이벤트를 수신하려는 객체가 이벤트가 발생했음을 알아내기 위해 사용됩니다.

### 이벤트를 노출하는 타입을 설계하기
...
(예제 코드 위주로 설명하는 장)
- 이벤트 패턴은 모든 이벤트 핸들러들의 반환 타입을 void로 정의합니다. 이벤트가 발생하였을 때 여러 개의 콜백 메서드를 호출해야 할 수 있으며, 이 모든 콜백 메서드로 반환 값을 받을 방법이 없기 때문입니다.

### 컴파일러가 이벤트를 구현하는 방법
```cs
public class NewMailEventArgs : EventArgs {}
public class MailManager
{
    public event EventHandler<NewMailEventArgs> NewMail;
}
```
위의 코드는 컴파일러가 아래처럼 바뀝니다.
- event 에 델리게이트를 추가하거나 제거하는 과정은 스레드 안정적으로 설계되었습니다. 29장 타입에 상관없이 Interlocked를 요소를 사용하기 위한 패턴 참조.
- 만약 등록한 적이 없는 메서드를 제거하려 하면 Delegate 의 Remove 메서드는 아무런 작업도 수행하지 않습니다. 이 단계에서 어떠한 예외나 경고도 유발하지 않으며 컬렉션의 내용도 그대로 유지됩니다.
- c# 컴팡일러는 이벤트를 기본 지원하기 때문에, 외부코드에서 이벤트 객체에 대해 += /-= 연산자를 사용하면 컴파일러는 이를 add_'EventName' / remove_'EventName' 으로 변경합니다.

```cs
public class MailManager2
{
    //1. private 으로 델리게이트 필드를 생성하여 null로 초기화한다.
    private EventHandler<NewMailEventArgs> NewMail = null;

    //2. public 으로 'add_이벤트명' 메서드를 추가하여 이벤트에 메서드를 등록할 수 있게 해준다.
    public void add_NewMail(EventHandler<NewMailEventArgs> value)
    {
        //반복문과 CompareExchange 메서드를 이용하여 스레드 안정적으로 델리게이트를 추가한다.
        EventHandler<NewMailEventArgs> prevHandler;
        EventHandler<NewMailEventArgs> newMail = this.NewMail;
        do
        {
            prevHandler = newMail;
            EventHandler<NewMailEventArgs> newHandler =
                (EventHandler<NewMailEventArgs>) Delegate.Combine(prevHandler, value);
            newMail = Interlocked.CompareExchange(ref this.NewMail, newHandler, prevHandler);
        } while (newMail != prevHandler);
    }

    //3. public으로 'remove_이벤트명' 메서드를 추가하여 이벤트로부터 메서드를 제거할 수 있게 해준다.
    public void remove_NewMail(EventHandler<NewMailEventArgs> value)
    {
        //반복문과 CompareExchange 메서드를 추가하여 스레드 안정적으로 델리게이트를 제거한다.
        EventHandler<NewMailEventArgs> prevHandler;
        EventHandler<NewMailEventArgs> newMail = this.NewMail;
        do
        {
            prevHandler = newMail;
            EventHandler<NewMailEventArgs> newHandler =
                (EventHandler<NewMailEventArgs>)Delegate.Remove(prevHandler, value);
            newMail = Interlocked.CompareExchange(ref this.NewMail, newHandler, prevHandler);
        } while (newMail != prevHandler);
    }
}
```

### 이벤트가 기다리는 타입 설계하기
...

### 명시적 이벤트 구현
...
실제로 이벤트를 구현하는 코드 작성(예제 코드는 책에서 참고)

</details>

## 12장. 제네릭

<details>
<summary>fold/unfold</summary>

제네릭(Generics)은 CLR과 CLR이 지원하는 언어들이 제공하는 다른 형태의 매커니즘으로서, 이를 통해 또 다른 코드 재사용 방식인 알고리즘 재사용을 수행할 수 있습니다.
- `List<T>` 를 예로 들때 T와 같이 데이터 타입으로 지정하는 변수를 타입 매개변수(type parameter)라고 합니다. 사용자 입장에서 제네릭 타입이나 제네릭 메서드를 활용할 때 지정하는 데이터 타입을 타입 인자(type argument)라고 합니다.

제네릭은 개발자들에게 여러 이점을 제공합니다.
- 소스 코드 보호 : 제네릭 알고리즘을 사용하기 위해서 알고리즘을 구현하고 있는 소스 코드가 반드시 필요한 것은 아닙니다. 반면에 c++ 템플릿의 경우, 템플릿 기반의 알고리즘을 사용하려면, 반드시 이를 구현하고 있는 소스 코드가 필요합니다.
- 타입 안정성 : 특정한 데이터 타입을 타입 인자로 지정하여 제네릭 알고리즘을 사용하면 컴파일러와 CLR은 지정된 데이터 타입과 호황된느 타입에 대해서만 해당 알고리즘을 사용할 수 있습니다. 
- 간결한 코드 : 컴파일러가 타입 안정성을 강력하게 검사하기 때문에 소스 코드 내에 캐스팅이 거의 필요하지 않아 코드를 좀더 작성하기 쉽고, 이해하기 쉽고, 유지 보수하기도 쉽게 됩니다.
- 더 나은 성능 : 제네릭 도입 이전에는 일반화된 알고리즘을 정의하기 위해서 모든 멤버들을 Object 타입으로 다루어야함 했습니다. 하지만 제네릭을 활용하게 된 뒤로 이 문제가 해결되었으며 값 타입을 사용하더라도 박싱이 발생하지 않습니다.


값 타입과 참조 타입에 대해서 다른 방식으로 동작
- 값 타입의 경우, 타입별로 코드 생성
- 참조 타입의 경우, 제네릭 제약조건을 만족하는 가장 기본 클래스에 대해서 코드 생성, 이후 제네릭 타입 매개변수는 전부 업캐스팅

### Framework Class Library 에서의 제네릭
...

### 제네릭 하부 구조

#### 열린 타입과 닫힌 타입
- CLR에서는 모든 타입이 개별적인 객체(타입 객체)를 가지게 됩니다. 이때 제네릭 타입 매개변수를 가지는 타입도 각자 타입 객체를 가집니다. 
  - 각각의 타입에 대해서 제네릭 타입 매개변수가 등장하는 타입을 열린 타입(open type)이라고 합니다. CLR은 열린 타입에 대해서는 인스턴스 생성을 허용하지 않습니다.
  - 제네릭 타입을 참조할 때, 제네릭 타입 인자들을 지정할 수 있는데, 이 과정에서 모든 타입 인자들을 실제 데이터 타입으로 지정하게 되면, 이를 닫힌 타입(Closed Type)이라고 합니다. CLR은 닫힌 타입에 대해서는 인스턴스 생성을 허용합니다.

#### 제네릭 타입과 상속
...

#### 제네릭 타입의 독자성
...

#### 코드 폭증
- 제네릭 타입 매개변수에 들어오는 타입에 따라 네이티브 코드를 전부 생성해야 한다면 코드 폭증(code Explosion)이 발생해 성능에 영향을 끼치게 될 것입니다.
- 다행히 CLR에서는 여기에 대한 최적화 방안이 마련되어져 있는데
  - 우선, 제네릭 메서드가 특정 타입 인자를 이용하여 호출된 적이 있고, 이후에 다시 동일한 타입 인자를 사용하여 메서드를 호출하는 경우, CLR은 이러한 유형의 메서드/타입 조합을 단 한 번만 컴파일합니다.
  - CLR은 타입 인자로 지정되는 타입이 참조 타입인 경우, 모두 동등한 타입으로 분류하여 코드를 공유합니다. 예를 들어 만약 CLR이 `List<string>`의 코드를 컴파일했었다면 `List<Stream>`에 대해서도 동일한 코드를 사용하게 하는 것입니다. 두 타입은 전부 참조 타입이기에 가능합니다.
  - 하지만 타입 인자로 값 타입이 지정되면, CLR은 반드시 개별 값 타입에 대응하는 네이티브 코드를 생성해야 합니다.(값 타입은 참조 타입의 포인터와 다르게 데이터 크기가 동일하지 않고 다양하기 때문입니다. 또한 값 타입을 다루는 네이티브 CPU 명령어다 다를 수도 있습니다.)

### 제네릭 인터페이스
...

### 제네릭 델리게이트
- 델리게이트는 사실 네 개의 메서드로 구성된 클래스인데 생성자, Invoke 메서드, BeginInvoke 메서드, EndInvoke 메서드를 구성되어 있습니다. 타입 매개변수를 이용하여 델리게이트 타입을 정의하면, 컴파일러가 델리게이트 클래스를 정의할 때에도 각 메서드의 매개변수나 반환 타입으로 타입 매개변수를 이용하여 정의하게 됩니다.

### 공변성과 반공변성 타입 매개변수를 사용하는 델리게이트와 인터페이스
- 델리게이트의 제네릭 타입 매개변수들에 공변성(Covariant)과 반공변성(contra - variant) 의 성질을 나타낼 수 있습니다.
- 고정(Invariant) : 제네릭 타입 매개변수는 변경될 수 없음을 의미합니다.
- 반공변성(Contra-Variant) : 제네릭 타입 매개변수로 지정한 타입을 상속한 (상속 계통상의 하위의) 타입으로 변경할 수 있음을 의미합니다. c#에서는 in 키워드를 사용하여 반공변성을 적용하도록 제네릭 매개변수를 설정할 수 있습니다. 반공변성 제네릭 타입 매개변수는 메서드의 매개변수와 같이 입력 용도로 사용되는 인스턴스에 대해서만 적용할 수 있습니다.
- 공변성(Covariant) : 제네릭 타입 매개변수로 지정한 타입을 해당 타입이 상속한(상속 계통상의 상위의) 타입으로 변경할 수 있음을 의미합니다. c# 에서는 out 키워드를 사용하여 공변성을 적용하도록 제네릭 매개변수를 설정할 수 있습니다. 공변성 제네릭 타입 매개변수는 메서드의 반환 타입과 같이 반환 용도로 사용되는 경우에 대해서만 적용할 수 있습니다.

<br>

`public delegate TResult Func<in T, out TResult>(T arg);`
- 위의 Func 예시에서 제네릭 타입 매개변수 T는 in 키워드로 설정되어 있어 반공변성이 적용되어 있고, TResult에는 out 키워드가 설정되어 있어 공변성이 적용되어 있습니다.

```cs
Func<object, ArgumentException> fn1 = null;

// 아래처럼 바꿀 수 있습니다.

Func<string, Exception> fn2 = fn1; //명시적으로 캐스팅하지 않아도 된다.
Exception e = fn2("");
```


- 가변성(Variance)은 컴파일러가 원래 타입과 변환하려는 타입 모두가 참조 타입일 경우에만 작동합니다. 달리 말하면, 가변성은 박싱이 필요한 값 타입에 대해서만 작동하지 않음을 의미합니다. (예를 들어 List<int> 를 IEnumerable<int> 로 바꿀 수 없습니다)
  - 컴파일러가 자동적으로 제네릭 정의를 확인해 공변성과 반공변성이 성립하도록 만들긴 하지만 사용자가 명시적으로 지정하지 않는다면 문제가 발생할 여지가 있습니다.
  - 또한 가변성은 ref나 out 키워드를 이용하는 제네릭 타입의 매개변수에 대해서는 허용되지 않습니다. `delegate void SomeDelegate<in T>(ref T t);` 해당 코드는 오류를 던집니다.

- 제네릭 인자와 반환 타입을 요구하는 델리게이트를 사용할 때에는 항상 in과 out 키워드를 지정하여 필요 시에 반공변성과 공변성의 장점을 활용할 수 있도록 해주는 것이 좋습니다. 왜냐하면 이러한 유연성이 나쁜 영향을 미치는 경우는 전혀 없는데다 델리게이트를 좀 더 범용적으로 사용할 수 있도록 해주기 때문입니다.

### 제네릭 메서드
...
#### 제네릭 메서드와 타입 유추
...

### 제네릭 기타 멤버들
- c#에서 속성, 인덱서, 이벤트, 연산자 메서드, 생성자, 소멸자를 정의할 때에는 자체적인 타입 매개변수를 지정할 수 없습니다. 하지만 제네릭 타입 안에서 이들 멤버가 정의되어 있을 경우, 이들 내부에서 타입 매개변수로 전달된 타입을 사용할 수는 있습니다.

### 검증 가능성과 제약조건
- 제약조건은 제네릭 매개변수로 지정할 수 있는 타입의 종류를 제한하는 방법입니다.
- 타입 매개변수에 적용할 수 있는 제약조건으로는 기본 제약조건(Primary Constraint), 확장 제약조건(Secondary Constraint), 생성자 제약조건(Constructor Constraint)이 있습니다.

#### 기본 제약조건
- 타입매개변수에는 기본 제약조건을 지정하지 않거나 단 한 개만 지정할 수 있습니다. sealed 되지 않은 클래스로 참조 타입을 지정할 수 있습니다. 그러나 일부 특별한 참조 타입들(System.Object, System.Void 등)은 사용할 수 없습니다.
- 기본 제약조건으로 class(참조타입)와 struct(값타입)를 사용할 수 있습니다.

#### 확장 제약조건
- 확장 제약조건은 인터페이스 타입으로 제약사항을 지정하기 위해서 사용됩니다.
- 인터페이스 제약조건 외에 타입 매개변수 제약조건(Type Parameter Constraint, 혹은 노출된 타입 제약조건 Naked Type Constraint)을 사용할 수 있습니다.
```cs
private static List<TBase> ConvertIList<T, TBase>(IList<T> list) where T : TBase
{
    var baseList = new List<TBase>(list.Count);
    for (var i = 0; i < list.Count; i++)
    {
        baseList.Add(list[i]);
    }

    return baseList;
}
```

#### 생성자 제약조건
- 생성자 제약조건을 지정하면, 컴파일러는 지정된 타입 인자를 추상 타입이 아니면서 동시에 매개변수가 없는 기본 public 생성자를 정의하고 있는지를 검사하게 됩니다.
  - 이 제약조건을 struct 제약조건과 같이 사용하면 오류로 간주되는데, struct는 이미 기본 생성자를 제공하고 있기 때문입니다.

#### 기타 검증 가능성 관련 문제
- 제네릭 타입 변수 캐스팅, 제네릭 타입 변수와 null 비교, 두 개의 제네릭 타입 변수 간 비교 등등


</details>


## 13장. 인터페이스

<details>
<summary>fold/unfold</summary>

### 클래스와 인터페이스 상속
...

### 인터페이스 정의하기
...

### 인터페이스 상속하기
...

### 인터페이스 메서드 호출에 대한 자세한 내용
...

### 인터페이스 메서드의 암묵적 구현과 명시적 구현(내부적으로 수행되는 작업)
...

### 제네릭 인터페이스
...

### 제네릭 인터페이스 제약조건
...
```cs
public static void M<T>(T t) where T : IComparable {}
```
- 위의 경우에서 제네릭 메서드에 값 타입을 적용할 경우 박싱이 일어나지 않습니다. C# 컴파일러는 IL 명령어를 추가하여 값 타입의 인스턴스를 매개변수로 인터페이스 메서드를 직접 호출하는 경우 박싱이 일어나지 않도록 보강합니다.
  - 인터페이스 제약조건을 사용하는 경우를 제외하고는 C# 컴파일러가 이 같은 IL 명령어를 추가하는 경우가 없으므로, 값 타입의 인스턴스를 매개변수로 인터페이스 메서드를 호출하는 경우에는 항상 박싱이 일어나게 됩니다.

### 같은 메서드 이름과 원형을 가지는 여러 인터페이스 구현하기
...

### 명시적 인터페이스 구현 메서드로 컴파일 시 타입 안정성 향상시키기
- 명시적 인터페이스 구현을 통해 타입 안정성을 확보하고 예기치 않은 박싱을 방지합니다.
```cs
public interface IComparable
{
    Int32 CompareTo(object other);
}

internal struct SomeValueType : IComparable
{
    private int m_X;
    public SomeValueType(int x) { m_X = x; }

    public int CompareTo(object other)
    {
        return m_X - ((SomeValueType)other).m_X;
    }
}
public static void Main()
{
    var v = new SomeValueType(0);
    var o = new object();
    var n = v.CompareTo(v); // 박싱 발생
    n = v.CompareTo(o); // InvalidCastException 예외 발생
}
```

```cs
internal struct SomeValueType : IComparable
{
    private int m_X;
    public SomeValueType(int x) { m_X = x; }

    public int CompareTo(SomeValueType other)
    {
        return m_X - other.m_X;
    }

    //명시적 인터페이스 구현
    int IComparable.CompareTo(object other)
    {
        return m_X - ((SomeValueType)other).m_X;
    }
}
public static void Main()
{
    var v = new SomeValueType(0);
    var o = new object();
    var n = v.CompareTo(v); // 박싱 없음
    n = v.CompareTo(o); // 컴파일 시점 오류
}
```
### 명시적 인터페이스 구현 메서드에서 주의해야 할 부분
명시적 인터페이스 구현 문제에서 가장 큰 문제점
- 명시적 인터페이스 구현 메서드를 타입 내에서 실제로 어떻게 구현하고 있는지가 문서화되어 있지 않다. 또한 Visual Studio IntelliSense도 이를 지원하지 않는다.
- 값 타입의 인스턴스를 인터페이스로 캐스팅할 때 박싱이 발생한다.
- 명시적 인터페이스 구현 메서드는 상속한 타입에서 호출할 수 없다.
...

### 설계 지침 : 기본 클래스 혹은 인터페이스
- IS-A vs. CAN-DO 관계 : 기본적으로 타입은 한 번에 하나의 구현만을 상속할 수 있다. 마냥ㄱ 상속한 타입과 기본 타입 간에 IS-A 관계를 설정할 수 없다면, 기본 타입을 정의하지 말고 인터페이스를 사용하는 것을 고려해야 한다. 인터페이스는 CAN-DO 관계를 나타낸다. 만약 여러 객체와의 관계 속에 CAN-DO 관계가 드러난다면 인터페이스를 사용하는 것이 적당하다.
- 사용자 편의성
- 일관성 있는 구현
- 버전 관리

</details>

## 14장. 문자, 문자열, 텍스트 사용하기

<details>
<summary>fold/unfold</summary>

### 문자
...
- .NET Framework 에서는 문자를 항상 16비트 유니코드 값으로 표현하기 때문에, 다국적 응용프로그램 개발을 비교적 쉽게 할 수 있다.
- 기본 개념과 캐스팅에 대해 설명

### System.String 타입
- System.String 타입은 변경할 수 없는 문자들의 순서 열이다.
  - CLR은 리터럴(literal) String 객체를 만들기 위해 특별한 방법을 사용합니다. 보통처럼 newobj IL 명령어가 아니라 ldstr(Load string) IL 명령어를 사용한다.

```cs
var s = "Hi" + " " + "there.";
```
- 문자열을 하나로 연결할때는 가급적 + 연산자를 사용하지 않는 것이 좋은데, 힙 상에 여러 개의 임시 문자열을 생성할 가능성이 있기 때문이다.
- 문자열을 비교할 때에는 Equals, Compare, StartsWith, EndsWith(책에서 예시로 적힌) 메서드들을 사용하는 것을 강력히 권장.
  - CompareTo 혹은 ==, != 과 같은 연산자를 활용하는 것은 피해야 한다. 그 이유는 호출자가 문자열 비교 방법을 명시적으로 지정할 수 없고, 이러한 비교 방식은 어떤 문자열 비교 방법이 사용될지 확인할 수 없기 때문.
  - 이외에도 FCL에는 문자열 비교를 위해 사용할 수 있는 System.StringComparer 같은 클래스가 정의되어 있다. 이 클래스는 동일 방식으로 반복해서 여러 문자열을 비교하려는 경우 유용하게 사용할 수 있다.

#### 문자열 인터닝
- 만약 응용프로그램 내에서 대소문자를 구분하여 서수를 비교하는 작업을 많이 수행하거나 동일한 값을 가지는 문자열들을 많이 사용하는 경우, CLR의 문자열 인터닝 매커니즘의 장점을 활용하면 성능을 비약적으로 개선할 수 있다.
- CLR은 초기화 시에 내부적으로 하나의 해시 테이블을 생성하는데, 이 해시 테이블의 키로는 문자열을 사용하고, 값으로는 관리 힙에 만들어진 string 객체의 참조를 저장한다. string 클래스 내에 정의되어 있는 정적 메서드(Intern, IsInterned)를 사용하면 내부 해시 테이블에 접근할 수 있다.
  - Intern은 string 타입의 매개변수를 받아 해시 코드 값을 계산한 후, 내부 해시 테이블에 일치하는 항목이 있는지 확인한다. 만약 일치하는 항목이 있는 경우, 기존의 string 객체가 반환된다. 일치하는 항목이 없는 경우, string 객체의 사본을 만들고 내부 해시 테이블에 그 참조를 추가한 후, 이 사본을 반환한다.
  - 응용 프로그램에서 더 이상 원래의 string 객체를 사용하지 않게 되면, 가비지 컬렉터가 해당 string 객체가 점유하고 있던 메모리를 제거할 수 있다. 하지만 내부 해시 테이블이 참조하고 있는 string 객체는 제거되지 않는데, 왜냐하면 해시 테이블이 string 객체를 참조하고 있기 때문이다. 내부 해시 테이블이 참조하고 있는 string 객체는 앱도메인이 언로드되거나 종료될 때까지 제거되지 않는다.
  - 문자열 인터닝은 유용한 기능임에는 틀림없으나 한편으로는 사용에 있어서 성능상의 오버헤드가 나타날 수 있다. 이 때문에 C# 컴파일러는 왜 문자열 인터닝을 기본으로 사용하지 않도록 했다.

#### 문자열 풀링
- 만약 같은 리터럴 문자열이 소스 코드에서 여러 번 등장한다면, 메타데이터의 크기가 불필요하게 늘어날 수도 있다.
- 이러한 문제를 해결하기 위해서 c# 컴파일러를 비롯한 많은 컴파일러들은 동일 리터럴 문자열을 모듈의 메타데이터에 단 한 번만 기록한다. 해당 문자열을 참조하는 모든 코드는 메타데이터상의 동일 문자열을 참조하도록 수정된다. 이를 통해 동일 문자열이 여러 차례 등장하는 경우, 이를 단 하나로 통합하므로 모듈의 크기를 눈에 띄게 줄일 수 있다.
 

### 효율적으로 문자열 생성하기
- string 타입은 변경할 수 없기 때문에, FCL 에서는 System.Text.StringBuilder라는 별도의 타입을 만들어, 문자열과 여러 문자들을 이용하여 동적으로 새로운 string 인스턴스를 만드는 방법을 제공하고 있다.
- 논리적으로, stringbuilder 객체는 char 타입의 배열을 나타내는 필드 하나를 가지고 있다. stringbuilder 의 멤버들을 통해서 이 문자 배열을 다룰 수 있도록 해주며, 문자열 내의 문자들의 개수 변화에 맞게 배열의 크기를 자유롭게 확장하거나 축소할 수 있다. 만약 이전보다 더 큰 크기의 배열을 필요로 할 때에는, stringbuilder 에서 자동으로 더 큰 배열을 하나 만든 후 문자들을 새 배열로 복사하고 새로운 배열을 사용하도록 변경한다.

### 객체에 대한 문자열 포현을 얻어오기 ToString
...
- 매개변수 없는 ToString 메서드에는 두 가지 문제점이 있다. 첫째, 문자열에 대한 서식을 제어할 수 있는 방법이 없다.둘째 문화권에 맞춘 서식을 선택할 방법이 마땅치 않다.
  - 드문 경우이지만 응용프로그램은 현재 실행 중인 스레드의 문화권 대신 사용자가 지정한 다른 문화권을 기준으로 문자열을 생성해야 하는 경우가 있을 수 있다. 이처럼 문자열 생성시에 정밀하게 좀 더 세부적인 제어가 필요한 경우가 있기 때문에, 세부적으로 서식을 지정하거나 문화권을 설정할 수 있는 ToString 메서드가 필요하다. System.IFormattable 인터페이스를 구현하고 있는 타입들은 서식이나 문화권을 설정할 수 있는 ToString을 구현하고 있다.

### 문자열을 객체로 분석하기: Parse
...
- 올바르지 않은 사용자 입력으로 인해 Parse 메서드가 자주 예외를 유발하게 되면 응용프로그램의 성능이 급감하게된다. 이런 경우에는 TryParse 메서드를 활용할 수 있다.

### 인코딩: 문자 배열과 바이트 배열 사이의 변환
- 인코딩 과정을 활용하면 유니코드를 지원하지 않는 시스템과도 문자열을 주고받을 수 있다.
- 가장 많이 사용하는 인코딩은 UTF-16과 UTF-8
   - UTF-16은 16비트 문자를 2바이트로 인코딩한다. 문자에는 영향을 주지 않으며, 압축도 발생하지 않아 성능상으로는 가장 훌륭하다. 이 같은 UTF-16 인코딩을 유니코드 인코딩이라고도 한다. UTF-16은 또한 리틀 엔디안(little endian)과 빅 엔디안(big endian)사이를 변환하기 위한 용도로도 사용된다.
   - UTF-8은 글자들을 종류에 따라서 1 바이트부터 4바이트로 인코딩을 수행한다. 
     - 0x0080 이하의 문자들은 1바이트로 압축되는데, 주로 미국 내에서 사용하는 문자들이 여기에 해당된다.
     - 0x0080 ~ 0x07ff 사이의 문자들은 2바이트로 변환되며, 유럽과 중동 지역 언어의 문자들이 여기에 해당된다.
     - 0x0800 이후의 문자들은 3바이트로 변환되며, 주로 동아시아 언어들이 여기에 해당된다. 
     - 마지막으로 서로게이트 쌍(surrogate paris)는 4바이트로 변환된다.
     - UTF-8은 매우 대중적인 인코딩이지만, 0x0800 또는 그 이상의 문자 값을 인코딩할 경우 UTF-16에 비해 비효율적이다.
- UTF-32 인코딩은 각각의 문자를 4바이트로 인코딩한다. 이 인코딩을 이용하면 각각의 문자들이 가변 길이를 가지는 경우에 대비하지 않아도 되기 때문에 문자들을 수횐하는 단순한 알고리즘을 작성할 때 유용하다. 예를 들어 UTF-32를 사용하면 모든 문자가 4바이트로 저장되기 때문에 서로게이트에 대해서 고민할 필요가 없다. 하지만 메모리 관점에서는 비효율적이므로, 네트워크나 파일로 문자열을 저장할 때에는 거의 사용되지 않고 보통 프로그램 내부에서만 활용하는 용도로만 사용된다.(이외에도 리틀/빅 엔디안 사이를 변환하는 용도로 사용되기도 한다.)
- UTF-7 인코딩은 7비트 값으로 문자들을 표현할 수 있는 오래된 시스템들과 함께 사용된다.(Deprecated)
- ASCII 인코딩은 16비트 문자를 ASCII 문자로 인코딩하는데, 0x0800 미만의 문자들은 1바이트로 변환한다. 0x007F 를 초과하는 문자들은 변환할 수 없으며 따라서 이 인코딩을 수행하면 문자가 소실된다. ASCII 구간(0x00 ~ 0x7F)에 있는 문자들로 구성된 문자열에 대하여 이 인코딩을 수행하면 데이터를 반으로 줄일 수 있을 뿐 아니라 상위 바이트를 잘라 버리기 때문에 속도가 매우 빠르다.

### 안전한 문자열
...

</details>

## 15장. 열거 타입과 비트 플래그

<details>
<summary>fold/unfold</summary>

### 열거 타입
- 열거 타입은 기호 이름과 연결되는 값의 쌍을 묶어서 정의하는 타입이다.
- 열거 타입은 보통 강력한 타입으로 취급된다. 예를 들어 만약 Color.Orange 값을 Fruit 열거 타입을 매개변수로 받는 메서드로 전달하려고 하면 컴파일러가 오류가 있음을 알려준다.

<br>

- 모든 열거 타입은 System.Enum 타입을 상속하는데, System.Enum은 System.Valutype을 상속하니 열거 타입들은 값 타입으로 분류된다. 하지만 열거 타입은 메서드, 속성 등을 정의할 수 없다.

<br>

```cs
internal enum Color
{
    White, //숫자 값 0 할당
    Red,
    Green,
    Blue,
    Orange,
}
```

위의 Enum 타입은 컴파일러에 의해 아래와 비슷한 형태로 컴파일한다.

```cs
internal struct Color : System.Enum
{
    // 다음의 public 상수 필드들은 Color 열거 타입의 기호와 값들을 정의하고 있다.
    public const Color White = (Color)0;
    public const Color Red = (Color)1;
    public const Color Green = (Color)2;
    public const Color Blue = (Color)3;
    public const Color Orange = (Color)4;

    //다음은 Color 변수의 값을 저장하는 인스턴스 필드다.
    //다음의 필드를 직접 참조하는 코드를 작성할 수 없다.
    public int value__;
}
```

- 실제로 C# 컴파일러는 위 코드를 컴파일 할 수 는 없는데, System.Enum을 상속하는 것은 허용하지 않기 때문이다. 기본적으로 열거 타입은 다수의 상수 필드와 함께 하나의 인스턴스 필드를 가지고 있는 구조체다.
- 열거 타입에 의하여 정의되는 기호들은 모두 상수 값이다. 그래서 컴파일러가 열거 타입의 기호를 참조하는 코드를 만나게 되면, 기호를 그와 연결된 숫자 값으로 치환하기 때문에 더 이상 열거 타입에서 정의하는 기호와는 연관성을 잃게 됩니다. 열거 타입을 사용하는 어셈블리가 실행 시에는 열거 타입을 필요로 하지 않으며, 컴파일 시점에서만 활용하는 것이다.

<br>

- System.Enum의 정적 메서드인 GetValues과, System.Type의 인스턴스 메서드인 GetEnumValues 를 활용하면 해당 enum 타입에서 정의하는 개별 기호들을 배열형태로 가져올 수 있다.
- 위의 메서드들은 Array를 반환하니 아래처럼 사용할 수 있다.
```cs
public static TEnum[] GetEnumValues<TEnum>() where TEnum : System.Enum
{
    return (TEnum[])Enum.GetValues(typeof(TEnum));
}
```

<br>

- System.Enum의 GetName와 System.Type의 GetEnumNames를 활용하면 enum 값에 대한 문자열 표현을 반환한다. 
- Enum의 Parse 와 TryParse 를 활용하면 문자열로부터 그에 대응되는 Enum값을 가져올 수 있다.
- Enum의 IsDefined와 Type의 IsEnumDefined를 활용하여 매개변수로 전달한 값이 특정 enum 타입 안에 존재하는지 확인할 수 있다.(대신 리플렉션을 사용하기 때문에 속도가 훨씬 느리다)

### 비트 플래그
- 열거 타입을 이용하여 결합 가능한 비트 플래그를 표현하는 방식은 매우 일반적이다. 열거 타입이 단일 수치 값을 표현하므로, 어떤 비트가 설정되어 있고, 어떤 비트가 설정되어 있지 않은지 나타내는 방식으로도 활용할 수 있다.
- Enum 타입은 HasFlag라는 메서드를 제공하고 있다. 하지만 매개변수로 Enum 타입을 받고 있는데 여기에 값 타입을 넣으면 박싱이 발생하므로 쓰지 않는 것을 권장.

<br>

열거 타입을 비트 플래그 조합처럼 사용하려는 경우 반드시 System.FlagsAttribute 사용자 정의 특성을 지정하는 것을 강력히 권장한다.
```cs
[Flags]
internal enum Actions
{
    None = 0,
    Read = 0x0001,
    Write = 0x0002,
    ReadWrite = Actions.Read | Actions.Write,
    Delete = 0x0004,
    Query = 0x0008,
    Sync = 0x0010,
}
```
- 아래의 경우 FlagsAttribute가 지정되어 있다면, ToString 메서드는 이를 확인하고, 현재의 숫자 값이 단순히 고정된 값이 아니라 비트 플래그의 조합으로 나온 값이라는 것을 이해하고 그에 맞추어 처리한다.
  - 아래 예시에 경우에는 Read, Delete를 출력한다.

```cs
public void DoSomething()
{
    var actions = Actions.Read | Actions.Delete; //0x0005
    Console.WriteLine(actions.ToString()); // 0x0005 에 대응하는 Actions의 값은 존재하지 않는다.
}
```

```cs
var a = (Actions)Enum.Parse(typeof(Actions), "Query");
Console.WriteLine(a.ToString());    //Query

Enum.TryParse<Actions>("Query, Read", out a);
Console.WriteLine(a.ToString());    //Read, Query

Enum.TryParse<Actions>("28", out a);
Console.WriteLine(a.ToString());    //Delete, Query, Sync
```

- 하지만 비트 플래그용 열거 타입에 대해서는 IsDefined 메서들르 절대 사용하면 안된다. 전달된 문자열을 검색하는 과정에서 ', ' 을 기준으로 문자열을 토큰화하지 않기 때문이다. 숫자를 전달하는 경우도, 정확히 일치하는 값을 찾으려 하지 특정 비트가 일치하는 경우에 대해서는 고려하지 않는다.



### 열거 타입에 메서드 추가하기
- 확장 메서드 활용

</details>

## 16장. 배열

<details>
<summary>fold/unfold</summary>

배열은 여러 개의 항목을 단일 컬렉션으로 다룰 수 있게 해주는 매커니즘이다. CLR에서는 1차원 배열, 다차원 배열, 중첩 배열(Jagged Array)를 지원한다. 모든 배열 타입은 System.Array 타입을 상속받는다.
- CLR은 배열에 대한 인덱스 값이 정확한지 항상 검사한다. 예를 들어 100개의 원소를 가진 배열에서 -5나 100을 사용하여 원소에 접근할 수 없다. 이렇게 할 경우, System.IndexOutOfRangeException 예외가 발생하게 된다.

### 배열 요소 초기화하기
- 배열 이니셜라이저(Array Initializer) 활용.

```cs
//Array Initializer
string[] names = new string[] { "Aidan", "Grant" };

//C#의 var 활용
var names = new string[] { "Aidan", "Grant" };

//배열의 타입 추론
var names = new[] { "Aidan", "Grant" };

//다음과 같이 좀 더 간편한 문법으로 배열을 만드는 것도 가능
string[] names2 = { "Aidan", "Grant" };
```

### 배열 캐스팅하기
- 참조 타입 요소로 구성된 배열의 경우, CLR은 암묵적으로 원본 배열의 오소를 특정 타입으로 캐스팅할 수 있다. 이 경우 양쪽의 배열 타입은 반드시 차수가 동일해야 하고, 원본 요소 타입에서 대상 요소 타입으로 암묵적이든 명시적이든 변환이 가능해야 한다. 하지만 값 타입의 요소로 구서오딘 배열은 다른 타입으로 캐스팅할 수 없다.
  - Array.Copy 를 활용하는 경우, 새로운 배열을 만들고 원래의 배열 요소를 꺼내어 대상 배열로 수동으로 지정할 수는 있을 것이다.
  - Array.Copy 메서드는 단순히 한 배열에서 다른 배열로 복사하는 메서드가 아니다. Copy 메서드는 복사 영역이 메모리상에서 겹치는 경우라도 C의 memmove함수와 같이 정확히 복사 해준다.
    - 박싱, 언박싱, 기본값 확장(CLR 의 int -> double), downcasting 와 같은 변환을 지원한다.
 
```cs
FileStream[,] f = new FileStream[5, 10];
object[,] o = f;    //2차원 객체 배열을 암묵적으로 캐스팅

int[] i = new int[5];
object[] o2 = i; //값 타입의 배열은 캐스팅 불가능

//배열을 새로 만들고, Array.Copy를 활용하여 각 메서드를 강제로 원본 배열에서 특정 타입으로 구성된 배열로 캐스팅을 수행하며 복사
//아래는 int를 박싱한 참조 객체로 구성된 배열을 만들게 된다.
o2 = new object[5];
Array.Copy(i, o2, i.Length);
```

- 만약 배열의 요소에 대한 복사본을 만드는 일만 하고 싶다면, System.Buffer의 BlockCopy 메서드를 사용하는 것이 Array의 Copy 메서드보다 더 빠르다. 하지만 Buffer의 BlockCopy메서드는 기본 타입에 대해서만 사용할 수 있으며, Array의 Copy 메서드와 같은 타입 캐스팅을 지원하지는 않는다.
  - 또한 이 메서드를 사용하는 경우 int 타입의 매개변수들은 배열 내의 바이트 오프셋으로 표현되는 것이며, 요소의 인덱스를 의미하는 것은 아니다. BlockCopy 메서드는 비트 단위로 취급할 수 있는 데이터를 다른 배열로 복사하기 위한 목적으로 설계되었으므로 Byte[] 배열 안에 들어있는 유니코드 문자를 Char[] 타입의 배열로 복사하기 위해 사용할 수도 있다.
- 배열의 요소들을 한쪽 배열에서 다른 쪽 배열로 안전하게 복사하기를 원한다면, 반드시 System.Array의 ConstrainedCopy 메서드를 사용해야 한다. 복사 작업이 완벽하게 끝낼 수 있도록 해주어, 복사 작업이 실패할 경우에도 대상 배열의 데이터를 변경하거나 훼손하지 않는다. 해당 메서드는 제약이 있는 실행영역(Constrained Execution Region, CER) 에서 사용 가능한다.

### 모든 배열의 암묵적 부모 타입인 System.Array
...

### 모든 배열이 암묵적으로 구현하는 IEnumerable, ICollection, IList 인터페이스
- System.Array 타입은 이 세 가지 인터페이스를 전부 구현하고 있다. (하지만 제네릭 버전이 아니다)
  - CLR 팀은 System.Array 타입에 `IEnumerable<T>`, `ICollection<T>`, `IList<T>` 인터페이스를 직접 구현하도록 하지 않았는데, 다차원 배열과 시작 인덱스가 0이 아닌 배열들에 지원해야 하는 문제 때문이었다.
  - 이러한 이유로 CLR 팀은 약간의 트릭을 활용해서 1차원 배열이면서, 시작 인덱스가 0인 배열 타입이 만들어지면 `IEnumerable<T>`, `ICollection<T>`, `IList<T>` 인터페이스를 자동으로 구현하고, T가 참조 타입인 경우 상속 계통을 따라 모든 상위 클래스들에 대해서도 추가적으로 세 개의 인터페이스를 구현한다.
  - 따라서 만약 `FileStream[] fsArray` 가 있다고 하면, CLR은 FileStream[] 타입을 생성할 때 자동으로 `IEnumerable<FileStream>`, `ICollection<FileStream>`, `IList<FileStream>` 인터페이스를 구현한다. 더불어 `IEnumerable<Stream>`, `ICollection<Stream>`, `IList<Stream>` (+ object 타입 버전까지) 상위 타입의 인터페이스 역시 구현한다. 
  - 그러나 만약 값 타입 배열이라면, 해당 타입에 대한 인터페이스는 구현하겠지만, System.ValueType 이나 System.Object 타입에 대해서는 이 인터페이스들을 구현하지 않는다.

### 배열의 전달과 반환
...
- Array.Copy 는 얕은 복사를 수행한다는 것을 주의할 것.
- 배열을 반환하는 메서드를 작성할 때, 배열 내부에 원소가 없는 경우, null을 반환하는 것보다 빈 배열을 반환하는 것이 좋다.(호출자 측에서 처리해야할 예외가 줄어든다.)

### 시작 인덱스가 0이 아닌 배열 만들기
- Array의 CreateInstance를 활용. 배열의 타입을 지정하거나, 배열의 각 차수마다 포함할 요소의 개수를 지정할 수 있다.
  - CreateInstance 메서드는 배열을 위한 메모리 공간을 할당하고, 배열의 메모리 블록에 추가 공간을 할당하여, 매개변수에 대한 정보를 저장한 후, 배열 객체에 대한 참조를 반환한다.


### 배열의 내부 구조
- CLR은 기본적으로 두 가지 유형의 배열을 지원한다.
  - 1 차원 배열이면서 시작 인덱스가 0인 배열. 이러한 배열을 SZ 배열 혹은 벡터라고 한다. (S는 1차원을, Z는 시작인덱스가 0을 의미)
  - 시작 인덱스가 지정되지 않은 1차원 배열과 다차원 배열을 지원한다.
- SZ 배열의 경우, 타입 이름을 출력하면 string 배열의 경우 `System.String[]` 을 출력하지만, 1차원이면서 시작 인덱스가 0이 아니라면 `System.String[*]`을 출력해서 다르다는 것을 구분한다. 
- CLR은 다차원 배열에 대해서 실제 실행 시점에서는 잠정적으로 시작 인덱스가 0이 아닌 것으로 간주한다. 따라서 시작 인덱스가 0이든 0이 아니든 타입을 출력할 때 `System.String[*,*]`처럼 * 표시가 나타나지 않는다.

<br>

- SZ배열에 접근하는 것이 그렇지 않은 배열에 접근 속도보다 빠르다. 
  - SZ배열 전용의 newarr, ldelem, ldelema, ldlen, stelem과 같은 IL 명령들이 있어서, 좀더 최적화된 방법을 사용하기 때문이다.

### 안전하지 않은 배열 사용과 고정 크기 배열
...

</details>

## 20장. 예외와 상태 관리

<details>
<summary>fold/unfold</summary>

### 예외의 정의
- 예외란 이름이 의미하는 바와 같이 멤버가 수행할 것으로 예상되는 작업을 완료하지 못한 경우를 말합니다.


### 예외 처리의 구조
- try 블록 내에 두는 코드는 정리 작업이 반드시 필요하거나 혹은 예외를 극복해야 할 필요가 있는 코드를 두게 됩니다. 이 외에도 try 블록 내에는 잠재적으로 예외를 발생시킬 가능성이 있는 코드를 두기도 합니다.
  - try 블록은 finally 블록이나 적어도 하나 이상의 catch 블록이 같이 나타나야 합니다. try 블록만 하나 있는 경우는 큰 의미가 없거니와 c#은 이를 허용하지 않습니다.


- catch 블록에는 예외를 처리하는 코드를 위치시켜야 하고, 다뤄야할 각각의 예외에 대해서 개별적으로 catch 블록을 작성할 수도 있습니다.
  - catch블록이 잡아낼 오류 타입을 지정할 때 상속 구조에서 아래쪽에 있는 예외 타입을 앞쪽에(파생 예외 타입들) 두고 위쪽에 있는 예외 타입(System.Exception)을 뒤쪽에 놓는 것이 좋습니다. CLR은 코드의 위에서 아래로 일치하는 catch타입을 찾아 내려갑니다.
  - CLR 이 try 블록 내에 있는 코드가(혹은 try 블록 내에서 호출하는 메서드가) 예외를 던지면 일치하는 catch블록의 타입을 찾을때까지 콜스택을 거슬러올라갑니다. 일치하는 catch 블록을 찾으면 거쳐 올라온 메서드의 가장 안쪽부터 finally 블록(있으면)을 수행합니다.
    - 여기서 예외 타입이 일치하는 catch 블록과 연관된 finally 블록은 아직 수행하지 않습니다. catch 블록을 수행하 이후에 finally 블록의 내용을 수행합니다.
  - catch 블록은 아래의 세 가지 작업 중 하나를 수행합니다.
    - 동일한 예외를 다시 던져서(Re-throw) 호출 스택의 상위로 예외를 전달
    - 발생한 예외에 추가적인 정보를 더한 다른 타입의 예외를 던져서 호출 스택의 상위로 새로 생성한 예외를 전달합니다.
    - catch 블록을 벗어나서 이하의 코드를 수행합니다.

- finally 블록 내의 코드는 수행이 보장되기 때문에, try블록 내에서 수행되는 코드들이 추가적인 정리 작업을 필요로 하는 경우에 주로 사용됩니다.
  - catch나 finally 블록 내에서 부주의하게 예외를 발생시키는 경우 finally 블록이 완전히 끝난 이후에 예외가 발생한 것처럼 동작합니다. 이 경우 CLR은 try 블록 내부에서 발생한 최초 예외의 추적정보를 손실할 뿐더러, 이 예외에 대한 모든 추가 정보(스택 추적 정보 등) 도 동시에 소실하게 됩니다.

### System.Exception 클래스
- CLR 자체는 int, string 등 다양한 타입으로 오류를 발생시킬 수 있도록 해놓았지만, 마이크로소프트는 모든 타입에 대해서 예외를 발생시키지 않도록 결정했고, System.Exception 타입을 정의하여 CLS를 따르는 모든 프로그래밍 언어는 System.Exception 혹은 이를 상속한 타입의 예외만을 발생시킬 것을 규격화했습니다.
- 만약 CLR이 개발한 어셈블리용 디버그 심볼(.pdb 파일)을 찾을 수 있다면 System.Exception의 StackTrace 속성과 System.Diagnostics.StackTrace의 ToString 메서드는 소스 코드의 파일 경로와 행 번호까지를 문자열에 포함시킬 수 있고, 이 정보는 디버깅 시에 상당히 유용한 정보입니다.
  - 스택 정보를 추적할 때 호출 스택상에 나타나야할 메서드들이 누락되는 경우가 있습니다. JIT 컴파일러가 특정 메서드를 인라인으로 호출하는 경우, 스택 정보는 스레드가 거쳐온 정보가 아닌 스레드가 돌아올 곳을 나타내기 때문에 예상과 다른 정보가 나타나는 경우 두 가지가 있습니다.
  - 디버그 빌드시 컴파일러는 어떤 메서드도 인라인으로 포함하지 말 것을 명령합니다.

### FCL에 정의된 예외 클래스
...

### 예외 발생시키기
- 예외를 발생시킬 때는
  - 어떤 타입의 예외를 발생시킬 것인지
  - 예외 타입에 어떤 메세지를 담을 것인지
충분히 고민한 뒤 결정하는 것이 좋다.

### 사용자 정의 예외 클래스 만들기
...

### 생산성을 위한 신뢰성 재고
...

### 지침과 모범 사례
- finally 블록은 아낌없이 사용하라
  - lock 문장을 사용하면, finally 블록 내부에 잠금해제 코드를 포함시킨다.
  - using 문장을 사용하면, fianlly 블록 내부에 객체의 dispose 메서드를 호출하는 코드를 포함시킨다.
  - foreach 문장을 사용하면, finally 블록 내부에 IEnumerator 가 참조하는 객체의 Dispose 메서드를 호출하는 코드를 포함한다.
  - 파괴자를 정의하면, finally 블록 내부에서 기본 클래스의 finalize 메서드를 호출한다.

```cs
try{
    //개발자가 실패할 것을 염두에 둔 코드를 여기서 수행
}
catch(Exception){
    //...
}
```

- 모든 예외를 잡으려 하지 마라
  - 클래스 라이브러리의 일부로 제공되는 타입은 절대로 어떤 상황에서도 위의 예시처럼 모든 예외를 잡으려 하면 안됩니다. 이러한 타입들은 델리게이트나, 가상 메서드, 혹은 인터페이스 메서드를 통하여 응용 프로그램 쪽 코드를 호출하는 경우도 흔합니다. 만일 응용프로그램 내의 특정 코드가 예외를 발생시키고, 응용 프로그램의 다른 쪽에서 발생한 예외를 잡아내도록 코드가 개발되어 있다면, 콜백되 응용프로그램 코드가 예외를 발생시키고, 발생된 예외가 라이브러리 타입 내의 코드를 벗어나서, 예외를 잡도록 고안된 응용 프로그램 코드 쪽으로 호출 스택을 거슬러 올라갈 수 있어야 합니다.
  - System.Exception 예외를 잡고 catch 블록에서 몰래 작업을 수행한 후 다시 예외를 던지는 경우라면 상관이 없습니다. 하지만 System.Exception 코드를 잡아 없애버리는 코드는 실패 상황을 숨겨버리기 때문에, 예기치 않은 결과를 초래하거나 잠재적으로 보안 취약성을 유발할 수 있으므로 절대로 그냥 놔둬서는 안됩니다.


```cs
public string CalculateSpreadsheetCell(int row, int column)
{
    string result;
    try
    {
        result = /* 스프레드시트 셀의 값을 계산하는 코드*/;
    }
    catch (DivideByZeroException)
    {
        result = "Can't show value : Divide by zero";
    }
    catch (OverflowException)
    {
        result = "Can't show value : Too big";
    }
    return result;
}
```

- 예외를 안정적으로 극복하기
  - 어떤 메서드를 호출할 때 그 메서드가 발생시킬 예외들을 미리 알고 있는 경우가 있다면 각각의 예외를 안정적으로 극복하고 응용프로그램을 계속해서 수행하도록 코드를 작성하고 싶을 것입니다.
  - System.Exception 타입으로 예외 처리를(예외를 다시 던지는 코드 없이) 하려고 해서는 안됩니다. try 블록 내에서 발생할 수 있는 모든 예외들을 미리 알 수 없는 노릇이기 때문입니다.

```cs
public void SerializeObjectGraph(FileStream fs, IFormatter formatter, object root)
{
    var beforeSerialization = fs.Position;

    try
    {
        formatter.Serialize(fs, root);
    }
    catch //모든 예외를 잡는다.
    {
        //만일 조금이라도 잘못된 부분이 있으면, 파일을 이전 상태로 재설정한다.
        fs.Position = beforeSerialization;
        //파일 크기 재설정
        fs.SetLength(fs.Position);
        //참고 : 파일 저장이 실패하였을 때만 스트림을 재설정해야 하기 때문
        //앞쪽의 코드는 finally 블록에 둘 수 없다.

        //호출자에게 예외를 발생하였음을 알려주기 위해서 동일한 예외를 다시 던진다.
        throw;
    }
}
```
- 복구할 수 없는 예외 발생 시 부분적으로 완료된 작업들을 취소하여 상태유지
  - 동작 수행 중 오류가 발생하여 진행 사항이 손상된 경우, 부분적으로 완료된 작업들을 취소할 수 있어서, 진행사항을 복구 할 수 있도록 하는 것이 좋습니다.
  - 부분적으로 완료된 작업들을 올바르게 취소하려면 모든 예외를 잡도록 코드를 작성해야 합니다. 이때 예외를 처리한 뒤 호출자에게 예외가 발생했음을 전파하는 것을 잊어서는 안됩니다.
  - 위의 예제에서는 catch 블록에 어떤 예외 타입도 지정하지 않았습니다. 단지 무엇인가가 잘못되었음을 확인할 뿐이며, throw 문을 통해 예외를 다시 던집니다.

- 계약을 유지하기 위해서 세부 구현사항 숨기기
  - 일부 상황에서는 특정 타입의 예외를 잡더라도 그와는 다른 타입의 예외를 다시 던지는 것이 효과적이 때가 있습니다. 이렇게 하는 유일한 이유는 메서드의 계약사항을 유지하기 위해서이며, 새롭게 생성하는 예외는 대체로 더욱 구체적이 예외 타입이어야 합니다.
  - 이 방법은 호출자에게 거짓말을 하는 것과 같습니다. 실제로 발생한 예외를 알려주는 것이 아니며, 어디서 발생했는지에 대한 정보(스택정보)도 제대로 전달하지 않습니다. 그러니 이 방법은 신중하게 활용해야 합니다.
  ```cs
  // GetPhoneNumber 메서드를 호출하는 사용자 입장에서 내부적으로 FileNotFoundException이나 IOException과 같은 예외를 발생한다는 것을 예측하기가 쉽지 않습니다. 그래서 NameNotFoundException이라는 새로운 예외를 생성하여 다시 던집니다.
  internal sealed class PhoneBook
  {
      private string m_Pathname;
  
      public string GetPhoneNumber(string name)
      {
          string phone;
          FileStream fs = null;
          try
          {
              fs = new FileStream(m_Pathname, FileMode.Open);
              //... 지정한 이름을 찾을 때까지 fs 로부터 내용을 읽어오는 코드
              phone = /*찾은 전화번호*/;
          }
          catch(FileNotFoundException e)
          {
              //찾고자 하는 이름을 포함시키고 원래 발생한 예외를 내부 예외로 취하는 다른 예외를 발생시킵니다.
              throw new NameNotFoundException(name, e);
          }
          catch(IOException e)
          {
              //찾고자 하는 이름을 포함하고, 원래 발생한 예외를 내부 예외로 취하는 다른 예외를 발생시킵니다.
              throw new NameNotFoundException(name, e);
          }
          finally
          {
              fs?.Close();
          }
          return phone;
      }
  }
  ```
  - 단순히 몇 가지 정보만을 더하는 정도의 작업을 하고자 한다면 예외 객체의 Data 속성 컬렉션(collection)에 그러한 정보를 추가하고 동일 예외를 다시 던지는 것이 좋습니다.
  ```cs
  private static void SomeMethod(string filename)
  {
      try
      {
          //...
      }
      catch(IOException e)
      {
          //IOException 객체에 파일 이름을 더한다.
          e.Data.Add("Filename", filename);
  
          //이제 정보가 추가된 동일 예외 객체를 다시 던진다.
          throw;
      }
  }
  ```
  - 하지만 이런 기법이 유용하지 않는 경우가 있는데, Reflection을 활용하는 메서드 내부에서 발생하는 예외는 CLR이 TargetInvocationException 으로 바꾸어 던집니다. 따라서 리플렉션작업 중 발생한 예외는 TargetInvocationException으로 추적해야 합니다.

### 처리되지 않은 예외
...

### 예외 디버깅하기
...

### 예외 처리 시 성능 고려사항
...

### CER(Constrained Execution Regions : 제약이 있는 실행 영역)
...
- CER은 실패가 발생하더라도 반드시 수행되어야하는 탄력적인 코드 블록을 의미합니다.
- 신뢰할 수 있는 메서드에 관한 내용

### 코드 계약(Code Contracts)
...
- 코드 계약(Code Contracts)은 개발자가 자신이 작성한 코드의 설계 고려사항을 코드를 이용하여 선언적으로 알려주는 방법입니다.

</details>

## 21장. 관리 힙과 가비지 수집

<details>
<summary>fold/unfold</summary>

### 관리 힙의 기본
다음은 리소스에 접근하기 위해 필요한 일련의 절차를 나타냈다.
1. 리소스를 대표하는 타입을 위해 메모리 공간을 할당한다.(c# 에서는 일반적으로 new 연산자를 이용하게 된다.)
2. 리소스의 초기 상태를 설정하기 위해서 메모리를 초기화 하고 리소스를 가용 상태로 만든다. 타입의 인스턴스 생성자(instance constructor)는 초기 상태를 설정하기 위한 용도다.
3. 타입의 멤버들을 이용하여 리소스를 사용한다.(필요한 만큼 반복적으로)
4. 리소스를 정리하기 위해서 상태를 변경한다.
5. 메모리를 해제한다. 이 과정은 가비지 수집기가 단독으로 수행한다.


#### 관리 힙에 리소스 할당하기
CLR 환경에서는 모든 객체가 관리 힙에서 할당되어야 한다. 프로세스가 초기화되면 CLR은 관리 힙에서 사용할 주소 공간(Address Space) 영역을 우선 할당합니다. CLR은 이 영역 내에서 다음에 객체를 할당할 위치를 가리키는포인터를 관리하는데, 이를 NextObjPtr으로 부른다면, NextObjPtr은 이 주소 공간 영역의 시작 주소를 가리키게 초기화 됩니다.

<br>

c# 의 new 연산자는 CLR 에게 다음과 같은 과정을 수행하게 한다.
1. 특정 타입의 필드를 고려할 때 몇 바이트 정도가 필요한지 계산한다.(기본 타입으로부터 상속한 필드도 모두 포함해야 한다.)
2. 계산된 값에 객체가 추가적으로 필요로 하는 메모리의 바이트 수를 더한다. 모든 객체는 타입 객체 포인터와 동기화 블록 인덱스라는 두 가지 필드를 추가로 가지게 된다.
3. 이렇게 계산된 값으로 CLR은 관리 힙 내의 영역에 객체를 할당할 만크의 충분한 여유 공간이 있는지 확인한다. 만일 가용 공간이 충분하다면, NextObjPtr이 가리키는 위치로 객체의 위치를 정하고, 그 공간을 0으로 채운다. 다음으로 타입 생성자를 호출하고(이 경우 NextObjPtr 값이 this 매개변수로 전달된다) new연산자는 객체의 참조를 반환하게 된다. 객체 참조 반환 직전에 NextObjPtr 값은 할당한 객체를 지나서 힙 내에서 다음 번에 객체를 할당할 위치를 가리키도록 변경된다.

<br>

관리 힙 입장에서는 새로운 객체를 할당하는 과정이란 것이 단순히 포인터에 특정 값을 더하는 작업일 뿐이므로 엄청나게 빠르게 수행될 수 있다.
- 대부분의 응용 프로그램에서 유사 시점에 생성된 객체들은 상호 강력한 연관성을 가지고 빈번한 참조가 이루어지는 경향이 있다. 
- 관리 힙에서는 이런 객체들이 아주 인접하게 할당될 것이기 때문에, 이 객체들을 접근하는 과정에서 참조의 지역성(locality of reference)에 기반을 둔 상당한 성능 향상을 보게 된다. 이러한 지역성으로 인해 프로세스의 워킹 셋(working set)이 작게 유지될 수 있고, 응용 프로그램이 메모리를 적게 쓰면서도 빠르게 수행될 수 있다. 참조의 지역성은 코드가 접근하는 객체들이 CPU 캐시(cache)에 계속해서 머물 수 있는 확률을 높이기 때문이다.


#### 가비지 수집 알고리즘
응용 프로그램이 새로운 객체를 생성하려 할 때, 관리 힙의 영역 내의 충분한 주소 공간이 남아있지 않을 수 있다. 이처럼 여유공간이 부족할 때 CLR 은 GC를 수행하게 된다.
- 이 말은 굉장히 간략화된 설명인데, 실제로 GC 0세대가 가득 찬 경우에 발생하게 된다.

<br>

- 참조 카운팅
  - 레퍼런스 카운트가 0인 객체에 대해서 가비지 수집을 진행한다.
  - 하지만 이 문제는 순환 참조(circular reference) 의 문제를 잘 처리하지 못할 수 있다.
- CLR 은 참조 추적(reference tracking) 알고리즘을 대신 사용한다. 
  - 첫째로 관리 합 내의 모든 객체를 순회하면서 특정 비트를 0으로 설정한다.(이 비트는 sync block index 필드에 포함된다)
  - 이후 특정 root 에 의해서 참조되는 객체가 힙에 있는 경우, CLR은 그 객체를 마크(mark) - sync block index 필드의 비트를 1로 설정 한다.
  - 마크 과정 이후 힙 내에 비트값이 마크 되지 않은 상태로 남아 있는 객체를 도달 불가능(unreachable)하며 가비지로 판정한다.
  - 마크 단계가 완료되면, 힙 내의 객체들은 마크된 객체들과 마크되지 않은 객체들로 양분된다. GC는 컴팩트 단계(compact phase)를 수행하며 마크된 객체들이 메모리 힙의 시작 지점 쪽으로 옮겨서 모든 살아남은 객체들이 연속된 메모리 공간상에 위치하도록 한다.
    - 컴팩트 과정을 통해 참조의 지역성이 되살아나고, 워킹 셋의 크기를 감소시킬 수 있다. 또한 메모리 힙에서 발생하는 파편화된 주소 공간을 완전히 없앨 수 있다.
    - 컴팩트 과정을 수행하면서 CLR은 각각의 루트로부터 객체가 옮겨간 거리만큼을 루트로부터 빼주는 작업을 수행한다.


### 세대 : 성능 개선을 위한
CLR의 GC는 세대를 고려한 가비지 수집기(generational garbage collector)다. 이는 다음과 같은 가정을 가지고 있다.
- 더 최근에 생성된 객체는 더 짧은 수명을 가지고 있다.
- 더 오래 전에 생성된 객체는 더 오랜 수명을 가질 것이다.
- 힙의 일부분을 정리하는 것이 전체 힙을 정리하는 것보다 빠르다.


<br>

세대를 고려한 가비지 수집기 동작 원리
- 관리 힙이 처음 초기화되면 어떤 객체도 포함되지 않은 상태가 된다. 힙에 새로 추가된 객체들을 0세대로 일컫는다. 
- CLR이 관리 힙을 초기화할 때 0세대에 수 킬로바이트 크기의 공간만을 허용하게 된다.(Budget Size) 새로운 객체가 계속 생성되어 허용된 크기를 초과하게 되면 그때 가비지 수집이 진행된다.
  - 이때 가비지 수집에서 살아남은 세대는 한 세대 승격하여 1세대가 된다.
- 이후 다시 객체가 힙에 할당되고 다시 GC가 동작하면 1세대도 가비지 수집 대상으로 삼을 수 있다.
  - 먼저 가비지 수집기는 1세대에 얼마나 많은 메모리가 사용되고 있는지 확인한다. 만일 1세대가 점유하고 있는 공간이 1세대의 허용된 크기보다 작다면 0세대의 객체만을 수집 대상에 포함시킨다. 1세대에 포함된 객체를 수집 대상에 포함시키지 않으면 전체적인 가비지 수집의 수행 속도가 빨라지게 된다.
- 1세대 객체가 점유하는 메모리 공간이 일정 수준이 넘어서는 경우 다시 0세대의 허용된 공간이 꽉 차는 경우 GC가 동작할 때 1세대의 메모리도 수집 대상에 포함시킨다. 이때 가비지로 수집되지 않은 1세대 객체들은 2세대로 승격된다.
  - 관리 힙은 0세대, 1세대, 2세대와 같은 크게 세 개의 세대만을 지원한다. CLR은 관리 힙을 초기화할 때, 세 개의 세대에 개별적으로 허용된 메모리 크기를 부여하게 된다. 하지만 CLR의 가비지 수집기는 자가 조정(Self-running) 수집기이기 때문에 으용프로그램에서 가비지 수집이 일어날 때마다 자체적으로 학습을 하게 된다.

<br>

- 가비지 수집기는 모든 스레드가 대부분의 시간을 스택의 최상단에서 유휴 상태로 있는 그런 형태의 응용프로그램에서 가장 잘 동작한다. 스레드가 어떤 작업을 수행해야 하는 상황이되면 깨어나서 잠시 사용되는 객체들을 생성하고, 반환되고 다시 유효 상태로 들어가는 그런 형태의 응용 프로그램을 예로 들 수 있다.
  - 서버 프로그램의 경우, 스레드 풀에 여러 스레드들을 생성해두고 클라이언트의 요청이 들어오면 요청을 처리하기 위해서 새로운 객체들을 생성하게 되고 결과를 클라이언트에게 돌려주고 나면 스레드는 다시 스레드 풀로 돌아가게 된다. 클라이언트의 요청을 처리하기 위해 생성하였던 대부분의 객체들을 이제 가비지가 된다.

#### 가비지 수집의 수행
아래와 같은 이유로 GC가 수행될 수 있다.
- 0세대에 허용된 메모리가 가득 차는 경우
- 코드에서 명시적으로 System.GC의 정적 메서드인 Collect를 호출. 
  - 코드를 통해서 CLR이 가비지 수집을 하도록 요청
- 운영체제가 메모리가 부족함을 보고
- CLR 이 앱도메인을 내리고unload 있는 경우
  - 앱 도메인이 내려가면 CLR 은 앱도메인 내의 어떤 것도 루트가 되지 못하는 것으로 간주하고, 모든 세대에 걸쳐서 가비지 수집을 진행한다.
- CLR 이 종료 ShutDown 되는 경우

#### 대형 객체
- CLR 은 모든 객체를 소형 객체와(small object) 대형 객체(large object)로 나눠서 생각한다. 오늘날 대형 객체는 85,000바이트(바뀔 수 있다) 이상의 크기를 가지는 객체를 의미.
- 대형 객체는 소형 객체와 동일한 주소 공간 내에 할당되지 않는다. 대형 객체는 프로세스의 주소 공간 내의 다른 위치에 있는 공간에 할당된다.
- 오늘날 GC는 대형 객체에 대해서는 컴팩트를 수행하지 않는데, 메모리상에서 대형 객체를 옮기기 위해서는 시간이 많이 소요되기 때문이다. 이러한 이유로 대형 객체들 사이에 주소 공간의 파편화가 발생할 수 있고, 이로 인해 OutOfMemoryException이 발생할 수도 있다.
- 대형 객체는 생성 즉시 2세대의 일부로 간주되므로 0세대나 1세대가 되지 못한다. 따라서 장시간 동안 사용될 객체만을 대형 객체로 만드는 것이 좋다. 짧은 시간 동안만 사용되는 개체를 대형 객체로 만들게 되면, 2세대에 대한 가비지 수집 절차가 너무 자주 일어나고 이로 인해 성능에 좋지 않은 영향을 미치게 된다. 일반적으로 대형 객체는 긴 문자열(XML 이나 JSON) 이나 바이트 배열인 경우가 많았으며, 파일이나 네트워크로부터 읽은 정보를 버퍼로 담아서 처리하는 등의 I/O 작업에 주로 사용된다.

#### 가비지 수집 모드
CLR이 기동되면 GC 모드가 선택되는데 이렇게 선택된 모드는 프로세스가 종료될 때까지 변경될 수 없다. 두 가지 기본 GC 모드가 있다. (응용 프로그램 구성 파일의 gcServer 요소를 통해 설정 가능)
- 워크스테이션(Workstation): 이 모드는 클라이언트 측 응용 프로그램에 적절한 형태로 튜닝된 가비지 수집 모드다. GC가 수행되면 응용 프로그램의 스레드가 멈추게 되는데, 이에 따라 사용자들이 불편함을 겪지 않도록 지연시간을 최소화하기 위한 모드다.
- 서버(Server) : 이 모드는 서버 측 응용프로그램에 적절한 형태로 튜닝된 가비지 수집 모드다. 성능과 리소스의 사용률을 최적화하는 데 중점믈 두고 있으며 같은 컴퓨터에서 다른 응용프로그램(서버나 클라이언트)이 수행되고 있지 않을 것으로 가정하고 GC 작업을 완료하기 위해서 모든 CPU들을 사용할 수 있을 것으로 기대한다. 이 GC 모드에서는 관리 힙을 여러 영역으로 구분하여 각각의 CPU가 그 영역을 전입하여 처리할 수 있도록 한다. 가비지 수집과정의 초기화 시에 가비지 수집기는 CPU 별로 특별한 스레드를 하나씩 배정하고, 이 스레드가 관리 힙 내의 주어진 영역을 다른 스레드와 함께 병렬적으로 처리할 수 있도록 한다. 이 같은 병렬 가비지 수집 과정은 여러 작업 스레드가 고유의 작업을 수행하는 서버 응용프로그램에서 잘 동작한다. 이러한 기능은 응용 프로그램이 수행되는 컴퓨터가 여러 개의 CPU를 가지고 있어서 성능 향상을 위해 여러 스레드들이 실질적으로 동시에 수행될 수 있는 환경을 필요로 한다.
- 추가적으로 GC는 동시concurrent 모드(이 모드가 default) 와 비동시nonconcurrent 모드라는 두 가지 하위 모드를 가지고 있다. (응용 프로그램 구성 파일의 gcConcurrent 요소를 통해 설정 가능)

### 특별한 정리 작업이 필요한 타입 다루기
- CLR은 객체가 가비지로 판단되고 관리 힙으로부터 메모리가 재사용되기 이전에 특정 코드를 수행할 수 있도록 finalization이라고 불리는 매커니즘을 제공한다. 파일, 네트워크 연결, 소켓, 뮤텍스 등과 같은 네이티브 리소스를 감싸고 있는 모든 타입은 finalization을 지원한다. CLR은 이 같은 객체가 더 이상 도달 가능 상태가 아닌 것으로 판단되면, 객체가 자신을 finalize할 수 있도록 해주어 객체가 감싸고 있던 네이티브 리소스를 해제하게 된다.
  - C++ 의 소멸자와 크게 다르다. c++ 에서와 같이 특정 타입의 객체가 가용 범위를 빠져 나오는 순간에 호출되는 것이 아니며, CLR은 특정 시점에 정확히 객체를 파괴(deterministic destruction)하는 기능을 제공하지 않다. 그러니 c#역시 이러한 매커니즘을 제공할 수 없다.

<br>

- 가비지로 분류된 객체의 Finalize 메서드는 가비지 수집의 완료 시점에 호출된다. 이 말은 이러한 객체들이 점유하고 있는 메모리 공간은 Finalize 메서드가 객체 내의 필드에 접근하는 코드를 수행할 수도 있으므로 바로 해제되어서는 안 되는 것을 의미하기도 한다.
  - finalize가능한 (finalizable)객체는 가비지 수집 과정에서 반드시 살아남아야 하며, 다음 세대로 승격 되게 된다. 그러해서 finalizable 객체는 필요보다 더 오랜 시간동안 살아남게 된다. 해당 객체가 참조하는 다른 객체들 역시 같이 승격된다.
- 사용자는 finalize 메서드가 언제 수행될지를 제어하는 방법이 없다. finalize메서드는 응용 프로그램이 추가적인 메모리를 요구하며 가비지 수집이 수행되는 과정에서 수행된다. 또한 CLR은 여러 Finalize 메서드들이 어떤 순서로 호출될지를 전혀 보장하지 않는다.(만약 Finalize 내부에서 서로 다른 객체 사이에 종속성을 가진다면 문제가 발생할 수 있다.)
- CLR은 Finalize 메서드를 호출하기위해서 특별히 높은 우선순위의 전용 스레드를 사용한다. 이렇게 하지 않으면 데드락이 발생할 수 있기 때문이다.
  - Finalize메서드가 처리되지 않은 예외를 발생시키면 프로세스는 종료된다. 이렇게 발생한 예외는 처리할 방법이 없다.

<br>

#### Finalization의 내부

응용프로그램이 새로운 객체를 생성하려면 new 연산자를 사용하여 힙으로부터 메모리를 할당 받아야 한다. 만일 객체가 Finalize 메서드를 정의하고 있다면 타입의 생성자가 호출되기 직전에, 객체를 가리키는 포인터가 fianlization 리스트에 삽입된다. 해당 리스트의 각 항목은 객체가 점유하고 있는 메모리를 반납하기 전에 finalize 메서드를 호출해야 하는 객체를 가리키고 있다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/21-13.jpg" width="60%" height="60%">

가비지 수집 절차가 진행되고 객체들이 가비지로 판단되면 가비지 수집기는 finalization 리스트를 살펴보고 가비지로 판단된 객체들을 참조하고 있는지 확인한다. 만일 그러한 객체 참조가 존재한다면 finalization 리스트로부터 항목을 제거하고, 제거된 항목들을 freachable 큐에 추가한다.(F - reachable) 해당 큐 내의 각 항목은 finalize 메서드가 호출될 준비가 된 객체를 나타낸다. 가비지 수집이 완료되면 관리 힙의 모습은 아래와 같이 될 것이다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/21-14.jpg" width="60%" height="60%">

CLR은 Finalize 메서드를 호출하기 위해서 특별히 높은 우선순위의 전용 스레드를 사용한다. 이처럼 전용의 스레드를 사용하는 이유는 응용프로그램 내의 보통 우선순위 스레드를 사용하게 되면 스레드 동기화 문제가 발생할 가능성이 있기 때문에 이를 피하기 위해서 전용의 스레드를 사용하게 된다. freachable 큐가 비어있다면(보통의 경우) 이 스레드는 sleep 상태가 된다. 하지만 freachable 큐에 항목이 추가된다면 스레드가 깨어나서 큐로부터 항목을 제거한 후 그 항목이 가리키는 객체의 finalize 메서드를 호출하게 된다. 이 같은 스레드의 동작 방식 때문에 해당 객체의 코드를 수행하던 스레드가 finalize 메서드를 호출할 것이라고 가정해서는 안 된다.
- freachable 큐는 마치 정적 필드처럼 다수의 루트들을 가지고 있는 또 다른 루트처럼 동작하게 된다. 즉 freachable 내의 각 항목들은 객체를 도달 가능 상태로 만들고 가비지가 되지 않도록 해준다.
- 가비지 수집기는 도달 가능하지 않은 객체를 가비지로 판단한다. 가비지 수집기가 객체에 대한 참조를 finalization 리스트에서 freachable 큐로 옮기게 되면, 객체는 다시 도달 가능한 상태가 되어 메모리를 반납하지 않아도 되다. 최초에는 객체가 가비지였으나 이후에 가비지가 아닌 상태로 바뀌게 된 것이다. 이를 객체가 복원(resurrected)되었다고 한다.
- freachable 큐에서 빠져나오면서 finalize를 호출한 뒤 다음번에 더 오래된 세대에 대하여 가비지 수집이 수행되면, finalize 가 완료된 객체들이 이제는 진짜 가비지가 된다. 왜냐하면 응용 프로그램의 어떤 루트도 더 이상 이 객체들을 가리키고 있지 않을 뿐더러, freachable 큐 또한 더 이상 이 객체들을 참조하고 있지 않기 때문이다. 

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/21-15.jpg" width="60%" height="60%">


### 객체의 수명을 수동으로 모니터링하고 제어하기
...
- GCHandle 타입을 활용하여 객체의 수명을 확인하는 내용

</details>

## 22장. CLR 호스팅과 앱도메인

<details>
<summary>fold/unfold</summary>

호스팅(Hosting)은 어떤 응용프로그램에서도 CLR을 사용할 수 있도록 해주는 기능이다. 특히 이 기능을 이용하면 기존에 개발된 응용프로그램에 일정 부분의 추가 기능을 관리 코드로 작성할 수 있게 해준다.


### CLR 호스팅
- .NET Frmework는 윈도우 운영체제에서 수행된다. 즉 .NET Framework가 윈도우 운영체제와 상호 운용될 수 있는 기술을 이용해서 만들어져야만 했음을 의미한다. 일단 모든 관리 모듈과 어셈블리 파일은 반드시 윈도우 PE(portable executable) 파일 포맷을 사용해야 하고 윈도우 실행 파일(EXE)이거나 DLL 이어야 한다.
- 모든 윈도우 응용 프로그램은 CLR을 호스팅할 수 있다. 그런데 CLR COM 서버의 인스턴스를 생성하기 위해서는 CoCreateInstance를 호출하는 것이 아니라, 네이티브 호스트에서 MetaHost.h 에 정의되어 있는 CLRCreateInstance 함수를 호출해야 한다.
  - CLRCreateInstance 함수는 MSCoreEE.dll 파일 내에 구현되어 있으며, 보통 C:\Windows\System32 디렉터리에서 찾을 수 있다. 이 DLL을 심(shim)이라고 부르는데, 이 DLL은 어느 Version의 CLR을 생성할지를 결정하는 역할만을 수행하며 어떠한 CLR COM 서버 기능도 포함하고 있지 않다.
  - 하나의 컴퓨터에 여러 버전의 CLR이 설치될 수는 있지만, MSCorEE.dll(심)은 유일하게 하나의 버전만이 존재한다.
  - CLRCreateInstance 함수는 ICLRMetaHost 인터페이스를 반환한다. 호스트 응용 프로그램에서는 이 인터페이스에 포함된 GetRuntime 함수를 호출할 때 생성하고자 하는 CLR의 버전을 지정할 수 있으며, 이후에 심이 요청한 버전의 CLR을 호스트 프로세스로 로드해준다.
    - 기본적으로 관리 실행 파일이 수행되면 심이 실행 파일을 학인하여 응용 프로그램을 만들고 테스트된 CLR의 버전 정보를 가져온다. 하지만 응용프로그램은 XML로 작성된 응용 프로그램 구성파일 내의 requiredRuntime와 supportedRuntime을 통해서 이 같은 기본 동작을 변경할 수 있다.

<br>

- GetRuntime 을 통해 ICLRRuntimeInfo 인터페이스를 가리키는 포인터를 얻어올 수 있고, ICLRRuntimeInfo 인터페이스의 GetInterface를 통해 ICLRRuntimeHost 인터페이스를 가리키는 포인터를 얻어올 수 있다. 
- 호스트 응용프로그램은 ICLRRuntimeHost 인터페이스에서 정의하고 있는 메서드를 이용하여 다음과 같은 작업을 수행할 수 있다.
  - 호스트 매니저(Host Manager)를 설정한다. 호스트가 메모리의 할당, 스레드 스케줄링과 동기화, 어셈블리 로딩 등의 작업에 참여할 것임을 CLR에 알려준다. 또한 가비지 수집이 시작되거나 종료될 때 그리고 요청한 작업 등이 작업 시간을 초과할 때에 호스트에게 알려줄 것을 요청한다.
  - CLR 매니저(CLR Manager)를 가져온다. CLR에게 일부 클래스나 멤버 등을 사용하지 못하도록 한다. 또 호스트는 어떤 코드가 디버깅될 수 있으며 어떤 코드가 디버깅될 수 있는지 알려주며, CLR이 정지되거나 스택 오버플로우(stack overflow) 등의 예외 상황이 발생하였을때 호스타 내의 어떤 메서드를 호출해줘야 하는지 알려준다.
  - CLR을 초기화하고 시작한다.
  - 어셈블리를 로드하고 로드한 어셈블리 내의 코드를 수행한다.
  - 윈도우 프로세스 내의 관리 코드가 더 이상 수행되지 못하도록 CLR을 중단한다.

<br>

- CLR을 호스팅하면 유용한 경우가 상당히 많다. 응용프로그램이 CLR의 기능을 사용할 수 있고 적어도 코드의 일부를 관리코드로 작성할 수 있는 이점이 생긴다. 
  - 다른 프로그래밍 언어를 사용하여 작업할 수 있도록 해준다.
  - 코드가 JIT 컴파일되므로 인터프리터를 사용하는 경우보다 속도 향상을 꽤 할 수 있다.
  - 메모리 누수나 메모리 손상을 피할 수 있도록 가비지 수집을 이용할 수 있다.
  - 보안 샌드박스 (sandbox) 내에서 코드를 수행한다.
  - 호스트는 풍부한 개발 환경을 제공하는데 있어 걱정을 덜 수 있다. 호스트는 언어, 컴파일러, 에디터, 디버거, 프로파일러 등의 기본 기술들을 그대로 사용할 수 있다.

<br>

- 프로세스 내에 CLR이 로드 되면 결코 언로드(unload) 시킬 수 없다. ICLRRuntimeHost 인터페이스의 AddRef나 Release 메서드를 호출해도 소용이 없으며, 유일한 방법은 프로세스를 종료하여 프로세스가 가진 모든 리소스를 해제하는 것 뿐이다.

### 앱도메인

#### Reference
- [understanding-process-application-domain-and-assemblies](https://www.c-sharpcorner.com/article/understanding-process-application-domain-and-assemblies/)

<br>

CLR COM 서버는 초기화 시 앱도메인을 생성하게 된다. 앱도메인이란 일련의 어셈블리를 포함하는 논리적인 컨테이너 역할을 수행한다. 첫번째 앱도메인은 CLR이 초기화 될 당시 생성되며 이를 기본 앱도메인(Default Appdomain) 이라고 한다. 이 기본 앱도메인은 프로세스 종료 시에만 파괴된다.
- 기본 앱도메인 외에도 비관리 COM 인터페이스 메서드나 관리 타입 메서드를 이용하면 추가적인 앱도메인을 생성할 수 있다. 앱도메인을 만드는 전체적인 목적은 격리 수단을 제공한다는 데 있다고 할 수 있다.
- 하나의 프로세스는 다수의 applicationDomain을 로드할 수 있다. 다수의 프로세스를 새로 생성하는 방식보다 다수의 앱 도메인을 활용하는 방식이 좀더 성능면에서 오버헤드가 적다.(Reference에서 나온 내용)


- 앱도메인의 구체적인 기능
  - 특정 앱도메인 내의 코드가 생성한 객체는 다른 앱도메인 내의 코드에서 직접 접근할 수 없다.
    - 특정 앱도메인 내의 코드가 객체를 생성하면, 이 앱도메인이 객체를 소유하게 되면서, 다른 앱도메인에는 존재할 수 없게 된다. 특정 앱도메인의 코드가 다른 도메인 내의 코드로 생성한 객체에 직접 접근하지 못하게 함으로써 경계를 명확히 구분할 수 있도록 해준다. 격리가 선행되기 때문에 프로세스 내에서 특정 앱도메인을 다른 도메인에 영향을 미치지 않고 언로드할 수 있다.
  - 앱도메인은 언로드될 수 있다.
  - 앱도메인을 개별적으로 보안성을 유지한다.
    - 앱도메인을 생성할 때 앱도메인 내에서 수행할 어셈블리의 최대 권한을 제한하기 위해서 개별적으로 권한 수준을 지정할 수 있다. 이 방법을 통해 앱도메인에 로드된 코드가 호스트가 유지하고 있던 중요 데이터를 읽어가거나 손상시키지 못하도록 할 수 있다.
  - 앱도메인은 개별적으로 구성된다.

<br>

윈도우 운영체제에서 각각의 응용프로그램들은 개별적인 프로세스 주소 공간을 가진다. 이로 인해 특정 응용프로그램 내의 코드는 다른 응용 프로그램 내의 코드와 데이터에 접근할 수 없으며, 이 같은 프로세스 격리를 통해서 보안 허점이나 데이터 손상 혹은 기대하지 못한 동작이 유발될 가능성을 차단한다. 그러나 윈도우에서 프로세스를 생성하는 작업은 상당한 비용이 발생한다. Win32의 CreateProcess 함수는 매우 느리고 프로세스의 주소 공간을 가상화하기 위해서 메모리도 많이 소비된다.
- 만일 응용 프로그램이 안정성이 담보되고 비관리 코드를 호출하지 않는 관리코드로만 구성되어 있다면 단일 프로세스 내에서 여러 관리 응용프로그램들을 수행하는 것도 문제 될 것이 없다. 또한 앱도메인을 이용하면 각 응용프로그램별로 보안을 설정하고, 구성 정보를 지정할 수 있을 뿐 아니라 개별적으로 종료할 수도 있다.

<br>

단일의 윈도우 프로세스가 하나의 CLR COM 서버를 수행하고 있는 모습
- 아래의 CLR은 현재 두 개의 앱도메인을 관리하고 있다. 개별 앱도메인은 각자 로더 힙과 접근 가능한 타입에 대한 정보만을 가지고 있다. 로드 힙 내의 각각의 타입 객체는 메서드 테이블을 가지고 있고, 메서드 테이블 내의 개별 항목들은 한 번이라도 수행된 적이 있다면, JIT 컴파일된 네이티브 코드를 가리키고 있다.
- 또한 개별 앱도메인이 몇몇 어셈블리들을 로드하고 있다. 여기서 System.dll의 경우 양쪽 앱도메인에서 각각 로드되어 있다. 두 앱도메인이 System.dll 파일 내의 어떤 타입을 동일하게 사용하더라도 각각의 로더 힙에 타입 객체가 생성된다. 이는 타입 객체에 할당된 메모리가 모든 앱도메인 사이에 공유되지 않기 때문이다.
- JIT 컴파일러가 생성한 네이티브 코드 역시 앱도메인별로 개별적으로 생성되며 공유되지 않는다.
- 동일 리소스를 공유하지 않는 것은 오버헤드가 될 수 있지만 앱도메인의 전체적인 목적이 격리를 제공하는 것으로서 CLR은 다른 앱도메인에 나쁜 영향을 미치지 않으면서 앱도메인을 언로드하거나 리소스 해제할 수 있어야 한다.
<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/22-1.png" width="70%" height="70%">

<br>

- 일부 어셈블리들은 여러 도메인에서 공유되는 것이 바람직한 경우도 있다. MSCorLib.dll 과 같은 파일이 그 예가 될 수 있는데, 이 어셈블리는 System.Object, System.Int32 를 포함하고 있을 뿐 아니라, .NET Framework 에서도 없어서는 안 될 타입들을 정의하고 있다.
  - 이 어셈블리는 CLR이 초기화될 때 로드되고, 모든 앱도메인이 이 어셈블리 내의 타입들을 공유하게 된다. 리소스의 사용량을 줄이기 위해 MSCoreLib.dll은 도메인 중립(domain-neutral) 공간에 로드된다. CLR은 이 처럼 도메인 중립 공간에 로드된 어셈블리를 위한 아주 특별한 로더 힙도 가지고 있다. 이 로더 힙 내의 모든 타입 객체와 타입 내의 네이티브 코드는 프로세스 내의 모든 앱도메인에 공유된다.
  - 그러나 도메인 중립 공간에 로드된 어셈블리는 프로세스가 종료되기 전까지는 절대 언로드 될 수 없다.

#### 앱도메인의 경계를 넘어 객체 사용하기
....


### 앱도메인의 언로딩
- 앱도메인을 언로딩하면 CLR은 앱도메인 내에 로드되었던 모든 어셈블리를 언로드하고 앱도메인의 로더 힙도 해제한다.
- AppDomain의 정적 메서드인 Unload를 호출하면 CLR은 지정한 앱도메인을 올바르게 언로드하기 위해 상당한 작업들을 수행한다.
  - 관리 코드를 수행한 적이 있었던 프로세스 내의 모든 스레드를 일시 중지시킨다.
  - CLR은 일시 중지된 모든 스레드의 스레드 스택을 뒤져서, 앱도메인이 언로드할 코드를 현재 수행 중이거나 혹은 계속해서 수행을 해나가다 보면 앱도메인이 언로드할 코드 쪽으로 반환될 스레드를 찾아낸다. 이후 CLR은 자신의 스택에 언로드될 앱도메인의 코드를 가지고 있는 모든 스레드에게 ThreadAbortException 예외를 발생시킨다. 스레드는 스택 unwind를 수행하게 되고 CLR은 이 예외를 삼켜버림으로써 프로세스가 종료되지 않고 계속 수행하게 한다.
  - 위의 두 단계를 통해 모든 스레드들이 제거할 앱도메인을 떠나게 되면, CLR은 언로드될 앱도메인 내에 생성된 객체를 참조하고 있는 프록시 객체에 특정 플래그를 설정한다. 이러한 프록시 객체들은 참조하고 있던 실제 객체가 사라진 것을 알게 된다.
  - CLR은 앱도메인 내애 생성되었던 모든 객체들은 메모리를 재사용하기 위해서 강제로 가비지 수집을 수행한다. 객체들이 가지고 있는 Finalize 메서드는 올바르 정리 작업이 수행될 수 있도록 모두 호출한다.
  - CLR은 남아있는 모든 스레드를 재개시킨다. AddDomain.Unload 를 호출하였던 스레드도 수행을 이어나갈 것이다.

### 앱도메인의 모니터링
호스트 응용프로그램은 앱도메인이 사용하는 리소스를 모니터링할 수 있다. 

### 앱도메인의 첫째 예외 통지
각각의 앱도메인은 CLR이 catch 블록을 찾기 시작할 때 수행되는 일련의 콜백 메서드들을 가지고 있다. 이 메서드들을 이용하여 로깅을 수행하거나 혹은 앱도메인 내에서 발생한 예외를 모니터링 하는 매커니즘으로 사용한다.
- 예외가 최초로 발생하게 되면, CLR은 앱도메인에 등록된 FirstChanceException 콜백 메서드를 호출한다. 이후 CLR은 스택에서 동일 앱도메인의 catch 블록을 찾는다. 만일 catch 블록이 발생한 예외를 처리하면 예외 처리 과정이 완료되고 보통의 수행 과정으로 복귀하게 된다. 만일 앱도메인이 예외를 처리할 수 있는 catch 블록을 가지고 있지 않다면 CLR은 호출한 앱도메인에 이르기까지 스택을 거슬러 올라가서 동일 예외를 다시 한번 발생시킨다.

### 호스트는 앱도메인을 어떻게 사용하는가
- 여기 나중에 다시 읽기

### 고급 호스트 제어
- 여기 나중에 다시 읽기

</details>

## 23장. 어셈블리 로딩과 리플렉션

<details>
<summary>fold/unfold</summary>

### 어셈블리 로딩
...
- JIT 컴파일러가 특정 메서드의 IL을 컴파일하다 보면 어떤 타입들이 참조되고 있는지를 알게 된다. 런타임 시에 JIT 컴파일러는 참조되고 있는 타입들이 어느 어셈블리에 저장되어 있는지를 확인하기 위해서 어셈블리의 TypeRef와 AssemblyRef 메타데이터 테이블을 이용한다.
- JIT 컴파일러는 이러한 부분들에 해당 하는 이름(확장자와 경로가 없는), 버전, 문화권, 공용 키 토큰을 모두 모아 문자열로 결합한 후 어셈블리 구분자를 만들고 이를 이용하여 어셈블리를 앱도메인으로 읽어오려 한다.(앞서 로드되지 않은 경우)

<br>

- 내부적으로 CLR은 System.Reflection.Assembly 클래스의 정적 Load 메서드를 이용하여 로드한다.
  - 내부적으로 Load를 호출하면 CLR은 버전 바인딩 리디렉션 정책을 어셈블리에 적용하고, 전역 어셈블리 캐시로부터 어셈블리를 찾는다. 
  - 이후 응용프로그램이 기본 디렉터리, 그 아래의 하위 디렉터리, 코드베이스(codbase) 위치를 차례로 찾는다.
    - 만일 Load메서드를 호출할 때 약한 어셈블리 이름을 전달하였다면 버전 바인딩 리디렉션 정책을 적용하지 않고, GAC로부터 어셈블리를 찾지도 않는다.
  - Load 메서드가 어셈블리를 찾아내면 로드한 어셈블리를 나타내기 위한 Assembly 객체를 생성하고 그 참조를 반환해준다.
    - 만일 Load메서드가 어셈블리를 찾지 못하면 System.IO.FileNotFoundException을 발생시킨다.


<br>

- 드문 경우긴 한데 특정 CPU 아키텍처에 해당하는 어셈블리를 로드하고 싶을 수도 있다. 이 경우 어셈블리의 구분자를 지정할 때 프로세서의 아키텍처를 포함시킬 수 있다.
  - MSIL, X86, IA64, AMD64, ARM 등등
  - 아래 예시에서는 ProcessArchitecture의 값을 MSIL로 설정.

```console
"SomeAssembly, Version=2.0.0.0, Culture=neutral, PublicKeyToken=01234567890abcde, ProcessArchitecture=MSIL"
```

<br>

- System.AppDomain 내부에도 Load메서드가 인스턴스 메서드 형태로 존재한다. 이는 사용자가 지정한 앱도메인에 어셈블리를 로드할 수 있도록 해준다. 이 메서드는 비관리 코드에서 호출하도록 설계된 메서드이고, 호스트가 특정 앱도메인에 어셈블리를 주입할 목적으로 만들어졌다.
  - AppDomain의 Load 메서드를 호출하려면 어셈블리 구분자를 문자열로 전달해야 하기 때문에 관리 코드 개발자는 보통 이 메서드를 사용하지 않는다.
  - Assembly의 참조를 반환하는데 System.Assembly 클래스는 System.MarshalByRefObject를 상속하지 않았기 때문에, 호출한 앱도멘인 쪽으로 Assembly 객체를 반환하기 위해서는 반드시 값으로 마샬링되어야 한다. 하지만 CLR이 어셈블리를 로드하는 과정에서는 호출하는 앱도메인의 설정을 이용하여 어셈블리를 찾고 로드할 것이다.
  - 호출하는 앱도메인의 정책과 검색 위치를 사용하였을 때 어셈블리를 찾지 못하면 FileNotFoundException을 던진다.
  - 바람직한 동작 방식이 아니므로 사용하지 않는 것을 권장

<br>

- 동적으로 확장 가능한 응용프로그램이 Assembly의 Load 메서드를 이용하여 특정 앱도메인으로 어셈블리를 로드하는 방식을 더 선호한다. 이 메서드를 사용할 때에는 어셈블리 구분자를 조합할 수 있는 개별 정보들을 모두 가지고 있어야 하므로 이를 쉽게 해줄 각종 유틸리티 도구가 존재하는데, 이러한 종류의 도구들은 어셈블리 파일의 경로명을 명령 행 매개변수로 받아들인다.
- 어셈블리를 경로명으로 이용하여 로드하려면 Assembly의 LoadFrom 메서드를 호출하면 된다.
  - 내부적으로 LoadFrom은 먼저 System.Reflection.AssemblyName의 정적 메서드인 GetAssemblyName을 호출하는데, 이 메서드는 지정한 파일을 열고 AssemblyDef 메타데이터 테이블의 항목을 찾아 어셈블리 구분자 정보를 획득한 후, System.Reflection.AssemblyName 객체로 반환한다.(파일은 물론 닫힌다)
  - 이제 LoadFrom은 내부적으로 Assembly의 Load 메서드를 호출하는데 이때 앞서 반환된 AssemblyName 객체를 매개변수로 전달한다.
  - 이제 CLR으 버전 바인딩 리디렉션 정책(version binding redirection policy)을 적용하고 일치하는 어셈블리를 찾기 위해서 다양한 위치를 검색하게 된다.
  - 만약 지정한 어셈블리를 찾았다면, 로드 후, 로드한 어셈블리를 나타내는 Assembly 객체를 생성하여 반환
  - 찾지 못하면 매개변수로 전달되 파일 경로에서 어셈블리를 로드. 만일 어셈블리가 이미 로드되어 있다면, 앞서 로드된 어셈블리를 나타내는 Assembly객체를 반환

<br>

- LoadFrom은 메서드의 매개변수로 URL을 전달할 수도 있다. 인터넷 위치를 넘겨주면 CLR은 파일을 다운로드하여 사용자의 다운로드 캐시에 저장한 후 그 위치로부터 파일을 로드한다.
- 그 외 어셈블리를 로딩하는 방법으로 ReflectionOnlyLoadFrom, ReflectionOnlyLoad 메서드가 존재.
- CLR은 개별 어셈블리를 언로드할 방법을 제공하지 않는다. 만일 CLR이 그러한 기능을 허용했다면 이미 언로드된 어셈블리 내부의 메서드로 반환되어 돌아오는 스레드 때문에 응용프로그램의 손상이 발생할 수 있기 때문이다. 어셈블리를 언로드하고 싶다면, 그 어셈블리를 로드하고 있는 앱도메인을 언로드하는 수밖에 없다.

### 동적으로 확장 가능한 응용프로그램을 만들기 위해서 리플렉션을 사용하기
- 메타데이터에는 여러 개의 테이블에 저장되어 있다. 어셈블리나 모듈을 생성하면 사용 중인 컴파일러가 타입 정의 테이블(type definition table), 필드 정의 테이블(field definition table), 모듈 정의 테이블(module definition table) 등의 여러 테이블을 생성하게 된다. System.Reflection 네임스페이스에 있는 여러 타입들을 이용하면, 이러한 메타데이터 테이블의 내용을 리플렉션(혹은 파싱) 하는 코드를 작성할 수 있다.
- 이러한 객체 모델 타입들을 사용하면, 타입 정의 메타데이터 테이블 내의 모든 타입을 손쉽게 살펴볼 수 있다. 특정 타입에 대하여 이 타입의 기본 타입이 무엇인지, 구현하고 있는 인터페이스는 무엇인지, 이 타입과 관련된 플래그에는 어떤 것이 있는지를 가져올 수 있다.
  - System.Reflection 네임스페이스에 포함된 또 다른 타입들을 사용하면 특정 타입의 필드, 메서드, 속성, 이벤트들 등을 이와 연관되어 있는 테이블들을 분석하여 가져올 수 있다.

### 리플렉션의 성능
- 리플렉션을 사용하면 컴파일 시의 타입 안전성을 해친다.
  - 리플렉션은 문자열을 광범위하게 사용하기 때문에 컴파일 시의 타입 안전성을 잃게 된다. 예를 들어 `Type.GetType(int)` 의 경우, 컴파일 단계에서는 문제없지만 CLR은 int 타입을 `System.Int32`로 알고 있기 때문에 null을 반환하게 된다.
- 리플렉션은 전반적으로 느리다.
  - 리플렉션을 사용하면 타입이나 멤버의 이름을 컴파일 시에 알 수 없기 때문에 런타임 시에 타입과 멤버를 구분할 수 있는 문자열을 이용하여 그 각각을 찾아내야 한다. 결국 리플렉션을 이용하게 되면 문자열 검색을 수행해야 한다. 이때 종종 대소문자를 구분하지 않고 문자열을 검색해야 하는 경우도 생기는데 이는 검색 속도를 더욱 느리게 한다.

<br>

- 리플렉션을 활용하여 메서드를 호출하려면 먼저 매개변수들을 배열로 포장해야 한다. 내부적으로는 이렇게 포장된 내용을 다시 꺼내어 스레드의 스택에 옮겨야 한다. 추가적으로 CLR은 메서드 호출 전에 개별 매개변수가 올바른 타입을 가지고 있는지 확인해야 하고, 마지막으로 호출자가 호출하려는 멤버에 접근할 수 있는 충분한 보안 권한이 있는지 확인해야 한다.

<br>

#### 타입 객체란 정확히 무엇인가
- Type 객체는 타입 참조를 나타내는 아주 가벼운 객체다. 만일 타입 자체에 대해서 좀 더 알고 싶다면 타입의 정의를 나타내는 TypeInfo 객체를 얻어 와야 한다.
  - 마이크로소프트는 타입 이름과 '어셈블리명을 정규화한 타입 이름'의 구조를 베커스 나우어 형식(Backus-Naur Form)으로 정의하고 있으며 이를 리플렉션 메서드의 문자열 매개변수로 주로 사용한다. 이러한 문법에 대한 지식은 중첩 타입(nested type), 제네릭 타입, 제네릭 메서드, 참조 매개변수, 배열 등을 리플렉션을 통해서 사용할 때 매우 유용하게 사용할 수 있다.

- 여러 프로그램 언어에서 컴파일 시에 이미 알려져 있는 타입 이름을 이용하여 Type 객체를 얻어 올 수 있는 연산자를 제공한다. C#의 경우에는 typeof 연산자
  - GetType 보다는 가능하면 typeof를 사용하는 것이 좋다. 일반적으로 typeof 쪽이 더 빠르다.
  - GetType의 경우에는 늦은 바인딩으로 획득한 타입 정보(예를 들어 업캐스팅된 레퍼런스의 진짜 타입 정보)와 이른 바인딩으로 획득한 타입 정보(컴파일 시간에 알려진 타입 정보)를 비교하는 용도로 쓰인다.

##### 타입 인스턴스 생성
- System.Activator의 CreateInstance 메서드들
- System.Activator의 CreateInstanceFrom 메서드들
- System.AppDomain의 메서드들 : AppDomain은 특정 타입의 인스턴스를 생성하기 위해서 CreateInstance, CreateInstnaceAndUnwrap, CreateInstanceFrom, CreateInstanceFromAndUnwrap의 네 가지 종류의 메서드를 제공해준다.
- System.Reflection.ConstructorInfo의 Invoke 인스턴스 메서드

<br>

위에 나열한 매커니즘들을 이용하면 배열(System.Array 계통의 타입)과 델리게이트(System.MulticastDelegate 계통의 타입)를 제외한 모든 타입을 생성할 수 있다.
- 배열을 생성하고 싶다면 Array.CreateInstance를, 델리게이트의 경우 MethodInfo.CreateDelegate를 활용.

<br>

- 제네릭 타입의 생성
```cs
static void Main(string[] args)
{
    //열려있는 제네릭 타입 객체를 가져온다.
    Type openType = typeof(Dictionary<,>);

    // <string, int> 타입 매개변수를 가지는 제네릭 타입을 얻는다.
    Type closedType = openType.MakeGenericType(typeof(string), typeof(int));

    // 닫힌 타입의 인스턴스를 생성한다.
    var o = Activator.CreateInstance(closedType);

    Console.WriteLine(o.GetType());
}
```

### 애드인을 지원하는 응용프로그램 설계
- 확장 가능한 응용프로그램을 개발하는 경우, 보통은 애드인 개발자가 자신만의 기본 타입을 선택할 수 있도록 인터페이스를 사용하는 것이 더 좋다. 
- 응용 프로그램을 개발하되 다른 개발자들이 자신만의 클래스를 만들어서 이 응용프로그램 안에 로드하고 제약 없이 수행할 수 있는 그런 응용프로그램을 개발한다고 가정한다면
  - 호스트 응용 프로그램과 애드인 컴포넌트 사이에 통신 매커니즘에 사용될 메서드를 인터페이스로 정의하고 있는 호스트 SDK 어셈블리를 작성하라. 인터페이스 메서드의 매개변수 타입이나 반환 타입은 다른 인터페이스를 사용하거나 MSCoreLib.dll 에 정의되어 있는 타입을 사용하는 것이 좋다. 만일 사용자 정의한 타입을 사용하게 되면 이 타입 또한 호스트 SDK 어셈블리에 포함시켜야 한다.
  - 애드인 개발자는 당연하게도 자신이 개발하는 애드인 타입을 자신의 애드인 어셈블리에 포함시킬 것이다. 개발된 애드인 어셈블리는 SDK 어셈블리를 참조할 것이다. 
  - 호스트 SDK 어셈블리를 호스트 응용 프로그램을 구현하고 있는 어셈블리와 분리하라. 이 애드인 어셈블리는 분명히 호스트 SDK 어셈블리를 참조할 것이고, 이 내부에 정의된 타입들을 사용하게 될 것이다.

  <br>

  - 여러 어셈블리에서 공유해서 사용해야하는 타입들은 어셈블리의 버전 문제에 특히 신경 써야 한다. 여러 어셈블리의 경계를 넘어 통신의 용도로 사용되는 타입들은 단일의 어셈블리로 분리될 수 있도록 명확한 구조를 잡는데 충분한 시간을 할애하는 것이 좋다.

### 타입 내의 멤버를 찾기 위해 리플렉션 사용하기

#### 타입 내의 멤버 검색

타입의 멤버로서 정의할 수 있는 것들로는 필드, 생성자, 메서드, 속성, 이벤트, 중첩 타입이 있다.
- FCL은 System.Reflection.MemberInfo 라는 추상 기본 클래스(abstract base class) 를 통해서 타입 멤버들의 공통적인 속성들을 캡슐화하고, 이 MemberInfo 를 상속하여 개별 타입 멤버의 고유 특성을 캡슐화하고 있다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/23-1.png" width="70%" height="70%">

#### 타입 내의 멤버 수행
...

#### 프로세스의 메모리 소비량을 줄이기 위해서 핸들 바인딩 기법 사용하기
...

</details>

## 24장. 런타임 serialization

<details>
<summary>fold/unfold</summary>

serialization 은 객체나 연결된 객체 그래프를 바이트 스트림(byte stream)으로 변환하는 과정을 뜻하며, deserialization 은 바이트 스트림을 다시 연결된 객체 그래프로 되돌리는 과정을 뜻한다.
- 객체와 바이트 스트림 간의 상호 변환 기능은 상당히 유용한 기능인데 몇 가지 활용 예를 나타내보면
- 응용프로그램의 상태(객체 그래프)를 파일이나 데이터베이스에 손쉽게 저장할 수 있고 다음 번에 응용프로그램을 수행할 때 저장해두었던 정보를 손쉽게 복원할 수 있다.
- 일련의 객체들은 시스템의 클립보드에 손쉽게 복사할 수 있고, 복사한 객체들은 자신의 응용프로그램이나 혹은 다른 응용프로그램에 붙여 넣을 수 있다. 실제로 윈도우 폼이나 WPF(Windows Presentatioin Foundation)가 이 방법을 사용한다.
- 사용자가 주요 객체들을 수정하는 동안 원본 객체를 복제해서 백업 용도로 가지고 있을 수 있다.
- 일련의 객체들을 네트워크를 통해서 손쉽게 다른 컴퓨터로 전송할 수 있다. .NET Framework의 리모팅 아키텍처에서는 객체를 값으로 마샬링할 때 serialize와 deserialize 를 사용한다. 
- 객체를 바이트 스트림으로 메모리에 serialize 하면 데이터의 암호화나 압축 등과 같은 작업을 수행할 때에도 용이하다.

### serialization/deserialization 쾌속 시작
```cs
static void Main(string[] args)
{
    var texts = new List<string> { "Jeff", "Kristin", "Alddan", "Grant" };
    var stream = SerializeToMemory(texts);

    //전부 초기화
    stream.Position = 0;
    texts = null;

    //객체를 deserialize한 후, 제대로 동작하는지 검증한다.
    texts = DeserializeFromMemory<List<string>>(stream);
    texts.ForEach(text => Console.WriteLine(text));
}

private static MemoryStream SerializeToMemory(object source)
{
    //serialize한 객체를 저장할 스트림을 생성
    var stream = new MemoryStream();

    //모든 복잡한 작업을 전임할 serialization 포맷터를 생성한다.
    var formatter = new BinaryFormatter();

    //포맷터에게 객체를 stream으로 serialize해줄 것을 요청한다.
    formatter.Serialize(stream, source);

    //호출자에게 serialize된 객체 스트림을 반환한다.
    return stream;
}

private static T DeserializeFromMemory<T>(Stream stream)
{
    //모든 복잡한 작업을 전임할 serialization 포맷터를 생성한다.
    var formatter = new BinaryFormatter();

    //포맷터에게 스트림으로부터 객체를 deserialize 해줄 것을 요청한다.
    return (T)formatter.Deserialize(stream);
}
```

- BinaryFormatter는 객체를 어떻게 serialize해야 하는지를 파악하기 위해서, 각 객체의 타입을 정확히 설명하고 있는 메타데이터를 활용한다. Serialize 메서드는 serialize 할 객체가 어떤 필드들을 가지고 있는지 확인하기 위해서 리플렉션 기법을 활용한다. 만일 개별 필드들이 또 다른 객체들을 참조하는 경우, 참조되는 필드까지도 어떻게 serialize해댜 할지를 확인할 것이다.
  - 포맷터는 객체 그래프 내의 단일 객체가 여러번에 걸쳐 스트림으로 serialize 되지 않도록 방지한다. 즉 그래프 내의 두 개의 서로 다른 객체가 동일한 객체를 참조하고 있는 경우, 포맷터를 이를 감지하고 각 객체를 단 한 번씩만 serialize하도록 한다.
  - BinaryFormatter를 활용하여 객체를 serialize하면 스트림에 serialize하려는 타입의 전체 이름과 타입을 정의하고 있는 어셈블리의 이름을 같이 저장한다.(어셈블리의 파일 이름(확장자 제외), 버전 번호, 문화권, 공개 키 정보를 모두 포함하는 어셈블리 식별자) Deserialize 를 수행할 때에는 가장 먼저 스트림 내에 기록되어 있는 어셈블리 식별자를 확인하고 현재 수행 중인 앱도메인에 해당 어셈블리를 로드한다.

### serialize 가능한 타입 정의하기

### serialization과 deserialization 제어하기

### 포맷터는 타입 인스턴스를 어떻게 serialize 하는가?

### serialize/deserialize 할 데이터 제어하기

### 스트리밍 컨텍스트

### 다른 타입으로 serialize 하고 다른 객체로 deserialize 하기

### serialization 대리자

### 객체를 deserialize 할 때 어셈블리와 타입을 오버라이딩하기

</details>

## 26장. 스레드의 기본

<details>
<summary>fold/unfold</summary>

### 윈도우는 왜 스레드를 지원하는가?
...

### 스레드의 비용
모든 스레드는 아래에 나열한 것들을 하나씩 가지고 있습니다.
- 스레드 커널 객체 : os는 시스템 내에서 생성되는 개별 스레드별로 고유의 데이터 구조체를 할당하고 초기화합니다. 이 구조체는 스레드를 나타내는 여러 속성들을 가지고 있으며 그 중에는 스레드의 컨텍스트라고 불리는 정보도 있습니다.
- 스레드 환경 블록(Thread environment block, TEB) : TEB는 유저 모드(응용 프로그램이 빠르게 접근할 수 있는 주소 공간)에 할당되고 초기화되는 메모리 블록입니다.
- 유저 모드 스택 : 지역 변수와 함수의 매개변수를 저장할 용도로 사용되며, 현재 수행 중인 함수가 반환될 때 그 다음으로 수행해야 할 위치를 저장합니다. 윈도우 os는 기본적으로 각각의 스레드에 대해서 유저모드 스택 1MB를 할당합니다.
- 커널 모드 스택 : 응용프로그램이 os의 커널 모드 함수로 매개변수를 전달해야 할 때 사용됩니다. 보안상의 이유로 유저 모드 코드에서 커널 모드로 매개변수를 전달할 때 유저 모드 스택의 내용을 커널 모드 스택으로 복사해서 넘겨줍니다. 응용프로그램은 커널 모드 스택에 접근을 못하기 때문에 커널 코드는 안전하게 동작을 수행합니다.
- DLL의 스레드 attach/detach 통지 : 윈도우 os는 프로세스 내에서 새 스레드가 생성되면 해당 프로세스의 메모리 공간에 로드된 모든 비관리 DLL들의 DllMain 함수를 DLL_THREAD_ATTACH 플래그를 매개변수로 호출합니다. 스레드가 종료될 때는 마찬가지로 DllMain 함수를 DLL_THREAD_DETACH 플래그를 매개변수로 호출합니다.

특정 시간에 윈도우 운영체제는 하나의 CPU에 하나의 스레드를 할당합니다. 스레드는 주어진 타임 슬라이스(time-slice 혹은 퀀텀(Quantum))동안만 수행됩니다. 스레드가 타임 슬라이스 만큼 수행을 완료하고 나면, 다른 스레드로 컨텍스트를 전환합니다.
<br>
컨텍스트를 전환할 때 os 는 아래의 동작을 수행합니다.
1. cpu 레지스터의 값을 현재 수행 중인 스레드의 컨텍스트 구조체에 저장합니다. 컨텍스트 구조체는 스레드 커널 객체 내부에 있습니다.
2. 여러 스레드들 중 다음 번에 수행할 스레드를 선택합니다. 만일 선택된 스레드가 다른 프로세스에 속해 있다면 (프로세스간 컨텍스트 스위치 수행) 스레드가 수행할 코드와 데이터가 접근하기 위해 가상 메모리 주소를 먼저 전환합니다.
3. 선택된 스레드의 컨텍스트 구조체 내의 값을 cpu 레지스터로 로드합니다.

컨텍스트 스위칭은 순전히 오버헤드에 해당하는 작업입니다. 하지만 이를 통해 좀 더 견고하고 사용자에게 응답성이 좋은 운영체제를 구현할 수 있습니다.
- 어떤 프로그램이 실행 중에 무한루프에 빠졌다고 해봅시다. 컨텍스트 스위칭이 없다면 해당 무한루프에서 빠져나올 방법이 없습니다. 하지만 일정시간마다 os는 컨텍스트 스위칭을 통해서 작업 관리자와 같은 새로운 스레드에게 cpu를 할당할 수 있으며 사용자는 작업 관리자를 활용해서 무한 루프에 빠진 프로그램을 종료시키고 다시 작업을 할 수 있을 것입니다.
- 추가적으로 가비지 컬렉션이 호출될 때 CLR은 모드 스레드를 일시 정지시킵니다. 그 후 힙 내의 객체를 마크하기 위해 모든 스레드의 스택을 추적해 루트 객체를 찾아야 하고, 컴팩트 작업이 완료되면 스택 내의 루트를 갱신한 후에야(메모리 위치가 바뀌므로) 비로소 스레드를 재개할 수 있습니다.
- 응용프로그램을 디버깅 할때 중단점에 다다를 경우 모든 스레드가 일시 정지됩니다. 이런 특징 탓에 스레드 개수가 많다면 디버깅 속도가 느려지게 됩니다.

### 바보짓은 이제 그만
...

### CPU 트렌드
...

### CLR 스레드와 윈도우 스레드
...

### 계산 중심의 비동기 작업을 수행하기 위해서 전용 스레드 사용하기
보통 상태가 아니라 특수한 용도를 위한 스레드가 필요한 경우가 있습니다.
- 보통 스레드 우선순위가 아닌 스레드가 필요한 경우. 스레드 풀 내의 모든 스레드는 보통 우선순위를 가지며 임의로 바꿀 수 있긴 하지만 권장되지 않습니다. 우선순위를 바꾼다 하더라도 스레드 풀 작업중에 바뀐 우선순위가 계속 유지되는 것도 아닙니다.
- 포그라운드 스레드처럼 동작하는 스레드가 필요한 경우, 이 스레드가 작업을 완료하면 응용 프로그램이 종료되거나 종료되지 않을 것을 보장하기 위해 필요합니다. 스레드 풀의 모든 스레드는 백그라운드 스레드이므로 CLR이 프로세스를 종료하려 하면, 수행 중이던 작업을 완료하지 못할 수도 있습니다.
- 계산 중심의 작업이 상당히 오랫동안 수행되어야 할 때, 스레드 풀을 이용하는 경우 추가 스레드를 생성할지 여부를 사용자가 결정할 수 없습니다.
- 스레드를 명시적으로 수행하거나 Thread의 Abort 메서드를 호출하여 스레드를 강제로 종료하는 것이 가능해야 하는 경우.

<br>
Join 메서드는 호출한 스레드 객체가 파괴되거나 종료될 때까지 이 메서드를 호출한 스레드를 중단시킵니다. 비동기적으로 갈라져나간 프로그램 흐름을 다시 합칠 수 있습니다.

### 여러 스레드를 사용하는 이유
- 응답성(클라이언트 측 gui 응용 프로그램에 대해서) : 윈도우 os는 각 프로세스별로 전용의 스레드를 할당하여 응용프로그램이 무한 루프에 빠지더라도 사용자가 다른 응용프로그램까지 사용하지 못 하는 상황을 미연에 방지하고 있습니다. 다수의 스레드를 활용하는 것은 시스템의 리소스를 낭비하고 성능에 좋지 않은 영향을 끼칠 수 있지만, 사용자에게는 응답성이 좋은 인터페이스를 제공할 수 있습니다.
- 성능(클라이언트 측, 서버 측 응용 프로그램에 대해서)

### 스레드 스케줄링과 우선순위
- 앞서 모든 스레드들은 커널 객체 내부에 컨텍스트 구조체를 포함하고 있다고 설명한 바 있는데, 이 컨텍스트 구조체에는 스레드가 마지막으로 수행되었던 CPU 레지스터의 상태 정보를 가지고 있습니다. 운영체제가 주어진 타임 슬라이스 만큼 특정 스레드를 수행하고 나면 현존하는 모든 커널 객체들 중 다른 작업이 완료되기를 기다리지 않는 스케줄 가능 스레드가 있는지 확인하게 되고, 이 중 하나를 선택해서 컨텍스트 전환을 수행합니다.
<br>

- 모든 스레드는 0(가장 낮은)에서 31(가장 높은)까지 우선순위 레벨을 할당받게 됩니다. (31의 우선순위를 가진 스레드가 있으면 해당 스레드를 가장 먼저 처리)
  - 이때 31 우선순위를 가진 스레드를 처리할 때 더 낮은 우선순위의 스레드에게는 cpu를 할당하지 않는데 이를 `기아 상태starvation` 이라고 부릅니다.

<br>

- 프로세스 우선순위 클래스의 역할을 혼돈할 수 있습니다. 윈도우 운영체제는 프로세스가 아니라 스레드를 스케쥴링의 대상으로 지정합니다. 프로세스 우선순위 클래스는 수행 중인 응용프로그램 간에 우선순위를 구성할 목적으로 만들어낸 추상화된 개념이며 다른 목적은 가지고 있지 않습니다.

### 포그라운드 스레드와 백그라운드 스레드
- CLR은 모든 스레드를 포그라운드 스레드나 백그라운드 스레드 중 하나로 간주합니다. 프로세스의 모든 포그라운드 스레드가 종료되면 CLR은 수행 중인 백그라운드 스레드들을 모두 강제로 종료시키려 합니다. 그렇게 되면 백그라운드 스레드는 아무런 예외를 발생시키지 않고 즉각 종료됩니다.
  - 따라서 메모리 버퍼의 내용을 디스크의 쓰는 것과 같이 반드시 완료해야 하는 작업은 포그라운드 스레드를 활용해야 합니다. 그렇지 않고 표 계산 프로그램에서의 셀 연산식 같이 덜 중요한 작업의 경우에는 백그라운드 스레드를 사용하는 것이 좋습니다. 이러한 작업들은 응용 프로그램이 재시작된 이후에 수행 중이던 작업을 다시 수행해도 되므로 사용자가 작업을 중단하려는 상황에서까지 작업을 끝까지 완료하려고 노력할 필요가 없습니다.
<br>
- 스레드가 살아있는 동안 포그라운드 스레드를 백그라운드 스레드로 변경하거나 그 반대로 변경하는 것은 언제든지 가능합니다. 응용 프로그램의 주 스레드와 Thread 객체를 명시적으로 생성하여 만들어진 스레드는 기본적으로 포그라운드 스레드로 동작합니다. 반면 스레드 풀 내의 스레드는 백그라운드 스레드로 동작합니다. 또한 네이티브 코드에 의해서 생성되어 관리 수행 환경으로 진입한 스레드들도 모두 백그라운드 스레드로 동작합니다.

</details>

## 27장. 계산 중심의 비동기 작업

<details>
<summary>fold/unfold</summary>

### CLR의 스레드 풀 소개
- CLR은 고유의 스레드 풀을 관리하는 코드를 가지고 있습니다. 스레드 풀은 응용 프로그램에서 활용할 수 있는 일련의 스레드의 집합이며 CLR 별로 하나씩 생성됩니다.
- CLR이 초기화되는 시점에 스레드 풀에는 어떤 스레드도 존재하지 않습니다. 내부적으로 스레드 풀은 작업 요청을 수신하기 위한 큐를 가지고 있어서 응용프로그램이 비동기 작업을 수행하려는 경우 이 큐에 작업 수행을 위한 항목을 추가하는 함수를 호출합니다. 스레드 풀은 큐에 추가된 항목을 가져와서 스레드 풀 내에 존재하는 스레드로 전달하는 역할을 수행하는데, 만일 스레드 풀에 스레드가 없다면 새로운 스레드를 생성합니다.
  - 스레드를 생성하게 되면 성능에 좋지 않은 영향을 끼칠 수 있지만, 스레드 풀 내의 스레드가 작업을 완료하게 되면 생성한 스레드를 파괴하지 않고 스레드 풀로 반납합니다. 반납된 스레드는 다른 요청이 있을 때까지 유휴Idle 상태를 유지하게 됩니다. 스레드를 파괴하지 않기 때문에 추가적으로 성능에 영향을 미치지는 않습니다.
    - 스레드 풀에 다수의 스레드가 Idle 상태로 남아 있다면 메모리를 낭비하는 상황이 됩니다. 스레드 풀은 풀 내의 스레드가 특정 시간 동안 계속 Idle 상태에 머물러 있다면, 스레드 풀은 이 같은 스레드를 깨워서 자기 자신을 종료하도록 하여 리소스를 해제합니다.
  - 스레드 풀은 응용 프로그램의 작업을 큐잉하는 속도가 스레드 풀 내의 스레드가 작업을 처리하는 속도보다 현저히 빠른 경우 추가적으로 스레드를 생성합니다.

### 단순한 계산 중심 작업의 수행
...

### 실행 컨텍스트
- 모든 스레드는 각자 실행 컨텍스트(Execution Contexts)라는 데이터 구조체를 가지고 있스빈다. 이 실행 컨텍스트에는 보안 설정(압축 스택, 스레드의 Principal 속성, 윈도우즈 아이덴티티(Windows Identity)), 호스트 설정(System.Threading.HostExecutionContextManager), 논리 호출 컨텍스트 데이터(Logical call context data, System.Runtime.Remoting.Messaging.CallContext 의 LogicalSetData/LogicalGetData)가 포함되어 있습니다.
...

### 협조적 취소와 타임아웃
- .NET Framework 은 작업 취소를 위한 표준화된 패턴을 제공하고 있는데 이를 혀조적 취소 패턴(cooperative cancellation)이라 합니다.
- CancellationToken 을 활용합니다.
  - [마이크로소프트 CancellationTokenSource](https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.cancellationtokensource?view=net-5.0)
  - [마이크로소프트 CancellationToken](https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.cancellationtoken?view=net-5.0)
- Regist로 취소될 때 호출될 델리게이트를 등록할 수 있으며, CreateLinkedToken으로 특정 토큰이 취소될 때 자동으로 취소될 연결될 토큰을 생성할 수 있습니다.

### 태스크
- 계산 중심의 비동기 작업을 수행하기 위해서 ThreadPool의 QueueUserWorkItem을 호출하는 방식은 간단한 방법이긴 하지만 많은 제약사항을 가지고 있다. 가장 큰 문제점은 작업 완료 시점과 작업 수행 결과를 얻을 수 있는 방법을 제공하지 않는다는 것입니다.
  - 이러한 제약을 극복하기 위해서 마이크로소프트는 태스크(task)라는 개념을 도입하였습니다.

<br>

- 태스크가 완료될 때까지 대기하여 그 결과를 얻을 수 있습니다.(wait, waitany, waitall 등)
  - Task.wait 메서드를 호출하게 되면 시스템은 대기하려는 태스크가 이미 수행이 시작되었는지 확인합니다. 수행이 시작되었다면 태스크가 완료될 때까지 Wait메서드를 호출한 스레드를 멈추지만, 만약 수행이 시작되기 전이라면, 태스크를 호출한 스레드를 멈추게 하지 않고 해당 스레드로 태스크를 수행한 뒤 결과값을 반환합니다. 해당 방식을 통해 리소스를 절약하는 효과를 볼 수 있습니다.

<br>

- AggregationException 은 애플리케이션을 실행하는 동안 발생하는 하나 이상의 오류를 나타냅니다.
  - AggregatioinException 타입은 예외 객체들에 대한 컬렉션을 캡슐화하기 위해서 주로 사용됩니다. (부모 스레드가 다수의 자식 스레드를 가지고 있고 특정 자식 스레드에서 예외가 던져지는 경우 사용)
  - AggregatioinException 의 Handle 메서드는 AggregatioinException 내부의 예외에 대해서 각각 callback 메서드를 호출할 수 있게 합니다. 에러 처리를 수행할 때 해당 기능을 사용합니다.
- waitall 메서드를 호출하고 다수의 태스크가 전부 완료될 때까지 기다리는 중인데 도중에 하나 이상의 태스크가 취소되었다면, operationCanceledException을 던집니다.

<br>

- CancellationTokenSource를 이용하면 태스크를 취소할 수 있습니다.
  - Task 객체의 작업이 스캐줄되기 전에 CancellationToken을 이용하여 태스크를 취소하려고 시도할 수 있는데 이 경우 태스크는 즉각 취소되고 절대 수행되지 않습니다. 하지만 태스크가 이미 수행 중이라면 작업을 수행중에 중단할 수 있도록 코드가 준비되어 있어야 합니다.

<br>

- 태스크 완료 시 다른 태스크를 자동으로 수행.
  - Wait, Result 는 해당 태스크를 수행하기 위해 스레드를 하나 더 생성해서 성능에 영향을 주는 경우가 있습니다. Wait/Result  말고도 스레드가 완료되었을 경우 이를 확인할 수 있는 방법이 있는데 특정 태스크가 수행 완료되었을 때 바로 다음 스레드를 이어서 수행하는 방법입니다.

- 아래의 코드는 어떤 스레드도 블로킹하지 않습니다.
```cs
            //태스크를 생성하고 시작합니다. 다른 태스크를 이어서 시작할 것입니다.
            var t = Task.Run(() => sum(1, 3));
            //ContinueWith 가 태스크를 반환하기는 하지만 잘 사용하지는 않습니다.
            Task cwt = t.ContinueWith(task => Console.WriteLine($"sum is {task.Result}"));
```

- 태스크 객체는 내부적으로 ContinueWith 태스크를 컬렉션에 저장하고 있습니다. 덕분에 단일 태스크 객체에 대하여 ContinueWith 메서드를 여러 번 호출할 수 있으며, 태스크가 완료되면 컬렉션 내의 모든 ContinueWith 태스크들을 스레드 풀에 큐잉하게 됩니다.
  - ContinueWith를 호출할 때 TaskContinuationOptions 플래그를 지정할 수 있습니다.
- [마이크로소프트 taskcontinuationoptions](https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=net-5.0)

<br>

- 태스크는 부모 자식 관계를 가질 수 있습니다.
  - 기본적으로 부모 태스크와 자식 태스크는 독립적이지만 TaskFactory 로 태스크를 생성하는 경우 TaskCreationOptions.AttachedToParent 플래그를 설정해 부모와 자식 태스크를 연결시킬 수 있습니다.
    - 이 경우 자식 태스크가 완료되기 전까지 부모 태스크는 완료되지 않습니다.
    - 자식 태스크가 예외를 던질 경우 부모 태스크로 전달됩니다.
    - Task.Run() 을 통해 만들어진 부모 태스크는 명시적으로 자식 태스크와 연결되지 않도록 합니다.
- [마이크로소프트 childTask](https://docs.microsoft.com/ko-kr/dotnet/standard/parallel-programming/attached-and-detached-child-tasks)

<br>

- 태스크는 내부적으로 ID(Int32), 상태를 나타내는 status(Int32), 부모 태스크 참조자, 태스크 생성시에 지정된 TaskScheduler 참조자, callback 메서드, callback메서드에 전달해야 하는 객체, ExecutionContext 참조자, ManualResetEventSlim 객체 참조자 등을 가지고 있습니다.
  - 태스크는 IDisposable 인터페이스를 구현합니다.
  - 태스크의 status를 확인해서 수명 주기를 파악할 수 있습니다. [마이크로소프트 : Task Status](https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.tasks.taskstatus?view=net-5.0)

<br>

- 태스크 팩토리는 Task 개체를 만들고 예약하도록 지원합니다.
  - [마이크로소프트 : Task.Run vs Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/)

<br>

- 태스크 스케쥴러는 작업을 스레드의 큐에 대기하는 낮은 수준의 작업을 처리하는 개체를 나타냅니다.
  - [마이크로소프트 : Task Scheduler](https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.tasks.taskscheduler?view=net-5.0#definition)

<br>

### Parallel의 정적 For, ForEach, Invoke 메서드
...

### Parallel LINQ
...

### 계산 중심 작업을 주기적으로 수행하기
- System.Threading 네임스페이스의 Timer 클래스를 이용하면 스레드 풀 내의 스레드를 이용하여 특정 메서드를 주기적으로 수행할 수 있습니다.
- Timer 객체가 가비지로 수집되면, finalizatioin 코드가 타이머를 취소하기 때문에 콜백 메서드가 더 이상 수행되지 않습니다. 타이머 클래스의 Dispose()를 호출한 경우에도 마찬가지

```cs
    public sealed class Program
    {
        public static Timer s_Timer;
        public static void Main()
        {
            Console.WriteLine("Timer 클래스를 활용해 주기적으로 델리게이트 호출");

            var timer = new Timer(DoSomething, null, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(2));

            //절대 수행되지 않는 타이머를 생성합니다. 이렇게 해서 s_Timer 변수에 객체를 할당하기도 전에 스레드 풀 내의 스레드가 DoSomething2 를 호출하는 것을 막습니다.
            s_Timer = new Timer(DoSomething2, null, Timeout.Infinite, Timeout.Infinite);

            //이 시점에서는 s_Timer의 객체가 할당되었으므로, Status 콜백 함수 내부에서 Change 메서드를 호출하기 위해서 s_Timer를 참조해도 널 오류가 발생하지 않습니다.
            s_Timer.Change(0, Timeout.Infinite);

            //프로그램이 종료되는 것을 막는다.
            Console.ReadLine();
        }

        private static void DoSomething(object state)
        {
            Console.WriteLine($"Called DoSomething : Current Time : {DateTime.Now}");
        }

        private static void DoSomething2(object state)
        {
            Console.WriteLine($"Called DoSomething2 : Current Time : {DateTime.Now}");
            Thread.Sleep(1000); //다른 작업을 수행하기 전에 1초 휴식

            //메서드를 반환하기 이전에 2초 후에 다시 수행될 수 있도록 해준다.
            s_Timer.Change(2000, Timeout.Infinite);

            //이 메서드가 반환되면 이 메서드를 수행하던 스레드는 스레드 풀로 반환됩니다.

        }
    }
```
### 스레드 풀이 스레드를 관리하는 방법
## 이 부분 오역투성이에 엉망진창입니다.

- 스레드 개수가 충분하지 않을 경우, 기아 현상이나 데드락이 발생할 수 있기 때문에 CLR은 지속적으로 수행 가능한 스레드 숫자를 증가시키고 있습니다.
- 스레드 풀이 생성할 수 있는 최대 스레드 개수는 개발자가 설정할 수 있습니다. 하지만 응용프로그램 성능에 영향을 줄 수 있으므로 가능한 기본 설정을 사용하는 것을 권고하고 있습니다.

<br>

**워커 스레드는 어떻게 동작하는가**

<br>

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/27-1.png" width="70%" height="70%">

<br>

- Top-level에 해당하는 태스크들은 항상 작업 항목을 글로벌 큐(Global Queue)에 추가합니다.
- 워커 스레드가 글로벌 큐로부터 작업 항목을 가져갈 때에는 FIFO(First-in-First-out) 순서로 가져옵니다. 이때 두 개 이상의 스레드가 글로벌 큐에서 태스크를 가져가려 할 수 있기 때문에 글로벌 큐는 스레드 동기화 락으로 보호되고 있습니다.

<br>

- 자식 태스크가 생성되는 경우, 부모 태스크를 담당하는 스레드에 대응하는 로컬 큐(local queue)가 생성되어 태스크가 삽입됩니다.
- 워커 스레드는 작업을 수행할 수 있는 상황이 되면 자신의 로컬 큐를 확인하여 태스크를 꺼내갑니다. 
  - 로컬 큐의 가장 앞쪽은(head) 해당 큐를 소유하고 있는 워커 스레드 만이 접근할 수 있도록 구성되어 있어 스레드 동기화가 필요하지 않습니다.(LIFO)
  - 자신의 로컬 큐에 태스크가 남아있지 않은 경우 워커 스레드는 글로컬 큐의 뒤쪽을 참조해 태스크를 가져갑니다.(FIFO)
  - 글로벌 큐가 비면 이번에는 다른 스레드의 로컬 큐 뒤쪽의(tail) 태스크를 가져갑니다. 이 경우 다수의 스레드가 접근하는 경우가 있으므로 스레드 락이 필요합니다.(FIFO)
  - 다른 큐에도 태스크가 남아있지 않으면 스레드는 sleep 상태로 변경됩니다. sleep 상태에서 일정 시간이 지나면 스레드는 스스로 깨어나 자기 자신을 제거하고 자원을 반환합니다.
  - 위의 방법으로 캐시 지역성을 보존하고 스레드 간 경합을 줄일 수 있습니다.
  - [Microsoft : TaskScheduler](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?redirectedfrom=MSDN&view=net-5.0#remarks)
  - [stack overflow : why-does-clr-threadpool-worker-thread-use-lifo](https://stackoverflow.com/questions/53461132/why-does-clr-threadpool-worker-thread-use-lifo-order-to-process-tasks-from-the-l)

</details>

## 28장 I/O 중심의 비동기 작업

<details>
<summary>fold/unfold</summary>

### 윈도우 운영체제가 I/O 작업을 수행하는 방법
...

### C#의 비동기 함수
- 함수에 async 키워드를 추가하여 비동기 함수로 지정할 수 있습니다. 컴파일러는 자동적으로 비동기 함수의 코드를 상태 기기(State Machine)를 구현하고 있는 타입으로 변환합니다. 
  - 이렇게 하여 메서드가 전부 수행된 이후에야 결과값을 반환하는 것이 아니라 상태 기기를 이용하여 메서드 내의 코드 중 일부만을 수행하고도 반환될 수 있도록 코드를 생성합니다.
- 메서드 정의 시 async를 포함하면, 컴파일러는 상태 기기가 최초로 시작될 때 Task 객체를 생성하도록 코드를 생성합니다. 이후에 상태 기기가 끝까지 작업을 완료하였을 때 이 Task 는 완료 상태로 변환됩니다.

<br>

비동기 함수를 사용할 때는 아래와 같은 제약이 있다.
- 응용프로그램의 Main 메서드를 비동기 함수로 변경할 수는 없습니다. 또한 생성자나 속성 접근자 메서드 혹은 이벤트 접근자 메서드는 비동기 함수가 될 수 없습니다.
  - 현재 C# 에서 Main 메서드는 비동기 함수가 될 수 있습니다 
- 비동기 함수는 out 이나 ref 매개변수를 가질 수 없습니다.
- catch, finally, unsafe 블록 내에서는 await를 사용할 수 없습니다.
- await 앞쪽에서 스레드의 소유권/재귀호출을 허용하는 락을 획득하였다가 await 뒤쪽에서 이를 해제할 수 없습니다.
  - 이러한 방식이 허용되지 않는 이유는 await 앞쪽의 코드를 수행하는 스레드와 await 뒤쪽의 코드를 수행하는 스레드가 다를 수 있기 때문입니다.
  - c#에서는 lock 내부에서 await 를 사용하면 컴파일러가 오류를 발생시킵니다.
- 쿼리 표현식 내부에서는 from 절의 첫 번째 컬렉션 나타내는 부분이나 join 절의 컬렉션을 나타내는 부분에서만 await 연산자를 사용할 수 있습니다.


#### Await
- await 연산자는 피연산자가 나타내는 비동기 작업이 완료될 때까지 바깥쪽 비동기 메서드의 평가를 일시 중단합니다. 비동기 작업이 완료되면 await 연산자는 작업 결과를 반환합니다(있는 경우). 이미 완료된 작업을 나타내는 피연산자에 await 연산자가 적용되면 바깥쪽 메서드를 일시 중단하지 않고 작업 결과를 즉시 반환합니다. await 연산자는 비동기 메서드를 평가하는 스레드를 차단하지 않습니다. await 연산자가 바깥쪽 비동기 메서드를 일시 중단하면 제어가 메서드 호출자에게 반환됩니다.

#### 참고
- [microsoft : await](https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/operators/await)


### 컴파일러가 비동기 함수를 상태 기기로 변환하는 방법
- 예제 코드는 책을 확인할 것
- 비동기 함수의 유일한 목적은 블로킹되지 말아야 하는 코드를 작성해야 할 때 좀 더 단순하게 코딩을 할 수 있도록 하기 위함입니다.

### 비동기 함수의 확장성
- 예제 코드는 책을 확인할 것

### 비동기 함수와 이벤트 핸들러
- 비동기 함수의 반환형을 void 로 정의할 수도 있는데, 이는 이벤트 핸들러를 비동기로 구현하는 경우를 단순화하기 위해서 c# 컴파일러가 허용하는 아주 특별한 경우입니다.

이벤트 핸들러 메서드는 다음과 유사한 형태를 띠는 것이 보통입니다.


`void EventHandlerCallback(Object sender, EventArgs e);`
- 그러나 이벤트 핸들러 내부에서는 I/O 작업을 수행하는 것이 보통입니다.

### 프레임워크 클래스 라이브러리(FCL) 내의 비동기 함수
- FCL을 살펴보면 많은 타입들이 I/O 작업을 비동기로 수행하는 XxxAsync 메서드를 제공하고 있습니다.
  - 예를 들어 System.IO.Stream 을 상속하는 모든 클래스들은 ReadAsync, WriteAsync, FlushAsync를 구현하고 있습니다.

### 비동기 함수와 예외 처리
- 비동기 작업에서 오류가 발생하는 경우, 예를 들어서 네트워크롤 통해 데이터를 송신한 수 응답을 기다릴 때 타임 아웃이 발생한다면 예외를 던질 것입니다.
  - 이때 디바이스 드라이버는 완료된(Completed) IRP를 CLR의 스레드 풀로 통지하고 스레드 풀 내의 스레드가 task 객체를 예외 상태로 완결시킵니다. 이제 비동기 작업을 수행하였던 상태 기기의 메서드가 다시 수행되고, await 연산자는 작업이 실패하였음을 발견하고 예외를 발생시킵니다.

- 여기서 IRP는 IO Request Packet 입니다.
- Task 객체에서는 AggregateException을 통해 예외를 던지지만 Task객체와 await 연산자를 같이 사용하는 경우에는 AggregateException 대신 첫 번째 InnerException 에 대응하는 예외가 발생하게 됩니다.
- 비동기 작업을 수행했던 상태 기기가 처리되지 앟은 예외를 만나게 된다면 Task 객체를 처리되지 않은 예외 상태로 완결 짓게 됩니다. 따라서 Task 객체가 완료되기를 기다리던 코드는 비동기 예외가 발생하였음을 알 수 있습니다. 그러나 반환 타입이 void인 비동기 함수의 경우, 처리되지 않은 예외가 발생하였음을 확인할 수 있는 방법이 없습니다. 이를 대비하기 위해서는 동기화 컨텍스트(synchronization context)를 활용하는 방법이 있습니다.

### 비동기 함수의 다른 기능
- 비동기 작업이 빨리 수행되는 경우가 있을 수 있습니다. 이런 간단한 작업들을 다른 스레드에서 수행하도록 하는 것은 비효율적일 수 있습니다.
  - 컴파일러는 이런 상황을 고려하여 await를 사용하는 경우 비동기 작업을 호출한 스레드에서 동기적으로 수행하도록 코드를 작성합니다.
  - 만약 이런 컴파일러 최적화를 원하지 않는 경우 Task.Run()을 활용하면 동작을 비동기로 수행하게 됩니다.

### 응용 프로그램과 스레딩 모델
- SynchronizationContext를 상속한 클래스의 객체는 응용프로그램 모델을 스레드 모델에 연결하는 역할을 수행합니다. 
- Task 객체에 대하여 await 연산자를 사용한 경우를 살펴보면, 호출하는 측의 스레드가 미리 SynchronizationContext 객체를 획득해두었다가, 스레드풀 내의 스레드가 작업을 완료하는 경우, 앞서 획득해둔 SynchronizationContext 객체를 사용하여 응용프로그램의 모델에 맞추어 올바른 스레드 모델이 적용될 것임을 보장해줍니다.
- 예제 코드는 책을 확인할 것

### 서버를 비동기로 구현하려면?
...

### I/O 작업의 취소
...

### 반드시 동기적으로 수행되어야만 하는 I/O 작업
...

### I/O 요청의 우선순위
...




</details>

## 29장. 단순 스레드 동기화 요소

<details>
<summary>fold/unfold</summary>

<br>

락의 문제점
- 성능을 해칩니다. 락을 획득하고 해체하는 작업은 추가적인 함수 호출이 필요하며, cpu가 여러 스레드들 중 어떤 스레드가 처음으로 락을 획득하도록 할 것인지 결정해야 하기 때문에 상당한 시간을 소요합니다.
- 스레드 동기화 락은 특정 시간에 하나의 스레드 만이 접근 가능하는 것만을 허용하기 때문에 다른 스레드는 블로킹 상태가 되는데, 스레드를 블로킹함에 따라 cpu가 더 많은 스레드를 생성하게 될 수 있습니다. 스레드 풀이 cpu가 스레드 사용성이 낮다고 판단하기 때문입니다. 이때 추가 스레드를 생성하는 동작은 오버헤드가 되며, 블로킹 되는 스레드가 다시 작업을 재개할 때 다시 스케줄링 되며, 더 많은 스레드 사이에서 문맥전환이 발생하는 것도 오버헤드가 됩니다.

### 클래스 라이브러리와 스레드 안전성
- 마이크로소프트의 FCL는 모든 정적 메서드에 대하여 스레드 안전성을 보장합니다. 하지만 인스턴스 메서드는 항상 스레드 안정성을 보장하는 것은 아닙니다. 시스템 락을 사용하는 경우 비효율적일 수 있기 때문입니다.
- 스레드 안정적으로 만든다는 것은 내부적으로 스레드 동기화 락을 반드시 사용해야 하는 것을 의미하지는 않습니다. 예를 들어 값 타입을 활용하는 경우라면 매개변수를 전달할 때 값 복사가 발생하므로 다수의 스레드가 동일 시점에 접근해도 그 값이 손상되지 않습니다.
- 고유의 클래스 라이브러리를 만들 때도 정적 메서드는 스레드 안전성을 보장하도록 인스턴스 메서드에 대해서는 반드시 그렇지 않도록 하는 것을 책에서 추천하고 있습니다.

### 단순 유저 모드 동기화 요소와 커널 모드 동기화 요소
...

### 유저 모드 동기화 요소
- int(Int32) 타입에 대해서는 동작이 원자적으로 이루어지기 때문에 아래의 코드 에서 값을 변경하는 스레드가 아닌 다른 스레드가 값을 얻어간다 하더라도 변경 중인 값을 읽지 않습니다.
```cs
 internal static class SomeType{
      public static Int32 x = 0;
 }

 //어떤 스레드가 아래의 코드를 수행 중
 SomeType.x = 0x01234567;
```

-  하지만 long 타입에 대해서는 이야기가 다릅니다. 원자적으로 수행된다고 보장할 수 없기 때문에 다른 스레드는 변경 중인 값을 획득할 가능성이 있습니다.
  - 예를 들어 어떤 값 x를 0x000000000000000 에서 0x0123456701234567 로 변경하고 있을 때 다른 스레드가 값을 읽는다면 0x0123456700000000 과 같이 변경 중인 값을 얻을 수 있습니다.
- 단순 유저 모드 동기화 요소를 이용하면 해당 값에 대해서도 원자적으로 수정이 이루어지도록 강제합니다.

<br>

단순 유저모드 동기화 요소에는 두 가지가 있습니다. 이들은 단순 데이터 타입의 변수에 대해서 지정된 시간에 원자적으로 쓰고 읽을 수 있게 합니다.
- Volatile 동기화 요소
- Interlocked 동기화 요소

**Volatile**

컴파일러가 지원하는 최적화는 사용자 입장에서 도움을 주기도 하지만 멀티스레딩을 이용하는 환경에서 컴파일러 최적화는 왜곡된 동작을 유발할 가능성이 있습니다.

```cs
internal static class StrnageBehavior
{
    private static bool s_StopWorker = false;

    public static void Main()
    {
        var worker = new Thread(Worker);
        worker.Start();
        Thread.Sleep(5000);
        s_StopWorker = true;
        Console.WriteLine("Wait For WorkerThread");
        worker.Join();
    }

    private static void Worker(Object o)
    {
        int x = 0;
        while (!s_StopWorker) x++;
        Console.WriteLine("worker Stop");
    }
}
```

위의 코드에서 컴파일러는 Worker 메서드를 수행하는 새로운 스레드를 생성할 때 최적화를 수행합니다. 이때 s_StopWorker 는 스레드 내에서 수정되는 일이 없으니 Worker 내부의 while문을 최적화하게 됩니다. 이 말인즉, Main 스레드에서는 s_StopWorker가 변경될 수 있는 값임에도 불구하고 Worker를 수행하는 스레드에서는 s_StopWorker를 불변값으로 인식해 while문을 최적화하는 것입니다. 이 결과로 코드 상의 while문을 벗어날 수 없게 됩니다.
- 릴리즈 빌드시 문제가 발생합니다.

또한 컴파일러 최적화는 경우에 따라 메서드 내부의 명령 실행 순서를 임의로 변경하기도 합니다.

```cs
internal sealed class ThreadsSharingData
{
    private int m_Flag = 0;
    private int m_Value = 0;

    //1번 스레드가 수행합니다.
    public void Thread1()
    {
        //참고 : 아래 코드는 실행 순서가 뒤집혀서 수행될 수 있습니다.
        m_Value = 5;
        m_Flag = 1;
    }

    //2번 스레드가 수행합니다.
    public void Thread2()
    {
        //참고 : m_Value 가 m_Flag 이전에 조회될 수 있습니다. m_Flag는 1이면서 m_Value 는 0 값이 출력될 수 있습니다.
        if(m_Flag == 1)
        {
            Console.WriteLine(m_Value);
        }
    }
}
```

<br>

- System.Threading.Volatile 네임스페이스의 Volatile 정적 메서드는 아래의 기능을 제공합니다.
  - Volatile.Write : 이 메서드를 호출한 위치에서 그 값이 반드시 쓰여질 것임을 보장합니다. 또한 프로그램 코드 순서상 이 코드를 호출한 위치보다 앞쪽에서 수행된 로드(load)/스토어(store) 과정은 반드시 이 코드보다 앞서 수행될 것임을 보장합니다.
  - Volatile.Read : 이 메서드를 호출한 위치에서 그 값이 읽혀질 것임을 보장합니다. 또한 프로그램 코드의 순서상 이 코드 이후에 위치한 로드(load)/스토어(store) 과정은 반드시 이 메서드가 수행된 이후에 수행될 것임을 보장합니다.

 <br>

 위의 코드를 아래처럼 변경할 수 있습니다.
 ```cs
 internal sealed class ThreadsSharingData
 {
     private int m_Flag = 0;
     private int m_Value = 0;
 
     //1번 스레드가 수행합니다.
     public void Thread1()
     {
         //참고 : m_Flag 값이 1로 바뀌기 이전에 m_Value 값이 먼저 5로 변경될 것입니다. 순서가 바뀔 염려가 없습니다. 하지만 Volatile.Write 이전에 다수의 명령이 있다면 해당 명령들의 실행 순서까지 보장하진 못합니다.
         m_Value = 5;
         Volatile.Write(ref m_Flag, 1);
     }
 
     //2번 스레드가 수행합니다.
     public void Thread2()
     {
         //참고 : m_Flag 값을 먼저 가져온 다음 m_Value 값을 가져옵니다.
         if(Volatile.Read(ref m_Flag) == 1)
         {
             Console.WriteLine(m_Value);
         }
     }
 }
```


- c# 이 지원하는 volatile 키워드를 필드에 적용할 수도 있습니다.
  - 기본 타입 및 Enum 타입에 대해서 지원하며 해당 필드에 접근하는 코드를 컴파일 할때, Volatile.Read, Volatile.Write 메서드를 사용하게 해줍니다.
  - 또한 이 키워드를 사용하면 C# 컴파일러와 JIT 컴파일러에게 이 필드의 값을 CPU 레지스터에 캐싱하지 않도록 하며, 항상 메모리로부터 값을 읽고 쓰도록 합니다.
  - 하지만 volatile 필드의 경우 최적화 대상에서 제외되는 만큼 메모리를 차지하는 크기도 커질 뿐더러 동작 속도도 느려집니다.
  - C# 에서는 volatile 필드에 대한 참조 값을 전달하지 못합니다 
```cs
internal sealed class ThreadsSharingData
{
    private volatile int m_Flag = 0;
    private int m_Value = 0;

    //1번 스레드가 수행합니다.
    public void Thread1()
    {
        //참고 : m_Flag 값이 1로 바뀌기 이전에 m_Value 값이 먼저 5로 변경될 것입니다.
        m_Value = 5;
        m_Flag = 1;
    }

    //2번 스레드가 수행합니다.
    public void Thread2()
    {
        //참고 : m_Flag 값을 먼저 가져온 다음 m_Value 값을 가져옵니다.
        if (m_Flag == 1)
        {
            Console.WriteLine(m_Value);
        }
    }
}
```

<br>


**Interlocked**

- Interlocked 클래스의 메서드들을 이용하면 원자적으로 값을 읽고 쓸 수 있을 뿐 아니라, 완벽히 메모리 펜스(memory fence)기능을 제공한다. 메모리 펜스 기능이란 Interlocked 메서드를 호출하기 이전에 수행된 쓰기 작업은 반드시 Interlocked 메서드 호출 이전에 호출될 것임을 보장하고, Interlocked 이후에 호출한 읽기 작업은 반드시 Interlocked 메서드 호출 이후에 수행될 것임을 보장하는 것을 말합니다.
  - Interlocked 메서드들의 경우, 상대적으로 속도도 빠른 편이고 다용도로 활용할 수 있습니다. 

```cs
public static class Interlocked
{
    //return(++location)
    public static int Increment(ref int location);

    //return (--location)
    public static int Decrement(ref int location);

    //return (location += value)
    public static int Add(ref int location, int value);

    //int old = location; location = value; return old;
    public static int Exchange(ref int location, int value);

    //int old = location;
    //if (location == comparand) location = value;
    //return old;
    public static int CompareExchange(ref int location, int value, int comparand);
}
```

<br>


**간단한 스핀락 구현하기**

- System.Threading 에도 spinlock 구조체가 존재합니다.
- 간단한 구현방식의 가장 큰 문제는 락을 소유하기 위한 경쟁 상태가 발생한 경우에, 스레드들이 계속해서 로프를 헛돌 수 있다는 것입니다. 이 경우 cpu 시간을 허비하게 되므로 스핀락 방식은 짧고 금방 벗어나는 구간에 대해서 사용하는 것이 좋습니다.
  - 단일 cpu 구조에서는 스핀락을 잘 사용하지 않습니다. 어떤 스레드가 락을 소유하고 다른 스레드가 루프를 돌고 있을 때 락을 빠르게 해제할 수 없기 때문입니다. 

```cs
//Interlocked 를 활용하여 간단한 스레드 동기화 락을 구현합니다.
internal struct SimpleSpinLock
{
    private int m_ResourceInUse; //0 기본값, 1 = true

    public void Enter()
    {
        while (true)
        {
            //리소스가 사용 중인 상태가 아니라면 사용 중인 상태로 변경한 후 바로 반환된다.
            if (Interlocked.Exchange(ref m_ResourceInUse, 1) == 0) return;
            //여기서 락을 얻지 못한 스레드는 블로킹
        }
    }

    public void Leave()
    {
        Volatile.Write(ref m_ResourceInUse, 0);
    }
}
```
아래처럼 사용합니다.
```cs
public sealed class SomeResource
{
    private SimpleSpinLock m_SpinLock = default;

    public void AccessResource()
    {
        m_SpinLock.Enter();
        //특정 시점에 단 하나의 스레드만이 이곳에 진입하여 리소스에 접근할 수 있습니다.
        m_SpinLock.Leave();
    }
}
```

**타입에 상관없이 Interlocked 요소를 사용하기 위한 패턴**

- 데이터 베이스 레코드를 수정할 때 흔히 사용되는 낙관적 동시성(Optimistic concurrency) 패턴
```cs
public static int Maximum(ref int target, int value)
{
    int current = target, start, desired;

    //루프 내에서는 target의 값을 변경하는 경우를 제외하고는 이 값에 접근해서는 안 된다.
    //왜냐하면 다른 스레드가 이 값을 변경할 수도 있기 때문이다.
    do
    {
        start = current;
        desired = Math.Max(start, value);

        //수행 중이던 스레드가 여기서 선점 당할 수 있다.

        current = Interlocked.CompareExchange(ref target, desired, start);

        //이번 순회 과정 중에 targe 값이 외부에서 변경되었다면 루프를 다시 돈다.
    } while (start != current);
    return desired;
}
```
- 위의 메서드가 한창 수행 중에 다른 스레드가 target의 값을 변경할 수도 있다. 그때 start와 현재의 target 값이 동일하지 않기 때문에 이때 desired 값은 유효하지 않은 값입니다. 즉 다른 스레드가 target 값을 변경하지 않았을 때 연산된 desired 값을 반환해야하며 이를 위해 Interlocked.compareExchange를 사용합니다.

- Morph 패턴
```cs
public delegate int Morpher<TResult, TArgument>(int start, TArgument argument, out TResult result);
public static TResult Morph<TResult, TArgument>(ref int target, TArgument arguemnt, Morpher<TResult, TArgument> morpher)
{
    TResult result;
    int current = target, start, desired;
    do
    {
        start = current;
        desired = morpher(start, arguemnt, out result);
        current = Interlocked.CompareExchange(ref target, desired, start);
    } while (start != current);
    return result;
}
```

### 커널 모드 등기화 요소
- 커널 모드 동기화 요소는 유저 모드 동기화 요소에 비해서 상당히 느립니다. 커널 모드 동기화 요소들이 운영체제에게 스레드 간의 동기화를 요청하는 것이기 때문입니다.
  - 또한 각각의 메서드들은 커널 객체를 이용하게 되고 이로 인해 스레드가 관리 코드에서 네이티브 사용자 코드를 거쳐 네이티브 커널 모드 코드로까지 전환되었다가 다시 역순으로의 전환을 반복할 수 밖에 없기 때문이기도 합니다.
  - 위의 전환 과정은 상당한 cpu 시간을 소비하기 때문에, 자주 발생할 경우 응용프로그램의 전체적인 성능에 나쁜 영향을 미치게 됩니다.

<br>

- 하지만 커널 모드 동기화 요소들이 단순 요저 모드 동기화 요소에 비해서 다음과 같은 경우에 이점을 제공합니다.
  - 리소스에 대한 경쟁 상태를 확인할 수 있어서, 운영체제에게 관련 스레드가 더 이상 CPU 시간으로 허비하지 않도록 하여, 프로세서 자원을 낭비하지 않도록 합니다.
  - 네이티브 스레드와 관리 스레드 사이에도 동기화를 수행할 수 있습니다.
  - 동일 컴퓨터 내의 서로 다른 프로세싱에서 수행 중 스레드 간에도 동기화를 수행할 수 있습니다.
  - 커널 모드 동기화 요소는 보안 체계가 적용되어 있어서, 인증되지 않은 계정이 이에 접근하는 것을 막을 수 있습니다.
  - 일련의 커널 모드 동기화 요소를 묶어서 전체가 가용 상태가 되거나 그 중 하나만 가용 상태가 될 때까지 스레드를 블로킹할 수 있습니다.
  - 타임 아웃 시간을 지정하여 스레드를 블로킹 할 수 있습니다. 지정된 시간 이내에 스레드가 리소스에 접근할 수 없는 경우,블로킹된 스레드의 수행을 재개하여 다른 작업을 수행하도록 할 수도 있습니다.

<br>

두 개의 주요 커널 모드 동기화 요소는 이벤트(event)와 세마포어(semaphore) 입니다. 뮤텍스(mutex)와 같은 다른 커널 모드 동기화 요소는 이 두 가지 주요 요소를 근간으로 만들어진 것입니다.
- System.Threading 내부에는 WaitHandle 이라는 추상 기본 클래스가 포함되어 있습니다. 해당 클래스는 윈도우 커널 오브젝트 핸들을 나타내기 위한 목적으로 만들어졌으며, FCL 안에는 WaitHandle을 상속한 클래스가 여러 개 존재합니다.
- 커널 모드 동기화 요소를 이용하는 모든 메서드들은 완벽히 메모리 펜스(memory fence) 기능을 제공합니다.

<br>

WaitHandle 이 가지는 메서드들
- WaitOne 는 커널 객체가 시그널 상태가 될 때까지 이 메서드를 호출한 스레드를 대기시키기 위해서 사용됩니다. 내부적으로 이 메서드는 Win32의 WaitForSingleObjectEx 함수를 호출합니다. 커널 객체가 시그널 상태가 된 경우 true를 타임아웃이 발생한 경우 false를 반환힙니다.
- WaitAll 메서드는 WaitHandle[] 배열 내에 포함되어 있는 모든 커널 객체들이 시그널 상태가 될 때까지 이 메서드를 호출한 스레드를 대기시키기 위해서 사용됩니다. 전부 시그널 상태가 되면 true를 타임아웃이 발생하면 false를 반환합니다.
- WaitAny 메서드는 WaitHandle[] 배열 내에 객체 중 하나라도 시그널 상태가 되면 true를 반환합니다.
- WaitAll과 WaitAny 메서드에 전달되는 배열 내의 커널 객체의 수는 64개를 넘어서는 안되며 만약에 초과할 경우 Sytem.NotSupportedException 이 발생합니다.
- 커널 객체의 핸들을 닫기 위해서 WaitHandle의 Dispose 메서드를 호출할 수 있습니다. 이 메서드 내부에서는 다른 어떤 스레드도 동일 커널 객체를 사용하고 있지 않음을 확인하는 과정이 포함되기 때문에 직접 호출하는 것은 좋지 않습니다. 가비지 컬렉터가 자동으로 커널 객체를 삭제해주기도 하니 내버려 두는 것지 좋습니다.

```cs
public sealed class Program
{
    public static void Main()
    {
        bool createdNew;

        using (new Semaphore(0, 1, "SomeUniqueStringIdentifyingMyApp", out createdNew))
        {
            if (createdNew)
            {
                //이 스레드가 주어진 이름의 커널 객체를 생성하였으므로 이제 이 응용프로그램의 다른 인스턴스는 수행될 수 없습니다. 
                //응용프로그램의 나머지 코드를 여기서 수행합니다.
            }
            else
            {
                //이 스레드는 이미 생성딘 동일 이름의 커널 객체을 열었습니다.
                //즉 응용 프로그램의 다른 인스턴스가 이미 수행 중이라는 의미이므로,
                //두 번째 수행된 응용프로그램의 인스턴스에서는 작업을 수행하지 않고 Main 메서드를 종료합니다.
            }
        }
    }
}
```
- 위의 예시에서 Semaphore를 사용하였지만 EventWaitHandle이나 Mutex를 사용할 수도 있습니다.
- 동일 응용 프로그램의 두 개의 인스턴스가 동시에 수행되고 있을 때, 두 개의 프로세스는 각자 고유의 스레드를 가지고 있을 것이며, 동일한 문자열을 이용하여 커널 객체 생성을 시도할 것입니다.
- 윈도우 커널은 이 중 하나의 스레드만이 지정된 이름의 커널 객체를 생성하도록 하고, createdNew 변수로 true 값을 돌려줍니다.
  - 두 번째 프로세스의 스레드가 동일 이름으로 커널 객체를 생성하려 하면 윈도우는 생성하려는 커널 객체가 이미 존재하고 있으므로 동일 이름의 커널 객체를 신규로 생성하지 못하도록 막고, 대신 앞서 다른 프로세스의 스레드가 생성하였던 동일 커널 객체를 사용할 수 있도록 해줍니다.
  - 이 방식으로 서로 다른 프로세스에 존재하는 스레드들이 단일의 커널 객체를 통해 상호 통신을 수행할 수 있습니다. 두 번째 프로세스는 객체 생성 시에 createdNew 값으로 false을 돌려받게 됩니다.

  <br>

  **이벤트**
  - 이벤트는 커널에서 관리되는 단순한 bool 변수입니다. 이벤트가 false이면 스레드가 블로킹되고 true 일때에는 블로킹이 해제됩니다. 
  - 이벤트는 크게 두 가지 종류가 있습니다.
    - 자동-리셋 이벤트는 여러 스레드가 자동-리셋 이벤트에 의해서 블로킹 되어있는 상태에서, 그 값이 true로 변경되면, 단 하나의 스레드만 블록킹을 해제합니다. 이후 커널이 자동적으로 이 이벤트를 리셋하여 false로 변경합니다.
    - 수동-리셋 이벤트는 동일 상황에서 그 값이 true로 변경되면 대기 중인 모든 스레드의 블록킹을 해제하며, 자동으로 리셋되지 않으므로 false로 변경되지 않습니다. 즉 코드를 통해서 수동으로 이벤트의 값을 false로 변경해줘야 합니다.


 <br>

 아래는 이벤트와 관련된 클래스들입니다.
```cs
public class EventWaitHandle : WaitHandle
{
    public bool Set();  //bool 값을 true로 설정합니다. 항상 true를 반환합니다.
    public bool Reset(); // bool 값을 false로 설정합니다. 항상 false를 반환합니다.
}

public sealed class AutoResetEvent : EventWaitHandle
{
    public AutoResetEvent(bool initialState);
}

public sealed class ManualResetEvent : EventWaitHandle
{
    public ManualResetEvent(bool initialState);
}
```

자동-리셋 이벤트를 사용하면 앞서 살펴본 SimpleSpinLock과 유사한 기능을 수행하는 스레드 동기화 락을 손쉽게 만들 수 있습니다.

```cs
internal sealed class SimpleWaitLock : IDisposable
{
    private readonly AutoResetEvent m_Available;

    public SimpleWaitLock()
    {
        m_Available = new AutoResetEvent(true); // true로 초기화
    }

    //리소스가 사용 가능할 때까지 커널에서 블로킹 수행
    public void Enter() => m_Available.WaitOne();

    //다른 스레드가 리소스를 사용할 수 있도록 해줌
    public void Leave() => m_Available.Set();

    public void Dispose() => m_Available.Dispose();
}
```

- SimpleWaitLock은 SimpleSpinLock 과 동일한 방법으로 사용할 수 있으며, 외부에서 보기에는 완전히 동일하게 동작하는 것처럼 보입니다. 하지만 이 두 가지 클래스를 성능적이 측면에서 비교해보면 근본적인 차이가 있습니다.
  - 여러 스레드들이 락을 획득하기 위해서 경쟁 상태에 있는 경우가 아니라면, SimpleWaitLock이 SimpleSpinLock에 비해 훨씬 느립니다. 왜냐하면 SimpleWaitLock의 Enter와 Leave 메서드를 호출할 때마다, 스레드는 관리 코드와 커널 코드 사이를 오가야 하기 때문입니다. (단점)
  - 하지만 스레드들이 경쟁 상태에 있는 경우라면, 락을 대기해야 하는 스레드들을 커널이 알아서 블로킹시켜주기 때문에, 스피닝으로 인한 CPU 소비가 발생하지 않습니다.(장점)
  - 더불어서 AutoResetEvent를 생성할 때는 Dispose 메서드를 호출할 때에는 관리 코드로부터 커널 코드로의 전환이 일어나며, 이로 인해 성능에 좋지 않은 영향을 미칠 수 있습니다.

```cs
public static void Main()
{
    int x = 0;
    const int iterations = 5000000;    //오백만 번

    var stopWatch = Stopwatch.StartNew();
    for(int i = 0; i < iterations; i++)
    {
        x++;
    }

    Console.WriteLine($"Incrementing {nameof(x)} : {x} : {stopWatch.ElapsedMilliseconds}");

    //아무런 작업도 하지 않는 메서드를 추가한 후에 오백만번 반복하는데 소요되는 시간을 측정
    stopWatch.Restart();
    for(int i = 0; i< iterations; i++)
    {
        M();
        x++;
        M();
    }
    Console.WriteLine($"Incrementing {nameof(x)} : {x} in M : {stopWatch.ElapsedMilliseconds}");

    //경쟁 상태가 발생하지 않는 상황에서 SimpleSpinLock을 상요하는 코드를 추가한 후에 오백만 번 반복하는 데 소요되는 시간을 측정
    var spinLock = new SpinLock(false);
    stopWatch.Restart();
    for (int i = 0; i < iterations; i++)
    {
        bool taken = false;
        spinLock.Enter(ref taken);
        x++;
        spinLock.Exit();
    }
    Console.WriteLine($"Incrementing {nameof(x)} : {x} in SpinLock : {stopWatch.ElapsedMilliseconds}");

    //경쟁 상태가 발생하지 않는 상황에서 SimpleWaitLock을 사용하는 코드를 추가한 후에 오백만 번 반복하는 데 소요되는 시간을 측정
    using (var waitLock = new SimpleWaitLock())
    {
        stopWatch.Restart();
        for (int i = 0; i < iterations; i++)
        {
            waitLock.Enter();
            x++;
            waitLock.Leave();
        }
        Console.WriteLine($"Incrementing {nameof(x)} : {x} in SimpleWaitLock : {stopWatch.ElapsedMilliseconds}");
    }
}

//이 메서드는 아무런 작업도 수행하지 않습니다.
[MethodImpl(MethodImplOptions.NoInlining)]
private static void M() { }
```

- 실행 결과
```console
Incrementing x : 5000000 : 3
Incrementing x : 10000000 in M : 25
Incrementing x : 15000000 in SpinLock : 136
Incrementing x : 20000000 in SimpleWaitLock : 11084
```

- 결과에서 알 수 있듯 스레드 동기화는 가능한 피하는 것이 좋고 반드시 동기화가 필요한 경우에는 유저모드 동기화 요소를 사용하되 커널 모드 동기화 요소는 가능한 사용을 피하는 것이 좋다.

<br>

**세마포어**

세마포어는 커널에서 관리되는 단순한 int 변수입니다. 세마포어의 값이 0이면 스레드들은 블로킹되고 0보다 크면 블로킹이 해제됩니다. 세마포어를 대기하던 스레드가 블록킹이 해제되면, 세마포어의 값은 1만큼 늘어납니다. 세마포어는 사용자가 설정할 수 있는 최댓값을 가질 수 있어서 현재 세마포어 카운트 값은 이 값을 초과할 수 없습니다.

```cs
public sealed class Semaphore : WaitHandle
{
    public Semaphore(int initialCount, int maximumCount);
    public int Release(); //Release(1)을 호출하고 이전 세마포어 값을 반환합니다.
    public int Release(int releaseCount); //이전 세마포어 값을 반환합니다.
}
```

<br><br>
- 세 가지 커널 모드 동기화 요소의 동작 방식을 정리해보면
  - 여러 스레드들이 자동 리셋 이벤트에 의해서 블로킹되어 있는 상태에서 이벤트가 설정 상태(시그널 상태) 가 되면 하나의 스레드 만이 블록킹이 해제됩니다.
  - 여러 스레드들이 수동 리셋 이벤트에 의해서 블로킹되어 있는 상태에서 이벤트가 설정 상태(시그널 상태) 가 되면 모든 스레드가 블로킹이 해제됩니다.
  - 여러 스레드들이 세마포어에 의해서 블로킹되어 있는 상태에서는 releaseCount에서 지정한 개수만큼의 스레드가 블로킹이 해제됩니다.

- 자동 리셋 이벤트는 최댓값을 1로 설정한 세마포어와 유사하게 동작합니다. 이벤트와 세마포어의 차이점이라면 자동 리셋 이벤트의 경우 연속적을 Set 메서드를 호출할 수 있고, 그 때마다 하나씩의 스레드가 블로킹 상태를 벗어나는 반면, 세마포어의 Release를 연속적으로 호출하였을 때 내부 카운트 값을 증가시켜서, 여러 스레드들이 동시에 블로킹 상태를 벋어날 수 있습니다. 하지만 세마포어의 release를 너무 많이 호출해서 설정된 최댓값을 넘어서게 된다면 SemaphoreFullException을 호출합니다.

<br>

- 아래는 세마포어를 이용하여 SimpleWaitLock을 구현한 코드입니다.
```cs
internal sealed class SimpleWaitLock : IDisposable
{
    private readonly Semaphore m_Available;

    public SimpleWaitLock(int maxConcurrent)
    {
        m_Available = new Semaphore(maxConcurrent, maxConcurrent);
    }

    //리소스가 사용 가능할 때까지 커널에서 블로킹 수행
    public void Enter() => m_Available.WaitOne();

    //다른 스레드가 리소스를 사용할 수 있도록 해줌
    public void Leave() => m_Available.Release(1);

    public void Dispose() => m_Available.Dispose();
}
```

<br><br>

**뮤텍스**
뮤텍스는 상호 배제 락을 표현하기 위한 요소입니다. 이는 AutoResetEvent나 최대 카운트가 1인 세마포어와 유사해서 블록킹된 스레드가 여러 개일 때, 이 중 하나의 스레드만이 수행될 수 있도록 해줍니다. Mutex클래스는 다음과 같습니다.

```cs
public sealed class Mutex : WaitHandle
{
    public Mutex();
    public void ReleaseMutex();
}
```

- 뮤텍스는 객체는 자신을 소유하고 있는 스레드의 ID 값을 기록해두었다가 특정 스레드가 ReleaseMutex를 호출하였을 때, 이 스레드의 ID값과 뮤텍스가 기록해두었던 스레드의 ID 값이 동일한지를 비교합니다. 만약 일치하지 않는다면 뮤텍스 객체의 상태는 변경되지 않고, ApplicaitonException을 발생시킵니다.
  - 또한 Mutex를 소유하고 있던 스레드가 어떤 이유에서 종료되면 AbandonedMutexException을 발생시켜, 동일 뮤텍스를 대기하던 다른 스레드를 깨웁니다. 이 예외를 처리하지 않는다면 프로세스는 종료됩니다.
- 뮤텍스 객체는 재귀 카운트(recursion count)를 가지고 있어서 뮤텍스를 이미 소유한 스레드가 뮤텍스를 다시 소유하려고 하면 이 값을 증가시키며 스레드를 블로킹시키는 대신 계속 수행될 수 있도록 해줍니다. ReleaseMutex를 호출하면 재귀 카운트 값은 줄어들고, 재귀 카운트가 0이 되어야만 다른 스레드가 뮤텍스를 소유할 수 있게 됩니다.
- 뮤텍스 객체는 스레드 ID와 재귀 카운트 등 추가적인 메모리 공간을 요구하므로, 성능상의 오버헤드가 있으며, 반드시 필요한 경우가 아니라면 뮤텍스를 사용을 피하는 편입니다.

<br>

- 보통 뮤텍스와 같이 재귀가 지원되는 락이 필요한 경우는 특정 메서드가 락을 소유한 채로 다른 메서드를 호출하고, 호출된 메서드 내부에서도 락을 필요로 하는 경우입니다.

```cs
internal class SomeClass : IDisposable
{
    private readonly Mutex m_Mutex = new Mutex();

    public void Method1()
    {
        m_Mutex.WaitOne();
        //여기서 작업을 수행합니다.
        Method2();  //내부에서 다시 락을 요구합니다.
        m_Mutex.ReleaseMutex();
    }

    public void Method2()
    {
        m_Mutex.WaitOne();
        //여기서 작업을 수행합니다.
        m_Mutex.ReleaseMutex();
    }

    public void Dispose() => m_Mutex.Dispose();
}
```

- 뮤텍스 객체는 재귀 방식을 지원하기 때문에, 동일 스레드가 이 뮤텍스 객체를 두 번에 걸쳐 소유하고 해제할 수 있습니다. Mutex 대신 AutoResetEvent를 사용한다면  Method2 내부에서 블로킹되어버릴 겁니다.
  - 책에서는 AutoResetEvent를 재귀 방식으로 활용할 수 있도록 작성한 코드 예시가 있습니다. 이 경우 뮤텍스와 달리 소유권을 추적하기 위한 코드들이 관리 코드에서 수행되기 때문에 동작은 동일하지만 속도는 더 빠릅니다.
</details>

## 30장. 복합 스레드 동기화 요소

<details>
<summary>fold/unfold</summary>

- 유저 모드 스레드 동기화 요소와 커널 모드 스레드 동기화 요소를 결합하여 `복합 스레드 동기화 요소`를 만들 수 있습니다.
  - 복합 스레드 동기화 요소는 스레드 들이 경쟁 상태가 아닐 때에는 유저 모드 동기화 요소의 성능상의 장점을 취하며, 동시에 다수의 스레드가 경쟁 상태일 경우에는 커널 모드 스레드 동기화 요소를 이용하여 CPU 시간을 소비하는 스피닝(spinning) 이 발생하지 않도록 합니다.

### 간단한 복합 스레드 동기화 락

- 복합 스레드 동기화 락의 예제 코드
  - 단순 유저 모드 동기화 요소인 Interlocked와 단순 커널 동기화 요소인 AutoResetEvent를 동시에 사용해서 최대한의 성능을 얻어내고 있습니다.
  - 처음 스레드가 락을 획득할 때에는 Interlocked 를 통해 빠르게 획득할 수 있도록 합니다.
  - 두 번째 스레드가 블로킹될 때에는 커널 동기화 요소인 AutoResetEvent의 WaitOne를 호출합니다. 이때 WaitOne은 커널에 접근하기 때문에 느리지만, 어차피 해당 스레드는 블로킹될 스레드이기 때문에 완전히 멈추는데 시간이 걸리더라도 성능적 손해는 크지 않을 것입니다.
  - 이 방식은 장점이 있어서 스레드가 완전히 블로킹되면 CPU 시간을 낭비하는 스피닝을 피할 수 있습니다.
  - 스레드가 락을 반환할 때에도 마찬가지로 먼저 Interlocked를 활용합니다. m_Waiters 를 확인해 스레드가 경쟁상태에 있는지 먼저 확인합니다.
  - 만약 대기하는 스레드가 없다면 별다른 동작 없이 빠져나옵니다. 이때 수행 성능은 꽤 빠릅니다.
  - 대기하는 스레드가 있다면 AutoResetEvent 의 set을 호출합니다. 이 경우 커널에 접근하기 때문에 속도는 느리지만, 다행히 스레드가 경쟁상태에 있을 때에만 커널 전환을 수행하게 됩니다.

```cs
internal sealed class SimpleHybridLock : IDisposable
{
    //단순 유저 동기화 요소(Interlocked) 에서 사용하기 위한 값
    private int m_Waiters = 0;

    //커널 모드 동기화 요소인 AutoResetEvent 선언
    private readonly AutoResetEvent m_WaiterLock = new AutoResetEvent(false);

    public void Enter()
    {
        //이 스레드는 락을 필요로 합니다.
        if(Interlocked.Increment(ref m_Waiters) == 1)
        {
            return;
        }

        //다른 스레드가 락을 소유하고 있는 경우(경쟁 상태). 이 스레드를 대기시킵니다.
        m_WaiterLock.WaitOne(); //성능에 나쁜 영향을 미친다.
        //WaitOne 메서드가 반환되면, 이 스레드가 락을 소유합니다.
    }

    public void Leave()
    {
        //이 스레드는 락을 해제합니다.
        if(Interlocked.Decrement(ref m_Waiters) == 0)
        {
            return;
        }

        //다른 스레드가 대기하고 있으므로, 그 중 하나를 깨운다.
        m_WaiterLock.Set(); //성능상 나쁜 영향을 미친다.
    }

    public void Dispose() => m_WaiterLock.Dispose();
}
```


### 스피닝, 스레드 소유권, 중복 소유
- 스레드가 커널 모드로 전환하게 되면 아주 짧은 시간 동안이라 락을 소유하는 경우라도 성능에 상당히 좋지 않은 영향을 미치게 됩니다. 따라서 스레드가 락을 대기하기 위해서 커널 모드로 전환하기에 앞서 유저 모드에서 스피닝을 수행하면 커널 모드로 전환하지 않을 수 있어 응용프로그램의 성능을 향상시킬 수 있습니다.
- 이와 별개로 일부 락을 소유한 스레드만이 락을 해제할 수 있는 경우가 있습니다. 이러한 락을 사용하면 락을 소유하고 있는 스레드가 중복적으로 락을 다시 획득하는 것이 가능합니다.
  - Mutex가 바로 이러한 특징을 가진 락의 전형적인 예라 볼 수 있습니다. 그러나 뮤텍스를 사용하지 않더라도 약간의 코드를 추가하면 스피닝과 더불어 스레드의 소유권 및 중복 소유가 가능한 복합 스레드 동기화 요소를 만들어낼 수 있습니다.

```cs
internal sealed class AnotherHybridLock : IDisposable
{
    private int m_Waiters = 0;
    private AutoResetEvent m_WaiterLock = new AutoResetEvent(false);

    //이 필드는 성능 향상을 위해서 스피닝 횟수를 제어합니다.
    private int m_SpinCount = 4000;
    //이 필드는 어떤 스레드가 락을 소유하고 있으며, 몇 회에 걸쳐 락을 중복적으로 소유하려 했는지를 저장합니다.
    private int m_OwningThreadId = 0;
    private int m_Recursion = 0;

    public void Enter()
    {
        //이 메서드를 소유한 스레드가 이미 락을 소유하고 있다면 중복 횟수만 증가시키고 반환합니다.
        var threadId = Thread.CurrentThread.ManagedThreadId;
        if(threadId == m_OwningThreadId)
        {
            m_Recursion++;
            return;
        }

        //이 메서드를 호출한 스레드가 락을 소유하고 있지 않은 경우 락을 획득하기 위해서 다음과 같이 수행합니다.
        var spinWait = new SpinWait();
        for(int spinCount = 0; spinCount < m_SpinCount; spinCount++)
        {
            //락이 해제되었다면 현재 스레드가 락을 획득할 것입니다. 락을 소유한 스레드는 상태 저장 후 반환합니다.
            if(Interlocked.CompareExchange(ref m_Waiters, 1,0) == 0)
            {
                goto GotLock;
            }

            //... 여기서 다른 스레드가 수행될 기회를 줍니다.
            //락을 소유하고 있는 스레드가 빨리 수행되어 소유하고 있던 락을 해제할 수 있도록 하는 거싱 좋습니다.
            spinWait.SpinOnce();
        }

        // 주어진 횟수만큼 스피닝을 수행하였으나 여전히 락을 획득하지 못한 경우, 한번만 더 스피닝을 수행해봅니다.
        if (Interlocked.Increment(ref m_Waiters) > 1)
        {
            //여전히 경쟁 상태이므로, 스레드는 대기할 수밖에 없습니다.
            m_WaiterLock.WaitOne(); //락을 대기합니다. 성능 저하 발생
            // 스레드가 깨어나면, 락을 소유하게 됩니다. 이제 락을 소유한 스레드는 상태 저장 후 반환합니다.
        }

    GotLock:
        //스레드가 락을 소유하면, 스레드의 ID를 저장하고 중복 횟수를 1로 설정합니다.
        m_OwningThreadId = threadId;
        m_Recursion = 1;
    }

    public void Leave()
    {
        //이 메서드를 호출한 스레드가 락을 소유한 것이 아니면 오류
        int threadId = Thread.CurrentThread.ManagedThreadId;
        if (threadId != m_OwningThreadId)
        {
            throw new SynchronizationLockException("Lock not owned by calling thread");
        }
        //중복 횟수를 감소시킵니다. 만일 현재 스레드가 계속 락을 소유해야 하는 상황이면 바로 반환합니다.
        if(--m_Recursion > 0)
        {
            return;
        }

        m_OwningThreadId = 0;
        if(Interlocked.Decrement(ref m_Waiters) == 0)
        {
            //락을 획득하기 위해서 대기하는 스레드가 없다면 바로 반환합니다.
            return;
        }

        //다른 스레드가 대기 중이라면 그 중 하나를 깨웁니다.
        m_WaiterLock.Set(); //여기서 성능저하가 발생합니다.
    }

    public void Dispose() => m_WaiterLock.Dispose();
}
```

- 여기서 29장에서 했던 방식대로 성능 측정을 해보면
```console
Incrementing x : 5000000 : 2
Incrementing x : 10000000 in M : 29
Incrementing x : 15000000 in SpinLock : 138
Incrementing x : 20000000 in SimpleWaitLock : 10156
Incrementing x : 25000000 in SimpleHybridLock : 76
Incrementing x : 30000000 in AnotherHybridLock : 206
```
- AnotherHybridLock이 SimpleHybridLock 에 비해 성능이 좋지 않습니다. 전자의 경우 몇 가지 필드를 더 가지고 있으며 그에따라서 코드도 복잡해지기 때문에 성능저하가 발생하는 것입니다.


### 프레임워크 클래스 라이브러리(FCL) 내의 복합 동기화 요소
- FCL에는 사용자 스레드를 가능한 커널 모드로 전환하지 않고 유저 모드에서 수행될 수 있도록 해주어 응용프로그램의 성능을 향상시킬 수 있는 다양한 복합 스레드 동기화 요소를 포함합니다.
  - 몇몇 동기화 요소는 경쟁 상태가 발생할 때까지 커널 모드 스레드 동기화 요소를 생성하지 않도록 해주어, 객체 생성이나 추가적인 메모리 소요가 발생하지 않도록 해줍니다.
  - 또한 FCL에 포함된 대다수의 동기화 요소는 CancellationToken과 같이 사용될 수 있어서 락을 대기하는 블로킹된 스레드의 작업을 취소할 수도 있습니다.

**ManualResetEventSlim과 SemaphoreSlim 클래스**
- AutoResetEventSlim 과 같은 클래스는 제공되지 않지만, 대부분의 상황에서SemaphoreSlim객체의 maxCount를 1로 설정하여 유사 기능을 수행할 수 있을 것입니다.
- 이 동기화 요소들은 이름에 포함된 커널 모드 동기화 요소들과 각각 대응되며, 단지 유저 모드에서 스피닝을 추가적으로 수행하며 경쟁상태가 발생할 때까지 해당 커널 동기화 요소를 생성하지 않는다는 데 차이가 있습니다.
  - 개별 객체가 제공하는 Wait 메서드들은 타임아웃과 CancellationToken을 매개변수로 취할 수도 있습니다.

**Monitor 클래스와 싱크 블록**
- Monitor는 스피닝과 더불어 스레드 소유권, 중복 소유를 지원하는 상호 배제 락입니다.
- 힙에 생성되는 모든 객체는, 객체와 연관된 동기화 블록(sync block)을 가지고 있습니다. 동기화 블록은 앞에서 살펴본 AnotherHybridLock과 유사한 필드를 가지고 있습니다. (커널 객체를 위한 필드, 싱크 블록을 소유하고 있는 스레드 ID, 중복 횟수, 대기 중인 스레드의 개수)
- Monitor 클래스는 static 클래스로 선언되어 있고, 각각의 메서드들은 힙 객체에 대한 참조 값을 매개변수로 취하여, 해당 객체와 연관되어 있는 동기화 블록의 필드를 수정합니다.

<br>

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/30-1.png" width="70%" height="70%">

<br>

- 이때 힙 상의 모든 객체에 대해서 동기화 블록 구조체를 생성한다는 것은 낭비적입니다. 대부분의 객체들은 동기화 블록을 사용하지 않습니다.
  - 그러므로 CLR에서는 자신이 초기화될 때 동기화 블록을 저장할 수 있는 배열을 네이티브 힙에 미리 할당해둡니다.
    - 4장에서 살펴본대로 힙 상에 객체가 생성된다면 객체별로 두 개의 필드가 추가됩니다.(동기화 블록 인덱스, 타입 객체 포인터) 여기서 동기화 블록 인덱스는 동기화 블록 배열의 인덱스를 나타냅니다.
  - 객체가 최초로 생성되면 객체의 동기화 블록 인덱스 값을 -1로 초기화하며 이는 동기화 블록을 가지지 않음을 나타냅니다.
  - 이후에 Monitor.Enter를 호출하면 CLR은 동기화 블록 배열에서 사용되지 않고 있는 동기화 블록을 찾아서 그 인덱스 값을 할당해줍니다. 즉 이 시점에 힙의 객체는 동기화 블록과 연계되는 것입니다.
  - 이제 Monitor.Exit를 호출하면 동일 싱크 블록을 사용하기 위해서 대기중인 스레드가 있는지 확인하게 되는데, 대기 중인 스레드가 없다면 싱크 블록을 해제 하기 위해서 객체가 가지고 있던 동기화 블록 인덱스를 -1로 변경합니다. 이렇게 함으로써 추후 다른 객체가 동일 싱크 블록을 재사용할 수 있도록 해줍니다.

<br>

- Monitor 사용 시 주의사항으로는 Monitor.Enter ~ Exit 내부에서 비동기 동작을 호출하여 외부 스레드가 잠긴 영역으로 다시 접근하는 경우는 반드시 피해야 한다는 것입니다.
  - MoreEffective C# 항목 42 : 잠긴 영역에서는 외부 코드 호출을 삼가라 참조
- Monitor가 static 클래스라서 내포하는 문제점들이 존재하비다.
  - 만일 어떤 객체가 참조하는 객체의 타입이 System.MarshalByRefObject 클래스를 상속한 경우라면 해당 객체는 프록시 객체를 참조하고 있을 수 있습니다. 프록시 객체를 Monitor의 메서드에 매개변수로 전달하게 되면, 프록시가 참조하는 실제 객체가 락이 되는 것이 아니라 프록시 객체가 락이 될 것입니다.
  - 스레드가 도메인 중립(domain neutral) 공간에 로드된 타입 객체를 매개변수로 Monitor.Enter를 호출하면 프로세스 내의 모든 앱도메인에 걸쳐서 해당 타입의 락을 소유하게 됩니다. 따라서 타입 객체를 Monitor의 메서드에 매개변수로 전달하지 않는 것을 권장합니다.
  - 문자열은 공유될 수 있기 때문에, 서로 완전히 분리되어 있는 코드들이 부지불식간에 동일한 string 객체를 참조할 수 있습니다. 이러한 문자열이 Monitor에 전달되면 서로 전혀 연관없는 코드들이 동기화되어 수행되게 됩니다.
  - Monitor의 메서드들이 매개변수로 Object 타입을 취하기 때문에, 만일 매개변수로 값 타입을 전달하게 되면, 박싱이 일어나게 되고 결국 박싱된 객체에 대해 락을 획득하게 됩니다.
  - [MethodImpl(MethodImplOptions.Synchronized)] 특성을 메서드에 적용하면 JIT 컴파일러는 메서드 내의 코드를 Monitor.Enter와 Monitor.Exit으로 감쌉니다. 만일 이 메서드가 인스턴스 메서드라면, 메서드에 전달된 this 객체에 대해 암시적으로 public 노출된 것과 다름이 없는 락을 소유하게 됩니다. 이 특성은 사용하지 않을 것을 권장합니다.
  - 특정 타입의 타입 생성자를 호출하면 CLR은 이 타입의 타입 객체에 대한 락을 획득하여 단일 스레드를 이용하여 타입 객체를 초기화한 후 정적 필드를 초기화합니다. 다시 말하지만 이 타입은 도메인 중립 공간에 로드될 수도 있기 때문에, 문제를 일으킬 수 있습니다. 예를 들어 타입 생성자의 코드가 무한 루프에 빠지게 되면 특정 프로세스에 포함된 모든 앱도메인에 걸쳐 해당 타입을 사용하지 못하게 됩니다. 따라서 타입 생성자는 가능한 사용하지 않을 것을 권장합니다.

<br><br>

- C# 언어는 lock이라는 키워드를 제공하여 락을 획득하고 해제하는 절차를 단순화할 수 있도록 배려합니다.
```cs
private void SomeMethod()
{
    lock (this)
    {
        //이 코드는 배타적으로 데이터에 접근합니다.
    }
}
```
위의 코드는 아래와 동작이 동일합니다.
```cs
private void SomeMethod()
{
    bool lockTaken = false;
    try
    {
        //여기에서 ThreadAbortException 같은 예외가 발생할 수 있습니다.
        Monitor.Enter(this, ref lockTaken);
        //이 코드는 상호 배타적으로 데이터에 접근합니다.
    }
    finally
    {
        if (lockTaken)
        {
            Monitor.Exit(this);
        }
    }
}
```

- 하지만 lock 키워드는 문제점을 내포하는데, 
  - finally 블록에서 락을 해제하도록 하지만 좋은 생각이 아닙니다. 예외가 발생했다는 것은 객체의 상태 정보가 손상되었을 수도 있다는 것을 의미하고 finally에서 락이 해제되고 나면 다른 스레드가 손상된 데이터를 가지고 작업을 하게 될 위험이 있습니다.
    - 차라리 응용 프로그램을 멈추는게 더 좋을 수도 있습니다.
  - try 블록을 들락날락하는 것은 성능상 좋지 않은 영향을 줍니다. 일부 JIT 컴파일러는 try 블록 내부에서 호출하는 메서드를 인라인 처리하지 않는 경우도 있는데, 이 경우 성능 저하는 더욱 심해집니다.
  - c#의 lock 키워드는 사용하지 않는 것을 권장합니다.

<br><br>

**ReaderWriterLockSlim 클래스**
- 공유 데이터 자원이라 해도 모든 스레드가 데이터를 읽기만 하는 경우라면 데이터에 동시에 접근해도 무방합니다. 반대로 수정하는 경우에는 반드시 상호 배제된 방식으로 데이터에 접근해야만 합니다. ReaderWriterLockSlim 요소는 이러한 문제를 해결하기 위해서 구현된 것으로, 다음과 같이 스레드를 제어합니다.
  - 특정 스레드가 데이터를 쓰고 있으면, 다른 스레드들의 모든 데이터 접근 요청은 블로킹됩니다.
  - 특정 스레드가 데이터를 읽고 있으면, 다른 스레드들의 읽기 요청은 블로킹되지 않고 수행될 수 있습니다. 하지만 쓰기 요청은 블로킹됩니다.
  - 데이터를 쓰고 있던 스레드가 작업을 완료하면, 쓰기 요청을 한 스레드들 중 단 하나의 스레드만 블로킹을 해제하여 데이터를 쓸 수 있도록 하거나 읽기 요청을 한 다수의 스레드들의 블로킹을 해제하여 데이터를 동시에 읽을 수 있도록 해줄 수 있습니다. 만일 블로킹된 스레드가 없다면 락을 해제하여 다음에 스레드들이 사용할 수 있도록 합니다.
  - 여러 스레드들의 읽기 작업이 모두 완료되면, 쓰기 요청을 한 스레드들 중 단 하나의 스레드만이 블로킹을 해제하여 데이터를 쓸 수 있도록 해줍니다. 만일 블로킹된 스레드가 없다면 락을 해제하여 다음에 스레드들이 사용할 수 있도록 합니다.



**OneManyLock 클래스**

저자가 직접 작성한 ReaderWriterLockSlim 클래스

...

**CountdownEvent 클래스**

내부 카운터 값이 0이 될 때까지 스레드를 블로킹시킨다.(세마포어의 동작방식을 거꾸로 뒤집어 놓은 방식)

...

**Barrier 클래스**
흔히 발생하는 문제를 해결하려고 만들어진 클래스는 아닙니다. 개발자들이 활용할 일은 적습니다.
- Barrier는 보통 여러 스레드들을 이용하여 병렬적으로 알고리즘을 단계별로 수행하려는 경우, 이들 스레드를 제어하기 위한 용도로 사용됩니다.


#### 스레드를 동기화 요소에 대한 요약
- 스레드를 블로킹하는 코드를 최대한 작성하지 않는 것을 권장합니다. Interlocked와 같은 메서드를 활용하는 쪽이 스레드 블로킹을 방지할 수 있습니다.
- 그래도 만일 스레드 블로킹을 고려해야 하는 경우
  - 프로그래밍 모델 단순화 : 스레드 블로킹을 사용한다는 것은 콜백 메서드 없이 프로그램의 코드를 순차적으로 작성하기 위해서 일부 리소스와 성능을 희생하는 것입니다. 하지만 콜백 메서드 없이 응용 프로그램을 순차적으로 작성하기만 하면 됩니다.
  - 스레드가 고유의 목적을 가진다 : GUI 기능을 담당하는 스레드를 배정할 경우, gui 스레드는 다른 작업이 수행될 때 잠시간 블로킹 해두었다가 그 이후에 ui나 컨트롤러를 갱신하는 경우가 있습니다.
- 락을 중복 소유하는 것은 성능에 나쁜 영향을 끼칩니다. 하지만 Monitor는 중복 소유를 허용 함에도 성능이 상당히 좋은 편입니다.(Monitor의 일부가 관리 코드가 아니라 네이티브 코드로 구현되었기 때문입니다) 
- 또한 finally 블록 내에서 락을 해제하는 것은 피하는 것이 좋습니다. 예외 처리 블록으로 진입하거나 빠져 나오는 작업은 상당한 성능 저하를 유발하거니와 상태를 변경하던 중간에 예외가 발생하면 상태 정보가 손상되어 다른 스레드들이 이로 인해 이상 동작을 할 수 있습니다.

### 잘 알려진 이중 확인 락 기법
- 싱글톤 패턴에서 다수의 스레드가 처음 싱글톤 객체에 접근할 때 객체가 여러 개 생성되는 일은 막아야 합니다(늦은 초기화, lazy initialization). 

```cs
internal sealed class Singleton
{
    private static readonly object s_Lock = new object();
    private static Singleton s_Value = null;
    
    //생성자를 private로 선언하여 외부에서 이 클래스의 인스턴스를 생성할 수 없도록 하고 있다.
    private Singleton()
    {

    }

    //c#을 이용하여 구현한 이중확인 락 기법
    public static Singleton Instance
    {
        get
        {
            if(s_Value != null)
            {
                return s_Value;
            }
            Monitor.Enter(s_Lock);
            if(s_Value == null) //메모리 펜스를 통해 CPU 레지스터에 캐싱된 s_Value 값을 읽는것이 아닌 메모리에서 직접 s_Value 값을 조회하도록 합니다.
            {
                var tmp = new Singleton();
                Volatile.Write(ref s_Value, tmp);   //메모리 펜스
            }
            Monitor.Exit(s_Lock);
            return s_Value;
        }
    }
}
```
메모리 펜스가 없다면
- 컴파일러는 이 코드를 만났을 때 Singleton 객체를 위한 메모리를 할당하고, 생성자를 호출하여 필드의 값을 초기화한 후, 그 값을 s_Value 필드에 그 참조 값을 할당하도록 코드를 생성할 것이라고 생각합니다.
  - 스레드가 변수의 값을 살펴볼 수 있도록 하는 작업을 퍼블리싱(publishing) 이라고 하는데 사실 컴파일러는 Singleton을 위한 메모리를 할당하고, s_Value에 참조 값을 퍼블리싱(할당)한 후에 생성자를 호출합니다.
  - 단일 스레드의 경우 이렇게 순서가 바뀌더라도 문제가 발생하지 않지만, 다중 스레드에서는 문제가 됩니다. s_Value에 참조 값을 퍼블리싱하고 생성자를 아직 호출하기 이전인 상황에서 다른 스레드가 싱글톤 객체를 참조한다면 이 스레드는 s_Value가 null이 아님을 확인하고 해당 객체를 사용하려 할 것이다.(하지만 생성자 호출이 완료되지 않은 상태)
- Volatile.Write를 이용하여 이 같은 문제를 해결합니다. 이 방법을 통해 tmp내의 참조 값을 s_Value로 퍼블리싱하기 전에 생성자가 수행을 완료하였음을 보증할 수 있습니다.

```cs
internal sealed class Singleton
{
    private static Singleton s_Value = new Singleton();
    public static Singleton Instance => s_Value;
    
    //생성자를 private로 선언하여 외부에서 이 클래스의 인스턴스를 생성할 수 없도록 하고 있다.
    private Singleton()
    {

    }
}
```
- 싱글톤을 구현하는 다른 방법
  - CLR은 타입 생성자의 스레드 안정성을 보증하므로 해당 싱글톤 객체는 단 한개만 생성됩니다.
  - 대신 해당 타입 생성자는 타입을 참조할때 수행되므로, 싱글톤 객체를 참조하는 것이 아닌 다른 정적 멤버를 참조하는 경우에도 싱글톤 객체가 생성됩니다.

```cs
internal sealed class Singleton
{
    private static Singleton s_Value = new Singleton();
    public static Singleton Instance
    {
        get
        {
            if(s_Value != null)
            {
                return s_Value;
            }

            var tmp = new Singleton();
            Interlocked.CompareExchange(ref s_Value, tmp, null);

            //만약 다수의 스레드가 동시에 싱글톤 객체를 생성한다 하더라도, s_Value에는 단 하나의 객체만이 할당되게 됩니다. 나머지는 전부 가비지로 수집됩니다.

            return s_Value;
        }
    }
    
    //생성자를 private로 선언하여 외부에서 이 클래스의 인스턴스를 생성할 수 없도록 하고 있다.
    private Singleton()
    {

    }
}
```
- 싱글톤을 구현하는 세 번째 방법
  - Interlocked를 활용함으로써 스레드를 블로킹하지 않고도 빠른 성능으로 싱글톤 객체를 참조할 수 있습니다.

**Lazy 활용**
- System.Lazy 클래스를 통해 위의 기법을 활용하도록 코드를 작성할 수 있습니다.

```cs
public static void Main()
{
    //DateTime을 이용하는 늦은 초기화 랩퍼(lazy-Initialization wrapper)를 생성합니다.
    Lazy<string> s = new Lazy<string>(() => DateTime.Now.ToLongTimeString(), true);

    Console.WriteLine($"value Created : {s.IsValueCreated}");   // Value 값을 가져올 수 없으므로 false를 반환
    Console.WriteLine($"value : {s.Value}");    // 이 시점에 매개변수로 전달한 델리게이트가 호출
    Console.WriteLine($"value Created : {s.IsValueCreated}");   // Value 값을 가져올 수 있으므로 true 반환
    Thread.Sleep(1000);
    Console.WriteLine($"value : {s.Value}");    // 이번에는 델리게이트 호출 X, 이전과 동일한 값 출력
}
```

- LazyInitializer 활용
```cs
public static void Main()
{
    //아래 방식은 내부적으로 Interlocked.CompareExchange를 활용합니다.

    string name = null;
    //name이 null이므로, 델리게이트가 수행되고 name이 초기화됩니다.
    LazyInitializer.EnsureInitialized(ref name, () => "Jeffrey");
    Console.WriteLine(name);

    //name이 null이 아니므로, 델리게이트가 수행되지 않으며, name이 변경되지 않습니다.
    LazyInitializer.EnsureInitialized(ref name, () => "Richter"); 
    Console.WriteLine(name);    //여전히 "Jeffrey" 출력



    //아래 방식은 내부적으로 Monitor의 Enter와 Exit을 사용할 수 있도록 syncLock을 전달합니다.
    name = null;
    var lockObj = new object();
    LazyInitializer.EnsureInitialized(ref name, ref lockObj, () => "Richter");
    Console.WriteLine(name);

    LazyInitializer.EnsureInitialized(ref name, ref lockObj, () => "Jeffrey");
    Console.WriteLine(name);    //여전히 "Richter" 출력
}
```


### 조건 변수 패턴
- 복잡한 조건이 참일 경우에만 특정 코드를 수행하도록 하고 싶을 수 있습니다. 이를 위한 하나의 방법으로 스레드를 계속 스피닝시키면서 조건을 지속적으로 확인하는 방법이 있을 수 있습니다. 그러나 이 방법은 CPU 시간을 낭비하게 되는데 여러 변수로 구성되어 있는 복잡한 조건 계산을 효율적으로 동기화할 수 있는 패턴이 있습니다.
- 조건 변수 패턴(condition variable pattern)이라 부릅니다.

```cs
internal sealed class ConditionVariablePattern
{
    private readonly object m_Lock = new object();
    private bool m_Condition = false;

    public void Thread1()
    {
        Monitor.Enter(m_Lock);

        //lock 을 획득한 상태로 복잡한 조건을 "원자적"으로 확인합니다.
        while (!m_Condition)
        {
            //조건을 만족하지 않으면 다른 스레드가 조건을 변경할 때까지 기다립니다.
            Monitor.Wait(m_Lock); // 임시로 작을 해제해서 다른 스레드가 락을 획득할 수 있도록 해줍니다.
        }

        //...
        //조건을 만족하면 데이터를 처리합니다

        Monitor.Exit(m_Lock);
    }

    public void Thread2()
    {
        Monitor.Enter(m_Lock);

        //...
        //데이터를 처리하고 조건을 수정합니다.

        m_Condition = true;

        Monitor.Pulse(m_Lock);      //락을 해제하고 대기 중인 스레드 중 하나를 깨웁니다.
        //Monitor.PulseAll(m_Lock);   //락을 해제하고 대기 중인 모든 스레드를 깨웁니다. 여기서 다른 모든 스레드를 깨우더라도 다시 락을 획득하는 스레드는 하나입니다.

        Monitor.Exit(m_Lock);
    }
}
```
- 첫번째 스레드에서는 조건을 만족하지 않을 시 해당 스레드를 블로킹 시키고 다른 스레드가 조건 처리 작업을 수행할 수 있도록 합니다. 스레드를 스피닝시키면서 계속 조건을 확인할 수도 있지만, 이는 CPU시간을 낭비하기 때문에 Wait 메소드를 호출합니다.
- 두번째 스레드에서는 조건을 처리하는 작업을 수행하고 블로킹된 스레드를 다시 깨웁니다. 


- 조건 변수 패턴을 활용한 스레드 안전한 큐의 구현
```cs
//스레드 안정적인 큐의 구현
internal sealed class SynchronizedQueue<T>
{
    private readonly object m_Lock = new object();
    private readonly Queue<T> m_Queue = new Queue<T>();

    public void Enqueue(T item)
    {
        Monitor.Enter(m_Lock);
        //큐에 아이템을 삽입한 후에 대기 중인 스레드 중 하나(혹은 전체)를 깨웁니다.
        m_Queue.Enqueue(item);
        Monitor.PulseAll(m_Lock);
        Monitor.Exit(m_Lock);
    }

    public T Dequeue()
    {
        Monitor.Enter(m_Lock);
        while(m_Queue.Count == 0)
        {
            Monitor.Wait(m_Lock);
        }

        var item = m_Queue.Dequeue();
        Monitor.Exit(m_Lock);
        return item;
    }
}
```


### 비동기 동기화
- 락은 매우 대중화된 기법이지만, 락을 너무 오랫동안 소유하게 되면 확장성에 치면적인 문제를 야기할 수 있습니다. 따라서 락이 필요한 위치에 비동기 동기화 요소를 사용하는 것은 상당히 유용하다고 할 수 있습니다. 락을 획득할 수 없을 때 단순히 반환해 버리거나 다른 일을 처리할 수 있어서, 스레드가 블로킹되는 것을 피할 수 있으며 이후 락을 획득할 수 있는 상황이 되면 어떤 식으로든 작업을 재개하여 락으로 보호하려던 자원에 접근할 수 있습니다.
- SemaphoreSlim 클래스의 WaitAsync 메서드는 이러한 아이디어를 구현하였습니다. 이 메서드를 이용하면 비동기적으로 리소스에 대한 동기 접근을 수행할 수 있습니다.(스레드를 블로킹하지 않고)

```cs
private static async Task AccessResourceViaAsyncSynchronization(SemaphoreSlim asyncLock)
{
    //...
    //여기서는 어떤 코드든지 수행할 수 있습니다.

    await asyncLock.WaitAsync(); //리소스에 대한 배타적인 접근을 위해서 락을 요청합니다.
                                 //여기서 락을 회득하였다면 다른 스레드가 리소스에 접근 하지 못합니다.

    //...
    //여기서 상호 배타적으로 리소스를 활용합니다.

    //작업을 마쳤다면 락을 반환하여 다른 코드에서 리소스를 사용할 수 있게 합니다.
    asyncLock.Release();

    //...
    //여기서는 어떤 코드든지 수행할 수 있습니다.
}
```
- 아래는 책에서 저자가 작성한 리더-라이터 구조의 비동기 락
  - 내부적으로 커널 모드 스레드 동기화 요소를 사용하지 않기 때문에 스레드를 블로킹하지 않습니다.
```cs
private static async Task AccessResourceViaAsyncSynchronization(AsyncOneManyLock asyncLock)
{
    // 여기서는 어떤 코드든지 수행 가능

    //동시에 접근하려면 OneManyMode.Exclusive나 OneManyMode.Shared를 사용
    await asyncLock.WaitAsync(OneManyMode.Shared);

    //상호 배타적으로 리소스를 읽는다.

    asyncLock.Release();
    // 여기서는 어떤 코드든지 수행 가능
}

public enum OneManyMode
{
    Exclusive, 
    Shared
}

public sealed class AsyncOneManyLock
{
    #region 락 코드
    private SpinLock m_Lock = new SpinLock(true); //읽기 전용으로 사용하지 않음
    private void Lock()
    {
        bool taken = false;
        m_Lock.Enter(ref taken);
    }
    private void Unlock()
    {
        m_Lock.Exit();
    }
    #endregion

    #region 락의 상태와 헬퍼 메서드
    private int m_State = 0;
    private bool IsFree => m_State == 0;
    private bool IsOwnedByWriter => m_State == -1;
    private bool IsOwnedByReaders => m_State > 0;
    private int AddReaders(int count) => m_State += count;
    private int SubtractReader() => --m_State;
    private void MakeWriter() => m_State = -1;
    private void MakeFree() => m_State = 0;
    #endregion

    //경쟁 상태가 아닌 경우에는 성능을 높이고 메모리 소비를 줄이기 위해서 사용
    private readonly Task m_NoContentionAccessGranter;

    //대기 중인 개별 라이터 스레드는 큐잉된 각자의 TaskCompletionSource에 의해서 깨어납니다.
    private readonly Queue<TaskCompletionSource<Object>> m_WaitingWriters = new Queue<TaskCompletionSource<object>>();

    //대기 중인 모든 리더 스레드는 단일의 TaskCompletioniSource 의해서 깨어난다
    private TaskCompletionSource<Object> m_WaitingReadersSignal = new TaskCompletionSource<Object>();
    private int m_NumWaitingReaders = 0;

    public AsyncOneManyLock()
    {
        m_NoContentionAccessGranter = Task.FromResult<Object>(null);
    }

    public Task WaitAsync(OneManyMode mode)
    {
        var accessGranter = m_NoContentionAccessGranter; //경쟁 상태가 아니라고 가정

        Lock();
        switch (mode)
        {
            case OneManyMode.Exclusive:
                {
                    if (IsFree)
                    {
                        MakeWriter(); // 경쟁 상태가 아니다.
                    }
                    else
                    {
                        //경쟁 상태 : 새로운 라이터 태스크를 큐에 삽입하여 라이터 스레드가 대기하게 한 후 이를 반환
                        var tcs = new TaskCompletionSource<object>();
                        m_WaitingWriters.Enqueue(tcs);
                        accessGranter = tcs.Task;
                    }
                    break;
                }
            case OneManyMode.Shared:
                {
                    if(IsFree || 
                        (IsOwnedByReaders && m_WaitingWriters.Count == 0))
                    {
                        AddReaders(1); // 경쟁 상태가 아니다.
                    }
                    else
                    {
                        //경쟁 상태 : 대기 중인 리더 스레드의 개수를 증가하고, 리더 태스크가 대기하게 한 후 이를 반환
                        m_NumWaitingReaders++;
                        accessGranter = m_WaitingReadersSignal.Task.ContinueWith(task => task.Result);
                    }
                    break;
                }
        }
        Unlock();

        return accessGranter;
    }

    public void Release()
    {
        TaskCompletionSource<object> accessGranter = null; //어떤 코드도 해제하지 않았다고 가정

        Lock();
        if (IsOwnedByWriter)
        {
            MakeFree(); //라이터 스레드인 경우
        }
        else
        {
            SubtractReader(); //리더 스레드인 겅우
        }

        if (IsFree)
        {
            //프리 상태이면, 대기 중인 라이터 스레드 하나를 깨우거나 모든 리더 스레드를 깨웁니다.
            if(m_WaitingWriters.Count > 0)
            {
                MakeWriter();
                accessGranter = m_WaitingWriters.Dequeue();
            }
            else if(m_NumWaitingReaders > 0)
            {
                AddReaders(m_NumWaitingReaders);
                m_NumWaitingReaders = 0;
                accessGranter = m_WaitingReadersSignal;

                //추후 리더 스레드를 대기시키기 위해서 새로운 TCS를 생성
                m_WaitingReadersSignal = new TaskCompletionSource<object>();
            }
        }
        Unlock();

        //리더/라이터 스레드가 락을 벋어날 수 있도록 하여 경쟁 상태가 발생할 수 있는 가능성을 낮추어 성능을 개선
        accessGranter?.SetResult(null);
    }
}
```

### Concurrent 컬렉션 클래스
- FCL은 ConcurrentQueue, ConcurrentStack, ConcurrentDictionary, ConcurrentBag의 네 개의 스레드-안정적인 컬렉션 클래스를 제공합니다.
  - 해당 클래스들은 스레드를 블로킹하지 않습니다. 따라서 컬렉션 내에 존재하지 않는 항목을 가져오려고 하는 경우, 해당 항목이 삽입될 때까지 기다리는 것이 아니라 즉각 반환됩니다. (TryDequeue 등, 자원을 가져올 수 없다면 false 반환)
  - ConcurrentStack, ConcurrentQueue, ConcurrentBag 컬렉션은 IProducerConsumerCollection 인터페이스를 구현하고 있습니다. 이 인터페이스를 구현하고 있는 클래스는 블로킹 컬렉션으로 변경될 수 있는데 이와 같이 변경되면 컬렉션이 가득 찬 경우 항목을 생산하는 스레드가 블로킹될 수 있으며, 컬렉션이 비어있을 때는 항목을 소비하는 스레드가 블로킹될 수 있습니다.
</details>
