# 제프리 리처의 CLR via C# 4판

## 1장. CLR의 실행 모델

<details>
  <summary>fold/unfold</summary>

### 공용 언어 런타임(CLR, Common Language Runtime)
- 서로 다른 프로그래밍 언어들 사이에서 공동으로 사용할 수 있는 실행환경(Runtime)을 말합니다.
- CLR을 지원하는 언어라면 CLR의 기능(메모리 관리, 어셈블리 로딩, 스레드 동기화 등)을 자유롭게 사용할 수 있습니다.

<img src="https://1.bp.blogspot.com/-g9AYNMBpG1s/U7Qii8mJm_I/AAAAAAAAAqg/bTFteXucTQA/s1600/2014-07-02_111719.png" width="40%" height="40%">

- CLR은 관리모듈을 실행시킵니다. 관리 모듈(managed module)이란 CLR을 지원하는 프로그래밍 언어를 컴파일한 결과물로 크게 IL과 메타데이터로 이루어집니다.

### 메타데이터(metadata)
- 메타데이터는 모듈 내의 타입과 그들의 구성 멤버 등의 대한 데이터 테이블입니다.
  - 테이블은 크게 두 종류로 나누어집니다. 하나는 소스 코드에 포함된 타입들과 그 멤버들의 정보, 다른 하나는 소스 코드가 참조하는 타입들과 멤버들에 대한 정보입니다.
- 프로그램 실행 파일이 생성될 시 메타데이터는 해당 파일 안에 포함됩니다.
- visual studio의 인텔리센스는 메타데이터를 활용합니다.
- 메타데이터는 각각의 객체(object)들이 메모리 블록 안에 serialization 할 수 있도록 합니다. 이후 deserialization을 거쳐서 객체가 원래 상태로 복원될 수 있습니다.
- 가비지 컬렉터(garbage collector)가 객체의 생명주기를 추적할 때 메타데이터를 활용합니다.

### 어셈블리(assembly)
CLR은 실제로 모듈들을 다루지는 않으며, 어셈블리를 다루게 됩니다. 어셈블리는 명확하게 정의하기엔 추상적인 개념이며 아래와 같습니다.

- 하나의 어셈블리는 하나 이상의 모듈이나 리소스 파일들에 대한 논리적 그룹입니다.
- 하나의 어셈블리는 재사용, 보안, 버전 관리의 가장 작은 단위입니다.

<img src="https://i.stack.imgur.com/s6gSO.png" width="60%" height="60%">

위의 그림에서 다수의 모듈과 리소스 파일이 결합되어 하나의 어셈블리로 만들어집니다.
- 매니페스트 : 어셈블리 안의 모듈 및 리소스 파일들의 집합을 설명합니다.

### 어셈블리 실행

<img src="https://i.stack.imgur.com/LXVmH.png" width="60%" height="60%">

위의 그림에서 JIT(just in time) 컴파일러가 IL 명령어를 실행하는 과정은 대략 아래와 같습니다.

1. Main 메서드가 실행되기 바로 직전에, CLR은 main 메서드 안에서 참조된 모든 타입들을 파악합니다. 이때 CLR은 내부적으로 자료구조를 생성해 참조된 타입을 관리하는 용도로 사용합니다.
2. Main 메서드가 WriteLine 메서드를 호출할 때 JIT 컴파일러가 호출됩니다. 컴파일러는 메서드의 IL 코드를 네이티브 CPU 명령어로 컴파일합니다. 
3. CLR은 메모리를 동적할당한 뒤 해당 공간에 네이티브 cpu 명령어를 저장합니다.
4. CLR은 새로 생성된 네이티브 cpu 명령어의 메모리 주소를 저장합니다.
5. 실제 코드를 실행합니다.
6. 두번째로 WriteLine 메서드를 호출할 때 CLR은 이미 WriteLine 메서드에 대한 코드를 이미 검사하였고 컴파일이 완료했다는 사실을 확인합니다. 곧바로 네이티브 cpu 명령어가 저장된 메모리로 이동해 코드를 실행합니다. 추가적인 jit 컴파일러 호출은 없습니다.


- 성능 저하는 메서드가 최초로 호출될 때에만 발생합니다.
- JIT 컴파일러는 생성한 네이티브 cpu 명령어를 동적 메모리상에 저장하며 응용프로그램이 종료될 때 자동으로 반환합니다.

### IL과 검증, 안전하지 않은 코드
- IL은 스택 기반의 언어로 모든 IL 명령어들과 연산자가 실행 스택 위에 쌓이고 꺼내어가는 방식으로 실행됩니다.
- IL의 가장 큰 장점은 cpu 내부로부터 추상화된 동작들에 대한 것이 아닙니다. 응용프로그램의 견고함과 보안을 책임진다는 것에 더 의의가 있습니다.
  - IL을 네이티브 CPU 명령어로 컴파일하는 동안, CLR은 확인(verification) 과정을 통해 코드를 검사하고 안전성을 점검합니다.
  - 확인 과정을 통하여 메모리를 잘못된 방향으로 접근하거나 사용하지 않으며, 다른 응용프로그램 코드에 역으로 영향을 주는 일이 없게 합니다. 대표적인 예로 응용프로그램의 물리 메모리와 가상 메모리 주소가 달라 잘못 접근하는 경우를 방지하는 경우가 있습니다.
- C# 컴파일러는 기본적으로 안전한 코드를 만듭니다. 안전한 코드는 확인 과정을 안전하게 통과할 수 있습니다. 반면에 안전하지 않은 코드를 사용하는 경우도 있는데 unsafe 키워드를 추가해서 작성할 수 있습니다. 직접 메모리에 접근하거나 비관리 코드와의 상호운용을 할때 유용합니다.

### 공용 언어 사양
- 공용 타입 시스템(CTS, Common Type System) : 마이크로소프트는 공용 타입 시스템(CTS) 표준을 정의하여 CLR 에서 타입이 어떻게 정의되어야 하고 동작되어야 하는지 명시하고 있습니다.
  - 모든 타입은 미리 정의된 타입인 System.Object 를 상속받습니다.

- CLR은 서로 다른 언어 사이에서 통신할 수 있게 해주는 것 이상으로 모든 언어들을 연계하고 어떤 언어로 쓰인 객체가 다른 언어에서도 완전히 동일한 의미와 사용법을 가지는 동등한 객체로 인지할 수 있게 해줍니다.
  - 이러한 통합이 가능한 이유는 CLR의 표준 타입 집합들과 메타데이터 그리고 공용 실행 환경(Common Execution Environment) 덕분입니다.
- 공용 언어 사양(CLS, Common Language Specification) : 마이크로소프트는 공용 언어사양을 정의하여 컴파일러를 제조할 때 준수해야 할 최소한의 사항들을 정의합니다. 여기에는 다른 CLR 위에서 동작하는 언어들 사이에서 반드시 지원해야할 내용들을 포함합니다.
  - 공용 언어 사양을 통해 언어 사이의 공통적인 규칙이 필수적으로 포함될 수 있게 되었으며 CLR은 이를 통해서 다양한 언어간의 상호 연계를 가능하게 합니다.

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRLR0g7k3JcNHoagiCnQjDYZEEjiDnLTYpKkQ&usqp=CAU" width="40%" height="40%">

</details>

## 4장. 타입의 기초

<details>
<summary>fold/unfold</summary>

### 모든 타입은 System.Object를 상속한다.

#### Reference
- [Microsoft : Object Class](https://docs.microsoft.com/en-us/dotnet/api/system.object?view=net-5.0)
---

- 모든 타입들은 궁극적으로 System.Object 타입으로부터 파생됩니다.
- 따라서 C#의 모든 객체는 System.Object의 public/protected 메서드(GetHashCode, ToString 등)를 사용할 수 있습니다.

```cs
//아래 두 클래스 선언은 동일합니다.

class Widget 
{

}

class Widget : System.Object
{

}


```

- CLR은 모든 객체들을 반드시 new 연산자에 의하여 만들어지도록 하고 있습니다. 
```cs
Widget widget = new Widget("Construct Param");
```

- new 연산자는 아래의 일을 합니다.
  - 할당하려는 타입과 System.Object 타입, 그리고 System.Object를 상속받은 모든 기본 타입들에서 정의된 모든 인스턴스 필드들을 메모리에 할당하기 위한 바이트 수를 계산합니다.
     - 힙상의 모든 객체에는 타입 객체 포인터(Type Object Pointer)와 동기화 블록 인덱스(Sync Block Index)가 추가됩니다. CLR은 두 멤버를 통해 객체를 관리합니다.
     - 추가 멤버들을 위한 바이트는 객체의 실제 크기에 포함됩니다.
  - 필요한 만큼 메모리를 할당합니다. 처음 할당할 때 모든 바이트를 0으로 초기화합니다.
  - 객체의 타입 객체 포인터와 동기화 블록 인덱스 멤버를 초기화합니다.
  - 생성자를 호출하고 new 연산자에 서술된 매개변수가 전달됩니다. 파생클래스의 생성자 부터 호출되며 System.Object의 생성자가 가장 마지막에 호출됩니다.


### 타입 간 캐스팅하기

- CLR의 중요한 기능들 중 하나는 타입 안전성입니다. 실행 시점에서 CLR은 객체의 정확한 타입이 무엇인지 항상 파악하고 있습니다.

```cs

    //암시적으로 System.Object를 상속합니다.
    internal class Widget { }
    
    public sealed class Program
    {
        public static void Main()
        {
            Object o = new Widget(); //암시적 변환이며, 안전합니다.

            //Object 타입으로부터 Widget 클래스를 타입이 파생되었기 때문에 명시적 형 변환 연산자가 필요합니다.
            //경우에 따라 런타임 오류가 발생할 수 있습니다.
            Widget w = (Widget)o;
        }
    }

```
### C#의 is와 as 연산자로 캐스팅하기
- C#에서 캐스팅 연산을 다룰 때 is/as 를 활용할 수 있습니다.

```cs
    Object o = new Object();
    Boolean result1 = o is Object;  //true
    Boolean result2 = o is Widget;  //false
```
- 아래와 같이 활용할 수 있으나, 아래의 경우는 CLR 이 타입을 두 번 점검합니다.

```cs
    //if 문에서 한번 검사합니다.
    if(o is Widget)
    {
        //명시적 형변환을 수행하면서 또 한번 검사합니다.
        Widget w = (Widget)o;
    }
```

- 위와 같은 상황을 방지하기 위해 as 연산자를 사용할 수 있습니다.
```cs
    //여기서 한번 타입을 점검합니다.
    Widget w = o as Widget;
    if(w != null)
    {
        //여기서 w를 사용합니다.
    }
```

### 실행 시점과의 연관성

- 아래는 M1 메서드가 호출되기 직전의 스레드 스택의 상태입니다. 할당된 스레드에서 M1 메서드를 호출할 것입니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-2.jpg" width="40%" height="40%">

- 대게 메서드들은 프롤로그 코드(Prologue Code)를 포함하며 메서드 안의 코드가 동작하도록 초기화를 거치게 합니다.
- 여기에 대응되는 에필로그 코드(Epilogue Code)도 있어서 메서드 실행 후의 정리 작업을 수행하게 합니다. 그리고 원래 호출자에게 돌아갈 수 있게 준비합니다.


- 아래에서 프롤로그 코드는 스레드 스택에 지역변수를 위한 메모리 공간을 할당합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-3.jpg" width="40%" height="40%">

- 아래에서 M2 메서드를 호출합니다. 메서드로 넘길 매개변수와 호출이 끝나고 되돌아갈 위치를 나타내는 주소값이 스택에 올라갑니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-4.png" width="40%" height="40%">

- M2 메서드의 지역변수가 스택에 올라갑니다. M2 메서드가 종료되면 리턴 주소를 확인해 다시 M1 메서드를 수행하던 위치로 되돌아갈 것입니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-5.jpg" width="40%" height="40%">



- 이제 아래의 두 클래스가 정의되어 있다고 가정합시다.

```cs

    public internal class Employee
    {
        public Int32 GetYearsEmployed() { ... }
        public virtual string GetProgressReport() { ... }
        public static Employee Lookup(string name) { ... }
    }

    public internal class Manager : Employee
    {
        public override string GetProgressReport() { ... }
    }
```

- 처음에 Windows 프로세스가 실행되고, CLR이 로드되고, managed heap이 초기화되고, 스택공간과 스레드가 할당될 것입니다. 이 스레드는 초기 코드를 실행한 상태고 이제 M3 메서드를 호출하려고 합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-6.png" width="40%" height="40%">

- JIT 컴파일러가 M3 메서드의 IL 코드를 컴파일하면서 M3 메서드 안의 타입들과 변수 정보에 대해서 파악합니다.
  - 이 시점에서 CLR은 이러한 타입들을 포함하는 어셈블리들을 로드할 것이며, 어셈블리의 메타데이터를 통해 타입 정보를 추출하여 타입에 대한 정보를 서술하는 또다른 자료 구조를 생성합니다.
  - 아래 그림에서 Int32와 string 과 같은 기본적인 타입 정보는 이미 올라와 있다고 가정하며 나타내지 않습니다.

- 아래 그림처럼 힙 위에 만들어지는 모든 객체는 타입 객체 포인터와 동기화 블록 인덱스 멤버를 추가적으로 가집니다.
- 타입을 선언할 때 정의된 정적 데이터는 타입 객체 안에 포함됩니다. 그리고 타입 객체가 생성되는 시점에 초기화됩니다.
- 마지막으로 타입 내의 메서드 하나당 한 개의 항목이 포함된 메서드 테이블도 만들어지게 됩니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-7.png" width="40%" height="40%">

- 스레드의 스택상에 지역 변수를 위한 메모리를 할당합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-8.png" width="40%" height="40%">

- 매니저 객체가 생성됩니다. 역시 타입객체 포인터와 동기화 블록 인덱스를 가지며, 타입 객체 포인터는 Manager의 정확한 타입 객체를 가리키도록 초기화됩니다.
- CLR은 객체를 생성하면서 객체의 모든 인스턴스 필드를 0 또는 NULL 값으로 초기화합니다.
- 그 다음 객체의 생성자를 호출하면서 인스턴스의 데이터를 수정합니다.
- 이후 new 연산자는 만들어진 Manager 객체의 메모리 주소를 반환하여 스레드 스택상에 할당된 변수 e에 저장합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-9.png" width="40%" height="40%">

- Lookup 메서드를 호출할 때 JIT 컴파일러는 IL 코드를 컴파일하고 컴파일된 코드를 동적할당된 메모리에 저장합니다.
- joe가 관리직에 해당한다면 새로운 Mananger 객체가 생성되고 지역변수 e에 저장합니다. 
- 이때 처음 만들어진 Manager 객체는 아무도 참조하지 않으므로 가비지 수거 대상이 됩니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-10.png" width="40%" height="40%">

- GetYearsEmployed 메서드를 호출합니다. 마찬가지로 JIT 컴파일을 거친 뒤 코드를 수행합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-11.png" width="40%" height="40%">

- 가상 메서드 GetProgressReport를 호출합니다.
  - 가상 메서드를 호출할 때에는 JIT 컴파일러가 호출에 앞서 추가적인 코드를 메서드를 호출할 때마다 그 안에 추가하게 됩니다.
  - e의 타입은 Employee 이지만 실제 가리키는 객체는 Manager 타입입니다. 코드를 수행할 때 객체 타입 포인터 멤버가 가리키고 있는 타입 객체 정보를 확인하여 실제 어떤 객체를 가리키고 있는지 파악합니다.
  - 이후 실제 객체 타입의 메서드 테이블에서 호출하려는 메서드를 찾아냅니다. 역시 필요하면 JIT 컴파일을 수행합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-12.png" width="40%" height="40%">

- 아래 그림에서 타입 객체 역시 객체에 해당하므로, 타입 객체 포인터를 멤버를 가진다는 것을 확인할 수 있습니다.
  - 해당 타입 객체 포인터의 경우 System.Type 이라는 MSCORLIB.DLL 안의 선언되어 있는 타입 객체를 가리키게 됩니다.
  - System.Type 타입 객체의 경우 타입 객체 포인터 멤버가 자기 자신을 가리킵니다. System.Type 타입 자체가 그 자체로 객체의 타입 객체이기 때문입니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-13.png" width="40%" height="40%">

</details>

## 5장. 기본, 참조, 값 타입

<details>
<summary>fold/unfold</summary>

### 프로그래밍 언어 기본 타입

#### Reference
- [Microsoft : c# 내장 타입](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types)
---

- 컴파일러가 직접 지원하는 데이터 타입들을 기본 타입(Primitive Type)이라고 부릅니다.
  - 대표적인 예로 int 타입이 있으며 아래 코드 4줄은 전부 같은 IL코드를 생성합니다.

```cs
    int a = 0;
    System.Int32 a = 0;
    int a = new int();
    System.Int32 a = new System.Int32();
```

- C#의 기본 타입들은 조금 독특한 특징을 가지고 있습니다. 다른 프로그래밍 언어에서 int는 32비트 운영체제에서는 32비트 정수로 64비트 운영체제에서는 64비트 정수로 취급되는 경우가 있지만, C#에서 int는 System.Int32의 별칭이기 때문에 반드시 32비트 정수로 취급됩니다. 64비트 정수는 System.Int64의 별칭인 long을 사용해야 합니다.

- C# 컴파일러는 기본 타입들을 다루는 작업들에 대해서 몇 가지 기능을 제공해줍니다.

1. 컴파일러는 아래의 타입들에 대해서 암묵적/명시적 형 변환을 지원합니다.
  - 암묵적 변환에 경우 변환 과정에서 데이터 손실이 없는 '안전한' 경우에만 지원합니다.
```cs
Int32 i = 5;        //Int32 -> Int32
Int64 l = i;        //Int32 -> Int64
Single s = i;       //Int32 -> Single
Byte b = (Byte)i;   //Int32 -> Byte(명시적)
Int16 v = (Int16)s; //Single -> Int16(명시적)
```

- 특히 부동 소수점 데이터를 다룰 때 주의해야 하는데 값을 정수형으로 변환할 때 컴파일러에 따라 버림/반올림 연산 중 어떤 것을 적용할지는 컴파일러마다 다릅니다. C#의 경우는 버림 연산이 적용됩니다.

2. 기본 타입은 변수가 아닌 리터럴 상수로 기재할 수 있습니다.
```cs
Console.WriteLine($"{123.ToString()}, {456.ToString()}");
```

3. 리터럴 상수로 구성되는 표현식이 있다면, 컴파일러가 해당되는 표현식을 컴파일 타임에 평가하여 응용프로그램의 성능을 향상시키도록 할 수도 있습니다.
4. 컴파일러는 +, -, *, /, &, ^ 등의  연산자가 사용되었을 때, 자동으로 연산자 처리 우선순위를 결정합니다.

### 기본 타입 연산의 오버플로우 여부 검사
- 언어마다 오버플로우를 처리하는 방식이 다릅니다. 오버플로우를 허용하는 C/C++ 과 다르게 Visual Baisc .NET에서는 오버플로우를 명백한 오류로 취급하고 발견될 경우 이 사실을 알립니다.
  - C#은 오버플로우를 어떻게 처리할지 개발자가 선택할 수 있게 합니다. 컴파일러 옵션을 바꾸거나, checked/unchecked 키워드를 활용합니다.

```cs
UInt32 valid = unchecked((UInt32)(-1)); 

int i = -1;
UInt32 invalid = checked((UInt32)(i));  //overflow exception

//블록 지정도 가능
checked
{
    Byte b = 100;
    b = (Byte)(b + 200);    //overflow exception
}

checked
{
    DoSomething(100);   //오버플로우 검사가 이루어지지 않을 수도 있습니다.
}

```

- checked 블록 안에서 메서드를 호출한다고 가정했을 때, 메서드가 어떻게 컴파일 되는지에 따라 오버플로우 검사가 이루어질 수도, 이루어지지 않을 수도 있습니다. 
  - checked 코드 블록은 단순히 컴파일 시점에 IL 코드의 오버플로우 검사여부를 결정하는 것에 불과하기 때문입니다.
- checked/unchecked 연산자와 코드 블록, 그리고 컴파일러 스위치는 Decimal 타입에 대해서 검사를 지원하지 않습니다. Decimal 타입은 CLR이 다루지 않는 특수한 타입이며, c# 내부적으로 Decimal 에 대해서는 특별히 다르게 취급하기 때문입니다.(Decimal을 연산하기 위한 정적메서드와 연산자 오버로딩이 추가적으로 존재합니다.)
  - System.Numerics.BigInteger 타입도 마찬가지입니다.

### 참조 타입과 값 타입

- 모든 클래스는 참조타입입니다.
- 모든 구조체와 열거타입은 값 타입입니다. 구조체는 System.ValueType을 상속받고, 열거형은 System.Enum 을 상속받습니다. 여기서 System.Enum 역시 System.ValueType을 상속받습니다.
  - 모든 값 타입은 Sealed 타입입니다. 어떤 타입도 값 타입을 상속받을 수 없습니다.
  - 값 타입이 스택에 할당될 때에는 참조 타입과 달리 타입 객체 포인터와 동기화 블록 인덱스가 멤버로 포함되는 오버헤드가 존재하지 않습니다.

- 어떤 상황에서 값 타입을 쓰는게 좋을지는 [MoreEffective CSharp 4장](https://github.com/wlsvy/TIL/blob/master/Document/C%23/MoreEffectiveCSharp/MoreEffectiveCSharp/Item04.cs) 을 참고합시다.
- 값 타입의 경우, GetHashCode 메서드의 결과값은 타입의 멤버 값을 통해 평가합니다. 서로 다른 두 값 타입 객체가 똑같은 hash 코드 결과값을 반환할 수도 있는 것입니다.

#### CLR의 메모리 레이아웃
- System.Runtime.InteropServices 네임스페이스를 참조합시다. 메모리 레이아웃을 개발자가 임의로 지정한다면 아래와 같은 방식으로 공용체를 만드는 것도 가능합니다.

```cs
using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Explicit)]
    public struct Union
    {
        [FieldOffset(0)]
        public int i;
        [FieldOffset(0)]
        public byte b;
        [FieldOffset(0)]
        public long l;
        [FieldOffset(4)]
        public int i2;
    }
```

### 박싱된 값 타입과 박싱되지 않은 값 타입

- 특정 인터페이스를 상속받은 값 타입에 대해서, 해당 값 타입 객체를 임의의 인터페이스 타입으로 캐스팅할 때 박싱이 필요합니다.
  - 인터페이스 변수는 참조타입입니다.

```cs
 int i = 1;
IComparable c = i;  //boxing
```

- 값 타입에 대해서 GetType, MemberwiseClone 과 같은 System.Object 에 정의된 비가상 메서드를 호출하려 할 때 박싱이 일어납니다. 힙에 할당된 참조 객체만이 해당 메서드를 호출할 수 있기 때문입니다.
- 박싱되지 않은 값 타입들은 동기화 블록 인덱스가 없기 때문에, 다중 스레드 환경에서 lock 구문 등의 설정 대상으로 지정할 수 없습니다.
- 값 타입은 sealed 타입이기 때문에 값 타입 객체가 ToString, Equals, GetHashCode 같은 가상 메서드를 재정의된 후 호출하려 하면 CLR이 이들을 비가상 메서드로서 호출하게 합니다. 추가적인 상속이 없는 것을 확신할 수 있기에 다형성을 무시하는 것입니다.

### 객체의 동일함과 식별
- [More Effective CSharp Item09](https://github.com/wlsvy/TIL/blob/master/Document/C%23/MoreEffectiveCSharp/MoreEffectiveCSharp/Item09.cs)를 확인합시다.

### 객체 해시 코드

### dynamic 기본 타입
- dynamic 타입을 확인하면, 컴파일러는 해당 소스에 대해 조금 특별한 IL코드(페이로드payload)를 만들어 냅니다. dynamic 타입은 런타임 바인더에 의하여, 런타임에 입력되는 값에 따라 타입이 변하게 됩니다.

</details>

## 6장. 타입과 멤버의 기본

<details>
<summary>fold/unfold</summary>

### 서로 다른 종류의 타입 멤버들
- 상수 : 절대불변의 데이터 값을 식별하는 기호입니다. 상수들은 항상 타입과 관계를 가지지만 타입의 인스턴스와는 무관합니다. 논리적 관점에서 정적 멤버입니다.
- 필드 : 일기 전용 혹은 읽기 / 쓰기 겸용 데이터 값에 대한 표현입니다. 필드는 타입의 상태를 정의하기 위하여 정적 멤버로 또는 인스턴스의 상태를 정의하기 위해 인스턴스 멤버로 선언될 수 있습니다.
- 인스턴스 생성자 : 인스턴스 생성자는 객체의 인스턴스 필드를 의도하는 대로 초기화하기 위한 목적으로 선언할 수 있는 메서드입니다.
- 타입 생성자 : 타입 생성자는 타입의 정적 필드들을 의도대로 초기화하기 위한 목적으로 선언할 수 있는 특별한 메서드입니다.
- 메서드 : 멤버로 추가할 수 있는 함수로, 특정한 타입에대한 상태를 변경하기 위하여 정적 메서드를 선언하거나 특정한 인스턴스에 대한 상태를 변경하기 위하여 인스턴스 메서드로 선언할 수 있습니다.
- 연산자 오버로드 : 서로 다른 두 객체애 대해 조작하는 방법을 정의하는 메서드입니다. 공용 언어 사양(CLS) 에는 포함되지 않습니다.
- 변환 연산자 : 암묵적/명시적으로 어떤 객체를 다른 객체 타입으로 변환할 수 있는 방법을 정의하는 메서드입니다. 공용 언어 사양(CLS) 에는 포함되지 않습니다.
- 속성 : 속성은 필드와 비슷한 문법을 사용하여 타입 내의 필드를 변경하거나 상태를 조회하기 위한 정적 속성, 객체 내의 필드를 변경하거나 상태를 조회하기 위한 인스턴스 속성으로 나눌 수 있습니다.
- 이벤트 : 정적 이벤트와 인스턴스 (비정적) 이벤트는 특정한 타입이 다른 정적 메서드 또는 인스턴스 메서드로 통지를 보낼 수 있는 방법을 제공합니다.
- 타입 : 타입 안에 또 다른 타입을 중첩해서 선언할 수도 있습니다. 규모가 큰 타입을 작은 타입들로 분해하여 단순화 시키기 위함입니다.

```cs
    public sealed class SomeType
    {
        //중첩된 클래스
        private class SomeNestedType { }

        //상수 필드, 읽기 전용 필드. 그리고 읽기/쓰기가 가능한 정적 필드
        private const int someConstant = 1;
        private readonly string someReadonlyFiled = "str";
        private static int someReadWriteField = 3;

        //타입 생성자
        static SomeType() { }

        //인스턴스 생성자
        public SomeType(int x) { }
        public SomeType() { }

        //인스턴스 및 정적 메서드
        private string InstanceMethod() { return null; }
        public static void StaticMethod() { }

        //인스턴스 속성
        public int SomeProperty
        {
            get { return 0; }
            set { }
        }

        //매개변수를 요구하는 인스턴스 속성(인덱서)
        public int this[string s]
        {
            get { return 0; }
            set { }
        }

        //인스턴스 이벤트
        public event Action SomeEvent;
    }
```

### 타입의 가시성
이웃 어셈블리
- TeamB 에서 작성한 어셈블리가 TeamA의 어셈블리 안에 들어있는 타입들을 사용하려면 TeamA가 만든 어셈블리 안의 타입들은 모드 public으로 선언해야만 합니다. 하지만, 이렇게 되었을 경우 TeamA가 public으로 선언한 모든 타입들은 TeamB 뿐만 아니라 다른 모든 이들에게도 공개가 됨을 의미하므로 의도하지 않은 결과일 수 있습니다. TeamB가 쓴 코드에서만 TeamA가 작성한 타입들을 사용하도록 의도되었을 때 TeamA가 만든 타입을 internal로 유지하면서도 TeamB에 대해서만 독점적으로 접근권한을 할당할 수 있도록 해야 합니다. CLR과 c#은 이러한 기능을 이웃 어셈블리(friend assmbly)라고 정의합니다.

### 멤버 접근성
- 타입 내의 중첩 타입과 멤버를 정의할 때에는 해당 타입과 멤버의 접근성을 설정할 수 있습니다.
IL 코드를 검증함으로써 참조하는 멤버의 접근성이 설령 컴파일러 수준에서 접근성에 대한 점검이 누락되었다고 할지라도 실행 중에 이를 검사하므로 기능성을 보장받을 수 있습니다. 

- C#에서 선언하는 멤버에 명시적으로 한정자를 지정하지 않을 경우, 컴파일러는 모든 경우는 아니지만 대개 private 한정자를 자동으로 선택하여 적용하게 됩니다. 그리고 CLR에서는 인터페이스에 선언되는 모든 멤버들은 반드시 public 한정자만을 사용할 수 있도록 하고 있습니다. c# 컴파일러는 이를 반영하여 인터페스 내의 멤버들에 명시적으로 한정자를 지정할 수 없도록 제한합니다. 대신 인터페이스 멤버들의 접근 한정자는 자동적으로 public이 됩니다.
- 상속받은 타입에서 기본 타입에 선언된 멤버를 재정의하는 경우, C# 컴파일러는 기존 멤버의 접근성을 그대로 가져옵니다. 예를 들어 기본 클래스의 protected 메서드를 파생클래스에서 재정의한다면 재정의된 메서드의 접근 한정자 역시 protected 입니다.
  - 이는 C#의 제약사항이며 CLR에서는 재정의하는 멤버의 접근성을 상위 타입보다 더 개방할 수 있습니다.

### 정적 클래스
- Console, Math 등 인스턴스로 생성되지 않도록 보호되는 클래스들은 정적 클래스입니다. 이러한 클래스들은 반드시 정적 멤버들만을 포함할 수 있습니다.
  - static 키워드는 값 타입에 대해서는 사용할 수 없습니다. CLR은 값 타입을 항상 인스턴스로 선언하여 사용하도록 제한하였기 때문입니다.
  - 정적 클래스는 반드시 System.Object 에서만 상속을 받도록 제한되었습니다. (자동적으로 sealed, abstract 특성이 부여됩니다)
  - 정적 클래스는 인터페이스를 구현할 수 없도록 제한되었습니다. 인터페이스 메서드는 클래스의 인스턴스로 생성될 때에만 호출할 수 있기 때문입니다.
  - 정적 클래스 안에서는 필드, 메서드, 속성, 이벤트 모두 정적 멤버로 선언되어야만 합니다.
  - 정적 클래스는 필드, 메서드 매개변수, 또는 지역 변수의 타입으로 사용될 수 없습니다. 이러한 작업은 모두 클래스 인스턴스화와 연관이 있기 때문입니다.

### 부분 클래스, 부분 구조체, 부분 인터페이스
- partial 키워드를 사용하면 한 소스 코드 파일 내에서 여러 조각으로 타입의 선언을 분할하거나 여러 소스 코드 파일에 걸쳐 여러 조각으로 타입의 선언을 분할할 수 있게 합니다.

### 컴포넌트, 다형성, 버전관리
컴포넌트 소프트웨어 프로그래밍(Component Software Programming, CSP)은 객체 지향 프로그래밍(OOP)의 수준을 끌어올렸습니다. <br>
다음은 컴포넌트로서 가져야 할 성격들입니다.
- 하나의 컴포넌트(.NET Framework에서는 하나의 어셈블리)는 "출판(Published)"된 것으로 간주합니다.
- 하나의 컴포넌트에는 식별할 수 있는 아이덴티티(이름, 버전, 문화권, 그리고 공개 키)가 존재합니다.
- 하나의 컴포넌트에는 영원히 유지되는 고유한 아이덴티티가 존재합니다. 어셈블리 안에 들어있는 코드는 다른 어셈블리에 정적으로 링크되는 일이 없으며, .NET 환경에서는 항상 동적 링크만 발생합니다.
- 하나의 컴포넌트는 의지하는 다른 컴포넌트들에 대해 정확한 정보를 표시합니다.(참조 메타데이터 테이블)
- 하나의 컴포넌트는 반드시 그 안에 들어있는 클래스와 멤버들에 대해 문서를 만들 수 있어야 합니다. C#에서는 소스 코드 내부에 XML 주석을 추가하여 컴파일러의 /doc 명령 줄 스위치를 사용하여 이러한 목적을 성취할 수 있습니다.
- 하나의 컴포넌트는 반드시 필요로 하는 권한에 대해 자세히 서술하고 있어야 합니다. CLR의 코드 액세스 보안(CAS) 기능을 통해 이를 달성할 수 있습니다.
- 하나의 컴포넌트는 새로운 서비스를 제공하더라도 변하지 않는 인터페이스나 객체 모델을 제공해야 합니다. 서비스 제공이라 함은 원래의 컴포넌트 버전과 호환성을 유지할 수 있는 새로운 버전의 컴포넌트를 제공하는 것입니다.

---

C#의 각 키워드와 컴포넌트 버전 관리에 주는 영향

| C# 키워드 | 타입에 대한 적용 | 메서드/속성/이벤트에 대한 적용 | 상수/필드에 대한 적용 |
|:---: | :--- | :--- | :---: |
|abstract| 여기에 해당하는 타입은 인스턴스로 만들 수 없게 된다. | 이 키워드로 선언된 멤버가 있는 타입을 상속받은 타입이 인스턴스로 생성될 수 있도록 하기 위해서는 반드시 해당 멤버를 구현해야만 한다. | (적용 불가) |
|virtual| (적용 불가) | 이 키워드로 선언된 멤버가 있는 타입을 상속받은 타입에서 이 멤버를 재정의할 수 있다. | (적용 불가) |
|override| (적용 불가) | 기본 타입의 가상 멤버를 현재 타입에서 재정의한다. | (적용 불가) |
|sealed| 여기에 해당하는 타입은 다른 타입의 기본 타입이 될 수 없다. | 이 키워드로 선언된 멤버는 상속 이후에 재정의할 수 없다. 이 키워드는 가상 메서드를 재정의하는 메서드에 대해서만 지정할 수 있다. | (적용 불가) |
|new| 중첩 타입에 적용되는 경우, 기본 타입에 존재할 수 있는 비슷한 멤버 메서드, 속성, 이벤트, 상수, 필드와는 전혀 관계가 없음을 명시하게 된다. |  |  |

### CLR이 가상 메서드, 속성, 이벤트를 호출하는 방법
- CLR은 한 타입 내에 같은 이름의 메서드 여러 개를 서로 다른 매개변수 또는 반환 타입을 사용하여 구분하는 것을 허용합니다.
  - 하지만 C#의 경우 메서드의 반환 타입은 무시하고 매개변수 목록의 차이를 통해 고유성을 식별합니다.

컴파일러가 코드를 컴파일할 때 메서드를 메서드 정의 테이블에 항목으로 추가하며, 각 항목들이 인스턴스 메서드인지, 가상 메서드인지, 정적 메서드인지의 여부를 플래그로 기록합니다.
- CLR은 다음의 두 IL 명령어를 사용하여 메서드를 호출합니다.
  - call : 정적/인스턴스/가상 메서드를 호출하기 위해 사용될 수 있습니다. 정적메서드 호출 시, 메서드가 정의된 타입을 정확하게 지정해야 합니다. 인스턴스/가상 메서드 호출 시 객체를 가리키는 변수를 반드시 지정해야 하며 이때 해당 변수는 절대 null이 아니어야 합니다. CLR은 넘겨받은 변수의 타입을 확인하여 일치하는 메서드를 찾는 데 사용합니다. 만약 해당 타입에서 발견하지 못했다면 상속 계통을 올라가면서 탐색합니다.
  - callvirt : 인스턴스/가상/비정적 메서드 호출에 사용됩니다. 인스턴스/가상 메서드 호출시 객체애 대한 참조를 반드시 지정해야 합니다. 비가상 인스턴스 메서드를 호출할 때 넘겨받은 객체 참조 변수의 타입을 통하여 CLR이 호출할 실제 메서드를 찾습니다. 이때 해당 참조 변수는 null일 수 있습니다. JIT 컴파일러는 메서드를 호출하기 전에 객체 참조가 null인지 검증하는 절차를 거칩니다.(null 이면 오류를 던집니다) 이런 추가적인 검사과정으로 인해 callvirt는 call 보다 조금 더 느리게 동작합니다.

컴파일러는 call 명령어를 값 타입에 정의된 메서드를 호출할 때 주로 사용하는 경향이 있습니다. 값 타입은 상속이 불가능하며 null 값을 가질 수 없기 때문입니다. <br><br>
타입을 설계할 때는 반드시 정의하는 가상 메서드의 수를 최소화해야 합니다.
1. 가상 메서드는 비가상 메서드보다 호출 속도가 느리다.
2. 가상 메서드는 JIT 컴파일러에 의하여 인라인으로 번역될 수 없어 성능에 영향을 줄 수 있습니다.
3. 가상 메서드는 컴포넌트 버전 관리를 어렵게 합니다.
4. 기본 타입을 선언할 때에는 편의를 위한 오버로드 메서드들의 집합을 제공하는 것이 보편적입니다.

### 타입의 가시성과 멤버의 접근성을 지능적으로 활용하는 방법
- 타입은 가능하면 sealed 타입으로, 멤버는 가능하면 priavte으로 -> 아래의 장점이 있습니다.
  - 버전관리 : 상속이 봉인된 클래스는 추후에 봉인을 해제할 수 있습니다만, 반대의 경우는 안됩니다.
  - 성능 : sealed 타입의 경우 컴파일러가 확인해서 가상메서드를 호출할 때에도 callvirt 대신 call을 활용할 수 있습니다. (가상 메서드를 비가상 메서드처럼 호출/타입이 봉인되 있다면 상속 계통을 전부 확인할 필요가 없기 때문에)
  - 보안 향상과 예측의 용이성 : 봉인되지 않은 클래스 타입의 경우, 추후 파생클래스에서 정의된 메서드로 인해 기본 클래스의 멤버가 의도치 않게 변경될 수 있습니다.

- 오래된 객체 지향 프로그래밍에 관한 격언 : 너무 복잡해지는 것 같다면 더 많은 타입을 만들라

### 타입에 대한 버전관리와 가상 메서드 사이의 조율
...


</details>

## 7장. 상수와 필드

<details>
<summary>fold/unfold</summary>

### 상수
- 절대 변하지 않는 값에 대한 기호
- 상수 기호를 정의할 때는 그 값이 반드시 컴파일 시점에서 확인할 수 있어야 합니다. 기본 타입으로 취급될 수 있는 경우 상수로 사용할 수 있습니다.(Int32, Boolean 등)
- 상수 기호를 참조하는 코드가 있을 때, 컴파일러는 어셈블리의 메타데이터 안에 정의된 상수 기호를 검색하여 상수의 실제 값을 추출한 후 만들어진 IL 코드에 값을 직접 첨부합니다.
  - 코드에 상수 값을 직접 첨부하므로 실행 시점에 상수 값을 위해서 추가로 메모리를 할당하지 않습니다.
  - 상수 값에 대해서 주소를 얻거나 이를 참조로 지정할 수 없습니다.

## 필드
- 필드는 값 타입의 인스턴스 또는 참조 타입에 대한 참조를 저장하는 데이터 멤버입니다.

<br>
필드 한정자
<br>

| CLR 키워드 | C# 키워드 | 설명 |
| :---: | :---: | :--- |
| Static | static | 타입의 상태의 일부로서 필드가 선언되며, 객체의 상태의 일부가 되는 것과는 반대되는 개념 |
| Instance | (기본값, 생략) | 타입 인스턴스(객체)의 상태의 일부로서 필드가 선언되며, 타입 그 자체와는 무관하다. |
| InitOnly | readonly | 해당 필드는 반드시 생성자 메서드에 의해서만 초기화가 가능하다. |
| Volatile | volatile | 해당 필드는 컴파일러, CLR, 하드웨어에 의하여 이루어지는 스레드 비안정성 최적화의 대상에서 제외된다.|

* C#은 성능상의 문제 때문에 필드를 인라인 문법을 사용하여 초기화하는 것과 생성자 안에서 대입 문법을 사용하여 초기화하는 것에 차등을 두고 있습니다.(8장에서 자세히)


</details>


## 8장. 메서드

<details>
<summary>fold/unfold</summary>

### 인스턴스 생성자와 클래스(참조 타입)
- 생성자는 특별한 유형의 메서드로 타입의 인스턴스를 올바른 상태로 초기화하는 것을 돕습니다. .ctor라는 이름으로 메타데이터에 등록됩니다.
- 참조 타입으로 객체의 인스턴스를 생성하면, 인스턴스의 데이터 필드들을 저장하기 위해서 메모리가 할당되는데, 먼저 객체의 오버헤드 필드(타입 객체 포인터, 동기화 블록 인덱스)가 초기화되고, 그 다음으로 타입의 인스턴스 생성자가 호출됩니다.
  - 인스턴스 생성자는 재정의할 수 없습니다.
  - 클래스를 abstract로 선언하면 컴파일러는 기본 생성자를 protected로 선언하며, 그렇지 않은 경우에는 public으로 선언된 것으로 간주합니다.
  - C# 컴파일러는 상속한 클래스가 명시적으로 기본 클래스의 생성자를 호출하지 않으면, 기본 클래스 생성자를 자동으로 호출하도록 코드를 생성합니다.

- 특별한 상황에서는 타입의 인스턴스 생성자가 호출되지 않고도, 해당 타입의 인스턴스가 생성될 수 있습니다.
  - Object 타입의 MemberwiseClone 메서드를 호출하여 메모리를 할당하고, 객체의 오버헤드 필드를 초기화한 다음, 원본 객체의 바이트들을 새 객체로 직접 복사해 넣습니다.
  - 또한 런타임 Serialization을 통하여 만들어진 데이터를 deserialization하는 경우에도 생성자 호출이 별도로 이루어지지 않습니다.

- 생성자에서 가상 메서드를 호출하지 않습니다. 하위 타입 멤버의 초기화가 덜 끝난 상태에서 재정의된 메서드를 호출한다면 의도하지 않은 결과가 나타날 수 있습니다.
  - C#에서는 객체 멤버에 대해서 인라인 초기화 문구가 작성되어져 있다면, 생성자를 호출하기 전에 해당 멤버에 초기화 데이터를 대입하게 됩니다.

```cs
        //만약 인스턴스 필드를 초기화하는 인라인 코드가 여럿 있고, 오버로드된 생성자를 많이 만들어야 한다면, 
        //필드 초기화 구문 대신, 공통적인 초기화 작업을 수행하는 단일의 생성자를 생성하는 것이 좋습니다.
        class SomeType
        {
            //인라인 초기화 구문은 전부 제거
            private int x;
            private string s;
            private double d;
            private byte b;

            // 기본 생성자에서는 모든 필드를 기본값으로 설정하고 있습니다.
            // 나머지 다른 생성자들은 이 생성자를 명시적으로 호출합니다.
            public SomeType()
            {
                x = 5;
                s = "Hi, There";
                d = 3.1459;
                b = 0xff;
            }

            public SomeType(int x) : this()
            {
                this.x = x;
            }

            public SomeType(string s) : this()
            {
                this.s = s;
            }
        }
```

### 인스턴스 생성자와 구조체(값 타입)
- CLR 에서는 값 타입의 인스턴스를 언제든 생성할 수 있도록 허용므로 값 타입은 내부에 생성자를 정의할 필요가 없습니다. C# 컴파일러에는 값 타입에 대해서는 매개변수가 없는 기본 생성자 코드를 생성하지 않습니다.
  - 컴파일러가 값 타입의 기본 생성자를 자동으로 생성해줄 것처럼 예상할 수도 있지만 사실 애플리케이션의 성능을 개선하기 위해서 c# 은 자동으로 생성자를 작성하지 않습니다.
  - 따라서 컴파일러는 애당초 생성자를 자동으로 호출해야 할 의무가 사라지게 됩니다.
- 신뢰할 수 있는 코드를 위하여 값 타입의 모든 필드들은 읽기 작업을 수행하기 전에 반드시 쓰기 작업을 한번 거쳐야 합니다. 따라서 생성자는 반드시 해당 타입 내의 모든 필드들을 명시적으로 초기화해줘야 합니다.

```cs
        struct widget
        {
            public int x, y, z, w;

            //문제 없이 컴파일됩니다.
            public widget(int x)
            {
                //참조 타입에서 this는 읽기 전용이지만, 값 타입에서는 this가 인스턴스 그 자체를 나타내며 새 인스턴스를 대입하는 것이 가능
                this = new widget();
                this.x = x;
            }


            //모든 필드를 초기화하지 않는 경우. -> 컴파일 X
            public widget(int x, int y)
            {
                this.x = x;
                this.y = y;
            }
        }
```

### 타입 생성자
- 타입 생성자는 static 키워드를 사용해서 정의되며 C# 에 의해 자동으로 private으로 지정됩니다. (외부에서 임의로 호출되지 못하도록 보호)
- JIT 컴파일러가 메서드를 컴파일 할 때 메서드 내의 코드가 어떤 타입들을 참조하는지 확인합니다. 만약 타입 생성자를 정의하고 있는 타입을 참조하고 있다면, JIT 컴파일러는 이 타입의 타입 생성자가 현재의 앱 도메인에서 실행된 적이 있는지 검사합니다. 만약 한 번도 실행되지 않았다면 JIT 컴파일러는 타입 생성자를 호출하는 코드를 네이티브 코드에 추가합니다.
  - 컴파일된 코드를 스레드가 실행할 때 여러 스레드가 동시에 타입 생성자를 실행하는 경우를 방지하기 위해 이 메서드를 호출하는 스레드가 상호 배타적인 락을 획득할 수 있도록 요구합니다. 
  - 정적 생성자는 CLR이 앱 도메인 당 단 한 번씩만 수행할 수 있도록 스레드 안정성을 보장하기 때문에 필요하다면 싱글톤 객체를 초기화 하기에 최적의 위치라고 할 수 있습니다.

```cs
        struct SomeValueType
        {
            // C#은 값 타입에 대해 매개변수 없는 값 타입 생성자를 정의할 수 있도록 허용합니다.
            // 하지만 CLR은 값 타입의 정적타입 생성자를 호출하지 않습니다.
            static SomeValueType()
            {
                Console.WriteLine("This never gets displayed");
            }
        }
        class SomeRefType
        {
            static SomeRefType()
            {
                //해당 타입을 처음 사용하는 경우 실행됩니다.
                Console.WriteLine("SomeRefType type ctor");
            }
        }

```
- 타입 생성자로 생성된 타입 객체의 경우 앱도메인이 언로드하는 경우에만 가비지 컬렉터의 수거대상이 됩니다.
  - CLR은 따로 정적 소멸자를 지원하지 않습니다. 

### 연산자 오버로드 메서드
- CLR에서는 연산자 오버로딩 개념이 존재하지 않습니다. 또한 연산자라는 개념 역시 없습니다. C#에서는 연산자를 대응되는 다른 이름의 메서드로 치환해서 사용합니다.
  - C#에서 +는 op_UnaryPlus, -는 op_UnaryNegation 등으로 호환되는 메서드가 존재합니다. 해당 메서드들은 specialname 플래그 셋을 포함하며, 만약 플래그가 true 이면 연산자 오버로딩에 활용되는 것을 나타냅니다.
  - CLR에서는 연산자 오버로드는 반드시 public 접근자를 사용하면서 정적 메서드로 사용되어야 합니다.


### 변환 연산자 메서드
- 변환 연산자(Conversion method)는 어떤 타입에서 다른 타입으로의 변환을 담당하는 메서드입니다.
  - 변환 연산자는 명시적(explicit)/암시적(implicit) 연산을 구현할 수 있습니다.
  - 자릿수나 정밀도에 손상을 주거나 정보를 잃어버리는 변환의 경우, 암시적 변환보다 명시적 변환 연산을 활용하는 것이 좋습니다.
  - is/as 연산자는 변환 연산자 메서드를 호출하지 않습니다.

### 확장 메서드
- 확장 메서드는 사용자가 정의한 정적 메서드를 인스턴스 메서드의 일부인 것처럼 보이게 합니다.
  - 컴파일러가 메서드를 바인딩할 때, 특정 메서드에 해당하는 인스턴스 메서드가 있을 경우, 컴파일러는 해당 메서드를 호출하는 IL 코드를 만들어냅니다. 하지만 인스턴스 메서드가 없는 경우, 컴파일러는 첫 번째 매개변수로 호출하려는 대상 타입의 인스턴스를 받는 정적 메서드를 포함하는 정적 클래스가 있는지 확인합니다. 이때 첫 번재 인자는 반드시 this 키워드로 표시되어야 합니다.
- 확장 메서드는(첫 번째 매ㅐ개변수에 this 키워드가 붙는 메서드)는 반드시 제네릭이 아닌 정적 클래스 위에서 정의되어야만 합니다.
- 확장 메서드는 단순히 정적 메서드에 대한 호출에 불과하기 때문에 CLR은 호출 과정에서 전달되는 객체가 null인지 검사하는 코드를 내보내지 않습니다.
- 정적 클래스의 이름은 임의로 작명할 수 있기 때문에 C# 컴파일러는 파일 수준의 모든 정적 클래스를 확인해야 하며 확장 메서드를 찾는데 시간이 필요합니다.
  - 검색 성능을 개선하기 위해 c# 컴파일러는 확장 메서드에 ExtensionAttribute를 내부적으로 추가합니다. 더 나아가 확장 메서드를 하나라도 포함하고 있는 정적 클래스/어셈블리에도 해당 특성이 추가됩니다. 컴파일러는 해당 특성이 부여된 정적 클래스/메서드들을 확인해나가면서 검색의 범위를 좁힙니다.

### 부분 메서드
...

</details>

## 9장. 매개변수

<details>
<summary>fold/unfold</summary>

### 선택적 매개변수와 명명된 매개변수
...
- 메서드로 매개변수를 전달할 때, 컴파일러는 각각의 매개변수에 대한 식을 왼쪽에서 오른쪽의 순서로 평가합니다.
- 매개변수에 지정하는 기본값들은 모두 컴파일 시점에서 알 수 있는 상수 값이어야 합니다.
- 모듈 외부에서 불리는 메서드의 매개변수의 기본값을 바꾸는 것은 위험성을 내포합니다. 호출하는 측의 코드가 재컴파일 되지 않는다면 이전에 사용되던 매개변수의 기본값을 그대로 사용하게 됩니다.

```cs
        //이 방법은 위험합니다.
        private static string MakePath(string fileName = "Untitled")
        {
            return string.Format(@"C:\{0}.txt", fileName);
        }

        //대신 이렇게 하는 것이 좋습니다.
        private static string MakePath(string filename = null)
        {
            return string.Format(@"C:\{0}.txt", filename ?? "Untitled");
        }

```
<br>
- ref, out 키워드를 사용하는 매개변수에는 기본값을 지정할 수 없습니다.
- c#의 경우 선택적 매개변수에 기본값을 지정할 경우, 컴파일러가 내부적으로 System.Runtime.InteropServices.OptionalAttribute 특성을 해당 매개변수에 자동으로 붙이고 메타데이터에 기록합니다.
  - 추가적으로 System.Runtime.InteropServices.DefaultParameterValueAttribute 특성을 해당 매개변수에 붙이고 메타데이터에 기록합니다. 이후에 DefaultParameterValueAttribute 특성의 생성자에는 소스 코드상에서 지정한 기본 상수 값을 전달합니다.


### 암시적으로 타입화된 지역 변수
...

### 메서드에 참조로 매개변수 전달
- out/ref 키워드는 매개변수로 넘겨받은 변수의 레퍼런스를 전달합니다.
- CLR에서 두 키워드는 동일한 의미를 가집니다. 하지만 C# 컴파일러는 두 키워드를 엄격하게 구분합니다.
  - ref 매개변수를 전달하기 전에 해당 변수는 초기화가 되어 있어야 하지만, out 매개변수로 전달될 때는 초기화 되어있을 필요가 없습니다.
- out 과 ref 키워드 간 오버로딩은 지원되지 않습니다. 메타데이터 관점에서는 out과 ref 키워드간의 차이가 없기 때문입니다.

### 메서드에 가변 매개변수 전달하기
- params 키워드는 메서드에 전달하는 인자의 개수를 가변적으로 취합니다.
  - 해당 키워드는 컴파일러가 System.ParamArrayAttribute 특성을 해당 매개변수에 붙이도록 지시합니다.

- null을 전달하지 않는 이상 params 키워드는 성능적 오버헤드가 존재합니다. 가변 매개변수를 위해 힙 상에는 배열 객체가 생성되어야 합니다.
  - 성능상의 손해를 최소화하고 싶다면 적절한 오버로딩 버전을 준비합시다.

### 매개변수 타입과 반환 타입에 대한 지침
...

### 상수화
- CLR은 매개변수를 상수로 선언하는 기능을 지원하지 않습니다.
- 마이크로소프트가 상수화된 객체나 매개변수가 변경되지 않았음을 검증하는 기능을 CLR에 추가하기는 매우 어렵습니다. 이를 가능하게 하려면 CLR은 상수화된 객체에 대해 쓰기 작업이 발생하지 않는지 매번 확인해야하며 이는 곧 성능상의 오버헤드가 됩니다. 또한 이러한 검증 과정은 개발자들에게 수 많은 복잡성을 가중시키게 됩니다.
  - 이러한 이유로 CLR은 객체나 매개변수에 대한 상수화를 지원하지 않습니다.

#### 스터디
- in, out, ref 키워드의 사용
  - 매개변수로 참조를 전달할 때 사용한다. 값 타입도 박싱이 일어나지 않습니다.
  - in :내부에서 참조 변경을 불가능하게 할 때 사용한다.
  - out : 할당되지 않은 변수를 전달해서, 내부에서 할당할 때 사용한다.

- multiple Return : Tuple vs out
  - Tuple이 편하지만, 패턴에 따라 out을 사용해 구현하는 것이 편한 경우도 있다.( TryGet 등… ), async 메서드는 out 사용하지 못합니다.

- 기본 매개변수는 사용하지 않는 것을 권장. 메서드 오버로딩이 충분한 대안이 될 수 있으며, 기본 매개변수로 인한 부작용이 나타날 수 있기 때문


</details>

## 10장. 속성

<details>
<summary>fold/unfold</summary>

- 속성은 메서드를 소스 코드상에서 호출하는 방법을 단순하게 만들어줍니다. CLR에서는 두 가지 유형의 속성을 지원하는데 매개변수를 포함하는 속성(인덱서)와 매개변수를 받지 않는 속성(기본 속성Default Property)로 분류됩니다.

### 매개변수가 없는 속성
- C#은 속성에 대한 지원을 내장하고 있습니다. C# 컴파일러가 속성으로부터 값을 가져오거나 설정하려는 코드를 만나면, 컴파일러는 적절한 메서드를 호출하는 코드로 이를 변경합니다.
- C# 컴파일러는 접근자 메서드를 만드는 것에 더하여 소스 코드상의 각 속성에 대한 정의 항목을 어셈블리의 메타데이터에 추가합니다.
  - 이 항목에는 속성 자체에 대한 몇 가지 플래그와 속성의 타입, get과 set 접근자 메서드에 댛나 참조를 포함합니다.
- 속성을 구현하면서 get/set 메서드의 구현부를 생략하면 C# 컴파일러는 자동으로 속성과 연결되는 private 필드(지원 필드backing field)를 정의해 줍니다.

<br>

필드와 속성의 차이
- 속성은 마치 필드처럼 보이지만 사실은 메서드입니다.
- 속성은 읽기 전용일 수 있지만 필드에 대한 접근은 항상 읽기와 쓰기가 모두 가능합니다.
- 속성 메서드는 예외를 발생시킬 수 있지만 필드에 대한 접근은 절대 그럴 일이 없습니다.
- 속성을 메서드에 out이나 ref 매개변수로 전달할 수는 없지만, 필드로는 그렇게 할 수 있습니다.
- 속성 메서드는 실행하는 데 시간이 오래 걸릴 수 있지만 필드에 대한 접근은 언제나 신속하게 실행됩니다.
- 만약 속성을 한 줄에서 여러 번 호출하면, 속성 메서드는 매번 다른 값을 반환할 수 있지만, 필드는 항상 같은 값을 반환합니다.
- 속성의 접근자 메서드는 객체의 상태와는 무관하게 추가적인 메모리를 필요로 하거나 속성을 포함하는 객체의 상태와는 무관한 다른 객체를 반환할 수도 있습니다.

<br>

#### 객체와 컬렉션 이니셜라이저
```cs
        public class Cat
        {
            // Auto-implemented properties.
            public int Age { get; set; }
            public string Name { get; set; }

            public Cat()
            {
                Console.WriteLine("Cat Contructor");
            }

            public Cat(string name)
            {
                Console.WriteLine("Cat Contructor with name");

                this.Name = name;
            }
        }

        public static void Main()
        {
            Cat cat = new Cat { Age = 10, Name = "Fluffy" };
            Cat sameCat = new Cat("Fluffy") { Age = 10 };
        }
```

- 컬렉션 이니셜라이저의 경우, 특정 타입이 IEnumerable 인터페이스와 Add() 메서드를 구현하고 있어야 합니다.


#### 기타
- new Tupel<> -> 튜플 클래스 타입, (value, value) -> 튜플 구조체 타입
- (value, value) 형식은 튜플 디스트럭션등의 편리한 기능도 있다.


</details>

## 11장. 이벤트

<details>
<summary>fold/unfold</summary>

이벤트 멤버를 타입 내에 정의한다는 것은 다음의 기능을 제공하는 것입니다.
- 관심 있는 이벤트의 메서드를 등록할 수 있습니다.
- 관심 있는 이벤트로부터 메서드를 등록 해제할 수 있습니다.
- 이벤트가 발생하면 등록된 메서드들에 이벤트가 발생하였음을 알려줍니다.

<br>

CLR의 이벤트 모델은 델리게이트(Delegate)에 기반을 두고 있습니다. 델리게이트는 타입 안정성을 유지한 채로 콜백 메서드를 호출하는 방법입니다. 콜백 메서드는 이벤트를 수신하려는 객체가 이벤트가 발생했음을 알아내기 위해 사용됩니다.

### 이벤트를 노출하는 타입을 설계하기
...
(예제 코드 위주로 설명하는 장)
- 이벤트 패턴은 모든 이벤트 핸들러들의 반환 타입을 void로 정의합니다. 이벤트가 발생하였을 때 여러 개의 콜백 메서드를 호출해야 할 수 있으며, 이 모든 콜백 메서드로 반환 값을 받을 방법이 없기 때문입니다.

### 컴파일러가 이벤트를 구현하는 방법
```cs
public class NewMailEventArgs : EventArgs {}
public class MailManager
{
    public event EventHandler<NewMailEventArgs> NewMail;
}
```
위의 코드는 컴파일러가 아래처럼 바뀝니다.
- event 에 델리게이트를 추가하거나 제거하는 과정은 스레드 안정적으로 설계되었습니다. 29장 타입에 상관없이 Interlocked를 요소를 사용하기 위한 패턴 참조.
- 만약 등록한 적이 없는 메서드를 제거하려 하면 Delegate 의 Remove 메서드는 아무런 작업도 수행하지 않습니다. 이 단계에서 어떠한 예외나 경고도 유발하지 않으며 컬렉션의 내용도 그대로 유지됩니다.
- c# 컴팡일러는 이벤트를 기본 지원하기 때문에, 외부코드에서 이벤트 객체에 대해 += /-= 연산자를 사용하면 컴파일러는 이를 add_'EventName' / remove_'EventName' 으로 변경합니다.

```cs
public class MailManager2
{
    //1. private 으로 델리게이트 필드를 생성하여 null로 초기화한다.
    private EventHandler<NewMailEventArgs> NewMail = null;

    //2. public 으로 'add_이벤트명' 메서드를 추가하여 이벤트에 메서드를 등록할 수 있게 해준다.
    public void add_NewMail(EventHandler<NewMailEventArgs> value)
    {
        //반복문과 CompareExchange 메서드를 이용하여 스레드 안정적으로 델리게이트를 추가한다.
        EventHandler<NewMailEventArgs> prevHandler;
        EventHandler<NewMailEventArgs> newMail = this.NewMail;
        do
        {
            prevHandler = newMail;
            EventHandler<NewMailEventArgs> newHandler =
                (EventHandler<NewMailEventArgs>) Delegate.Combine(prevHandler, value);
            newMail = Interlocked.CompareExchange(ref this.NewMail, newHandler, prevHandler);
        } while (newMail != prevHandler);
    }

    //3. public으로 'remove_이벤트명' 메서드를 추가하여 이벤트로부터 메서드를 제거할 수 있게 해준다.
    public void remove_NewMail(EventHandler<NewMailEventArgs> value)
    {
        //반복문과 CompareExchange 메서드를 추가하여 스레드 안정적으로 델리게이트를 제거한다.
        EventHandler<NewMailEventArgs> prevHandler;
        EventHandler<NewMailEventArgs> newMail = this.NewMail;
        do
        {
            prevHandler = newMail;
            EventHandler<NewMailEventArgs> newHandler =
                (EventHandler<NewMailEventArgs>)Delegate.Remove(prevHandler, value);
            newMail = Interlocked.CompareExchange(ref this.NewMail, newHandler, prevHandler);
        } while (newMail != prevHandler);
    }
}
```

### 이벤트가 기다리는 타입 설계하기
...

### 명시적 이벤트 구현
...
실제로 이벤트를 구현하는 코드 작성(예제 코드는 책에서 참고)

</details>

## 12장. 제네릭

<details>
<summary>fold/unfold</summary>

제네릭(Generics)은 CLR과 CLR이 지원하는 언어들이 제공하는 다른 형태의 매커니즘으로서, 이를 통해 또 다른 코드 재사용 방식인 알고리즘 재사용을 수행할 수 있습니다.
- `List<T>` 를 예로 들때 T와 같이 데이터 타입으로 지정하는 변수를 타입 매개변수(type parameter)라고 합니다. 사용자 입장에서 제네릭 타입이나 제네릭 메서드를 활용할 때 지정하는 데이터 타입을 타입 인자(type argument)라고 합니다.

제네릭은 개발자들에게 여러 이점을 제공합니다.
- 소스 코드 보호 : 제네릭 알고리즘을 사용하기 위해서 알고리즘을 구현하고 있는 소스 코드가 반드시 필요한 것은 아닙니다. 반면에 c++ 템플릿의 경우, 템플릿 기반의 알고리즘을 사용하려면, 반드시 이를 구현하고 있는 소스 코드가 필요합니다.
- 타입 안정성 : 특정한 데이터 타입을 타입 인자로 지정하여 제네릭 알고리즘을 사용하면 컴파일러와 CLR은 지정된 데이터 타입과 호황된느 타입에 대해서만 해당 알고리즘을 사용할 수 있습니다. 
- 간결한 코드 : 컴파일러가 타입 안정성을 강력하게 검사하기 때문에 소스 코드 내에 캐스팅이 거의 필요하지 않아 코드를 좀더 작성하기 쉽고, 이해하기 쉽고, 유지 보수하기도 쉽게 됩니다.
- 더 나은 성능 : 제네릭 도입 이전에는 일반화된 알고리즘을 정의하기 위해서 모든 멤버들을 Object 타입으로 다루어야함 했습니다. 하지만 제네릭을 활용하게 된 뒤로 이 문제가 해결되었으며 값 타입을 사용하더라도 박싱이 발생하지 않습니다.


### Framework Class Library 에서의 제네릭

### 제네릭 하부 구조

### 제네릭 인터페이스

### 제네릭 델리게이트

### 공변성과 반공변성 타입 매개변수를 사용하는 델리게이트와 인터페이스

### 제네릭 메서드

### 제네릭 기타 멤버들

### 검증 가능성과 제약조건


</details>

## 26장. 스레드의 기본

<details>
<summary>fold/unfold</summary>

### 윈도우는 왜 스레드를 지원하는가?
...

### 스레드의 비용
모든 스레드는 아래에 나열한 것들을 하나씩 가지고 있습니다.
- 스레드 커널 객체 : os는 시스템 내에서 생성되는 개별 스레드별로 고유의 데이터 구조체를 할당하고 초기화합니다. 이 구조체는 스레드를 나타내는 여러 속성들을 가지고 있으며 그 중에는 스레드의 컨텍스트라고 불리는 정보도 있습니다.
- 스레드 환경 블록(Thread environment block, TEB) : TEB는 유저 모드(응용 프로그램이 빠르게 접근할 수 있는 주소 공간)에 할당되고 초기화되는 메모리 블록입니다.
- 유저 모드 스택 : 지역 변수와 함수의 매개변수를 저장할 용도로 사용되며, 현재 수행 중인 함수가 반환될 때 그 다음으로 수행해야 할 위치를 저장합니다. 윈도우 os는 기본적으로 각각의 스레드에 대해서 유저모드 스택 1MB를 할당합니다.
- 커널 모드 스택 : 응용프로그램이 os의 커널 모드 함수로 매개변수를 전달해야 할 때 사용됩니다. 보안상의 이유로 유저 모드 코드에서 커널 모드로 매개변수를 전달할 때 유저 모드 스택의 내용을 커널 모드 스택으로 복사해서 넘겨줍니다. 응용프로그램은 커널 모드 스택에 접근을 못하기 때문에 커널 코드는 안전하게 동작을 수행합니다.
- DLL의 스레드 attach/detach 통지 : 윈도우 os는 프로세스 내에서 새 스레드가 생성되면 해당 프로세스의 메모리 공간에 로드된 모든 비관리 DLL들의 DllMain 함수를 DLL_THREAD_ATTACH 플래그를 매개변수로 호출합니다. 스레드가 종료될 때는 마찬가지로 DllMain 함수를 DLL_THREAD_DETACH 플래그를 매개변수로 호출합니다.

특정 시간에 윈도우 운영체제는 하나의 CPU에 하나의 스레드를 할당합니다. 스레드는 주어진 타임 슬라이스(time-slice 혹은 퀀텀(Quantum))동안만 수행됩니다. 스레드가 타임 슬라이스 만큼 수행을 완료하고 나면, 다른 스레드로 컨텍스트를 전환합니다.
<br>
컨텍스트를 전환할 때 os 는 아래의 동작을 수행합니다.
1. cpu 레지스터의 값을 현재 수행 중인 스레드의 컨텍스트 구조체에 저장합니다. 컨텍스트 구조체는 스레드 커널 객체 내부에 있습니다.
2. 여러 스레드들 중 다음 번에 수행할 스레드를 선택합니다. 만일 선택된 스레드가 다른 프로세스에 속해 있다면 (프로세스간 컨텍스트 스위치 수행) 스레드가 수행할 코드와 데이터가 접근하기 위해 가상 메모리 주소를 먼저 전환합니다.
3. 선택된 스레드의 컨텍스트 구조체 내의 값을 cpu 레지스터로 로드합니다.

컨텍스트 스위칭은 순전히 오버헤드에 해당하는 작업입니다. 하지만 이를 통해 좀 더 견고하고 사용자에게 응답성이 좋은 운영체제를 구현할 수 있습니다.
- 어떤 프로그램이 실행 중에 무한루프에 빠졌다고 해봅시다. 컨텍스트 스위칭이 없다면 해당 무한루프에서 빠져나올 방법이 없습니다. 하지만 일정시간마다 os는 컨텍스트 스위칭을 통해서 작업 관리자와 같은 새로운 스레드에게 cpu를 할당할 수 있으며 사용자는 작업 관리자를 활용해서 무한 루프에 빠진 프로그램을 종료시키고 다시 작업을 할 수 있을 것입니다.
- 추가적으로 가비지 컬렉션이 호출될 때 CLR은 모드 스레드를 일시 정지시킵니다. 그 후 힙 내의 객체를 마크하기 위해 모든 스레드의 스택을 추적해 루트 객체를 찾아야 하고, 컴팩트 작업이 완료되면 스택 내의 루트를 갱신한 후에야(메모리 위치가 바뀌므로) 비로소 스레드를 재개할 수 있습니다.
- 응용프로그램을 디버깅 할때 중단점에 다다를 경우 모든 스레드가 일시 정지됩니다. 이런 특징 탓에 스레드 개수가 많다면 디버깅 속도가 느려지게 됩니다.

### 바보짓은 이제 그만
...

### CPU 트렌드
...

### CLR 스레드와 윈도우 스레드
...

### 계산 중심의 비동기 작업을 수행하기 위해서 전용 스레드 사용하기
보통 상태가 아니라 특수한 용도를 위한 스레드가 필요한 경우가 있습니다.
- 보통 스레드 우선순위가 아닌 스레드가 필요한 경우. 스레드 풀 내의 모든 스레드는 보통 우선순위를 가지며 임의로 바꿀 수 있긴 하지만 권장되지 않습니다. 우선순위를 바꾼다 하더라도 스레드 풀 작업중에 바뀐 우선순위가 계속 유지되는 것도 아닙니다.
- 포그라운드 스레드처럼 동작하는 스레드가 필요한 경우, 이 스레드가 작업을 완료하면 응용 프로그램이 종료되거나 종료되지 않을 것을 보장하기 위해 필요합니다. 스레드 풀의 모든 스레드는 백그라운드 스레드이므로 CLR이 프로세스를 종료하려 하면, 수행 중이던 작업을 완료하지 못할 수도 있습니다.
- 계산 중심의 작업이 상당히 오랫동안 수행되어야 할 때, 스레드 풀을 이용하는 경우 추가 스레드를 생성할지 여부를 사용자가 결정할 수 없습니다.
- 스레드를 명시적으로 수행하거나 Thread의 Abort 메서드를 호출하여 스레드를 강제로 종료하는 것이 가능해야 하는 경우.

<br>
Join 메서드는 호출한 스레드 객체가 파괴되거나 종료될 때까지 이 메서드를 호출한 스레드를 중단시킵니다. 비동기적으로 갈라져나간 프로그램 흐름을 다시 합칠 수 있습니다.

### 여러 스레드를 사용하는 이유
- 응답성(클라이언트 측 gui 응용 프로그램에 대해서) : 윈도우 os는 각 프로세스별로 전용의 스레드를 할당하여 응용프로그램이 무한 루프에 빠지더라도 사용자가 다른 응용프로그램까지 사용하지 못 하는 상황을 미연에 방지하고 있습니다. 다수의 스레드를 활용하는 것은 시스템의 리소스를 낭비하고 성능에 좋지 않은 영향을 끼칠 수 있지만, 사용자에게는 응답성이 좋은 인터페이스를 제공할 수 있습니다.
- 성능(클라이언트 측, 서버 측 응용 프로그램에 대해서)

### 스레드 스케줄링과 우선순위
- 앞서 모든 스레드들은 커널 객체 내부에 컨텍스트 구조체를 포함하고 있다고 설명한 바 있는데, 이 컨텍스트 구조체에는 스레드가 마지막으로 수행되었던 CPU 레지스터의 상태 정보를 가지고 있습니다. 운영체제가 주어진 타임 슬라이스 만큼 특정 스레드를 수행하고 나면 현존하는 모든 커널 객체들 중 다른 작업이 완료되기를 기다리지 않는 스케줄 가능 스레드가 있는지 확인하게 되고, 이 중 하나를 선택해서 컨텍스트 전환을 수행합니다.
<br>

- 모든 스레드는 0(가장 낮은)에서 31(가장 높은)까지 우선순위 레벨을 할당받게 됩니다. (31의 우선순위를 가진 스레드가 있으면 해당 스레드를 가장 먼저 처리)
  - 이때 31 우선순위를 가진 스레드를 처리할 때 더 낮은 우선순위의 스레드에게는 cpu를 할당하지 않는데 이를 `기아 상태starvation` 이라고 부릅니다.

<br>

- 프로세스 우선순위 클래스의 역할을 혼돈할 수 있습니다. 윈도우 운영체제는 프로세스가 아니라 스레드를 스케쥴링의 대상으로 지정합니다. 프로세스 우선순위 클래스는 수행 중인 응용프로그램 간에 우선순위를 구성할 목적으로 만들어낸 추상화된 개념이며 다른 목적은 가지고 있지 않습니다.

### 포그라운드 스레드와 백그라운드 스레드
- CLR은 모든 스레드를 포그라운드 스레드나 백그라운드 스레드 중 하나로 간주합니다. 프로세스의 모든 포그라운드 스레드가 종료되면 CLR은 수행 중인 백그라운드 스레드들을 모두 강제로 종료시키려 합니다. 그렇게 되면 백그라운드 스레드는 아무런 예외를 발생시키지 않고 즉각 종료됩니다.
  - 따라서 메모리 버퍼의 내용을 디스크의 쓰는 것과 같이 반드시 완료해야 하는 작업은 포그라운드 스레드를 활용해야 합니다. 그렇지 않고 표 계산 프로그램에서의 셀 연산식 같이 덜 중요한 작업의 경우에는 백그라운드 스레드를 사용하는 것이 좋습니다. 이러한 작업들은 응용 프로그램이 재시작된 이후에 수행 중이던 작업을 다시 수행해도 되므로 사용자가 작업을 중단하려는 상황에서까지 작업을 끝까지 완료하려고 노력할 필요가 없습니다.
<br>
- 스레드가 살아있는 동안 포그라운드 스레드를 백그라운드 스레드로 변경하거나 그 반대로 변경하는 것은 언제든지 가능합니다. 응용 프로그램의 주 스레드와 Thread 객체를 명시적으로 생성하여 만들어진 스레드는 기본적으로 포그라운드 스레드로 동작합니다. 반면 스레드 풀 내의 스레드는 백그라운드 스레드로 동작합니다. 또한 네이티브 코드에 의해서 생성되어 관리 수행 환경으로 진입한 스레드들도 모두 백그라운드 스레드로 동작합니다.

</details>

## 27장. 계산 중심의 비동기 작업

<details>
<summary>fold/unfold</summary>

### CLR의 스레드 풀 소개
- CLR은 고유의 스레드 풀을 관리하는 코드를 가지고 있습니다. 스레드 풀은 응용 프로그램에서 활용할 수 있는 일련의 스레드의 집합이며 CLR 별로 하나씩 생성됩니다.
- CLR이 초기화되는 시점에 스레드 풀에는 어떤 스레드도 존재하지 않습니다. 내부적으로 스레드 풀은 작업 요청을 수신하기 위한 큐를 가지고 있어서 응용프로그램이 비동기 작업을 수행하려는 경우 이 큐에 작업 수행을 위한 항목을 추가하는 함수를 호출합니다. 스레드 풀은 큐에 추가된 항목을 가져와서 스레드 풀 내에 존재하는 스레드로 전달하는 역할을 수행하는데, 만일 스레드 풀에 스레드가 없다면 새로운 스레드를 생성합니다.
  - 스레드를 생성하게 되면 성능에 좋지 않은 영향을 끼칠 수 있지만, 스레드 풀 내의 스레드가 작업을 완료하게 되면 생성한 스레드를 파괴하지 않고 스레드 풀로 반납합니다. 반납된 스레드는 다른 요청이 있을 때까지 유휴Idle 상태를 유지하게 됩니다. 스레드를 파괴하지 않기 때문에 추가적으로 성능에 영향을 미치지는 않습니다.
    - 스레드 풀에 다수의 스레드가 Idle 상태로 남아 있다면 메모리를 낭비하는 상황이 됩니다. 스레드 풀은 풀 내의 스레드가 특정 시간 동안 계속 Idle 상태에 머물러 있다면, 스레드 풀은 이 같은 스레드를 깨워서 자기 자신을 종료하도록 하여 리소스를 해제합니다.
  - 스레드 풀은 응용 프로그램의 작업을 큐잉하는 속도가 스레드 풀 내의 스레드가 작업을 처리하는 속도보다 현저히 빠른 경우 추가적으로 스레드를 생성합니다.

### 단순한 계산 중심 작업의 수행
...

### 실행 컨텍스트
- 모든 스레드는 각자 실행 컨텍스트(Execution Contexts)라는 데이터 구조체를 가지고 있스빈다. 이 실행 컨텍스트에는 보안 설정(압축 스택, 스레드의 Principal 속성, 윈도우즈 아이덴티티(Windows Identity)), 호스트 설정(System.Threading.HostExecutionContextManager), 논리 호출 컨텍스트 데이터(Logical call context data, System.Runtime.Remoting.Messaging.CallContext 의 LogicalSetData/LogicalGetData)가 포함되어 있습니다.
...

### 협조적 취소와 타임아웃
- .NET Framework 은 작업 취소를 위한 표준화된 패턴을 제공하고 있는데 이를 혀조적 취소 패턴(cooperative cancellation)이라 합니다.
- CancellationToken 을 활용합니다.
  - [마이크로소프트 CancellationTokenSource](https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.cancellationtokensource?view=net-5.0)
  - [마이크로소프트 CancellationToken](https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.cancellationtoken?view=net-5.0)
- Regist로 취소될 때 호출될 델리게이트를 등록할 수 있으며, CreateLinkedToken으로 특정 토큰이 취소될 때 자동으로 취소될 연결될 토큰을 생성할 수 있습니다.

### 태스크
- 계산 중심의 비동기 작업을 수행하기 위해서 ThreadPool의 QueueUserWorkItem을 호출하는 방식은 간단한 방법이긴 하지만 많은 제약사항을 가지고 있다. 가장 큰 문제점은 작업 완료 시점과 작업 수행 결과를 얻을 수 있는 방법을 제공하지 않는다는 것입니다.
  - 이러한 제약을 극복하기 위해서 마이크로소프트는 태스크(task)라는 개념을 도입하였습니다.

<br>

- 태스크가 완료될 때까지 대기하여 그 결과를 얻을 수 있습니다.(wait, waitany, waitall 등)
  - Task.wait 메서드를 호출하게 되면 시스템은 대기하려는 태스크가 이미 수행이 시작되었는지 확인합니다. 수행이 시작되었다면 태스크가 완료될 때까지 Wait메서드를 호출한 스레드를 멈추지만, 만약 수행이 시작되기 전이라면, 태스크를 호출한 스레드를 멈추게 하지 않고 해당 스레드로 태스크를 수행한 뒤 결과값을 반환합니다. 해당 방식을 통해 리소스를 절약하는 효과를 볼 수 있습니다.

<br>

- AggregationException 은 애플리케이션을 실행하는 동안 발생하는 하나 이상의 오류를 나타냅니다.
  - AggregatioinException 타입은 예외 객체들에 대한 컬렉션을 캡슐화하기 위해서 주로 사용됩니다. (부모 스레드가 다수의 자식 스레드를 가지고 있고 특정 자식 스레드에서 예외가 던져지는 경우 사용)
  - AggregatioinException 의 Handle 메서드는 AggregatioinException 내부의 예외에 대해서 각각 callback 메서드를 호출할 수 있게 합니다. 에러 처리를 수행할 때 해당 기능을 사용합니다.
- waitall 메서드를 호출하고 다수의 태스크가 전부 완료될 때까지 기다리는 중인데 도중에 하나 이상의 태스크가 취소되었다면, operationCanceledException을 던집니다.

<br>

- CancellationTokenSource를 이용하면 태스크를 취소할 수 있습니다.
  - Task 객체의 작업이 스캐줄되기 전에 CancellationToken을 이용하여 태스크를 취소하려고 시도할 수 있는데 이 경우 태스크는 즉각 취소되고 절대 수행되지 않습니다. 하지만 태스크가 이미 수행 중이라면 작업을 수행중에 중단할 수 있도록 코드가 준비되어 있어야 합니다.

<br>

- 태스크 완료 시 다른 태스크를 자동으로 수행.
  - Wait, Result 는 해당 태스크를 수행하기 위해 스레드를 하나 더 생성해서 성능에 영향을 주는 경우가 있습니다. Wait/Result  말고도 스레드가 완료되었을 경우 이를 확인할 수 있는 방법이 있는데 특정 태스크가 수행 완료되었을 때 바로 다음 스레드를 이어서 수행하는 방법입니다.

- 아래의 코드는 어떤 스레드도 블로킹하지 않습니다.
```cs
            //태스크를 생성하고 시작합니다. 다른 태스크를 이어서 시작할 것입니다.
            var t = Task.Run(() => sum(1, 3));
            //ContinueWith 가 태스크를 반환하기는 하지만 잘 사용하지는 않습니다.
            Task cwt = t.ContinueWith(task => Console.WriteLine($"sum is {task.Result}"));
```

- 태스크 객체는 내부적으로 ContinueWith 태스크를 컬렉션에 저장하고 있습니다. 덕분에 단일 태스크 객체에 대하여 ContinueWith 메서드를 여러 번 호출할 수 있으며, 태스크가 완료되면 컬렉션 내의 모든 ContinueWith 태스크들을 스레드 풀에 큐잉하게 됩니다.
  - ContinueWith를 호출할 때 TaskContinuationOptions 플래그를 지정할 수 있습니다.
- [마이크로소프트 taskcontinuationoptions](https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=net-5.0)

<br>

- 태스크는 부모 자식 관계를 가질 수 있습니다.
  - 기본적으로 부모 태스크와 자식 태스크는 독립적이지만 TaskFactory 로 태스크를 생성하는 경우 TaskCreationOptions.AttachedToParent 플래그를 설정해 부모와 자식 태스크를 연결시킬 수 있습니다.
    - 이 경우 자식 태스크가 완료되기 전까지 부모 태스크는 완료되지 않습니다.
    - 자식 태스크가 예외를 던질 경우 부모 태스크로 전달됩니다.
    - Task.Run() 을 통해 만들어진 부모 태스크는 명시적으로 자식 태스크와 연결되지 않도록 합니다.
- [마이크로소프트 childTask](https://docs.microsoft.com/ko-kr/dotnet/standard/parallel-programming/attached-and-detached-child-tasks)

<br>

- 태스크는 내부적으로 ID(Int32), 상태를 나타내는 status(Int32), 부모 태스크 참조자, 태스크 생성시에 지정된 TaskScheduler 참조자, callback 메서드, callback메서드에 전달해야 하는 객체, ExecutionContext 참조자, ManualResetEventSlim 객체 참조자 등을 가지고 있습니다.
  - 태스크는 IDisposable 인터페이스를 구현합니다.
  - 태스크의 status를 확인해서 수명 주기를 파악할 수 있습니다. [마이크로소프트 : Task Status](https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.tasks.taskstatus?view=net-5.0)

<br>

- 태스크 팩토리는 Task 개체를 만들고 예약하도록 지원합니다.
  - [마이크로소프트 : Task.Run vs Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/)

<br>

- 태스크 스케쥴러는 작업을 스레드의 큐에 대기하는 낮은 수준의 작업을 처리하는 개체를 나타냅니다.
  - [마이크로소프트 : Task Scheduler](https://docs.microsoft.com/ko-kr/dotnet/api/system.threading.tasks.taskscheduler?view=net-5.0#definition)

<br>

### Parallel의 정적 For, ForEach, Invoke 메서드
...

### Parallel LINQ
...

### 계산 중심 작업을 주기적으로 수행하기
- System.Threading 네임스페이스의 Timer 클래스를 이용하면 스레드 풀 내의 스레드를 이용하여 특정 메서드를 주기적으로 수행할 수 있습니다.
- Timer 객체가 가비지로 수집되면, finalizatioin 코드가 타이머를 취소하기 때문에 콜백 메서드가 더 이상 수행되지 않습니다. 타이머 클래스의 Dispose()를 호출한 경우에도 마찬가지

```cs
    public sealed class Program
    {
        public static Timer s_Timer;
        public static void Main()
        {
            Console.WriteLine("Timer 클래스를 활용해 주기적으로 델리게이트 호출");

            var timer = new Timer(DoSomething, null, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(2));

            //절대 수행되지 않는 타이머를 생성합니다. 이렇게 해서 s_Timer 변수에 객체를 할당하기도 전에 스레드 풀 내의 스레드가 DoSomething2 를 호출하는 것을 막습니다.
            s_Timer = new Timer(DoSomething2, null, Timeout.Infinite, Timeout.Infinite);

            //이 시점에서는 s_Timer의 객체가 할당되었으므로, Status 콜백 함수 내부에서 Change 메서드를 호출하기 위해서 s_Timer를 참조해도 널 오류가 발생하지 않습니다.
            s_Timer.Change(0, Timeout.Infinite);

            //프로그램이 종료되는 것을 막는다.
            Console.ReadLine();
        }

        private static void DoSomething(object state)
        {
            Console.WriteLine($"Called DoSomething : Current Time : {DateTime.Now}");
        }

        private static void DoSomething2(object state)
        {
            Console.WriteLine($"Called DoSomething2 : Current Time : {DateTime.Now}");
            Thread.Sleep(1000); //다른 작업을 수행하기 전에 1초 휴식

            //메서드를 반환하기 이전에 2초 후에 다시 수행될 수 있도록 해준다.
            s_Timer.Change(2000, Timeout.Infinite);

            //이 메서드가 반환되면 이 메서드를 수행하던 스레드는 스레드 풀로 반환됩니다.

        }
    }
```
### 스레드 풀이 스레드를 관리하는 방법
## 이 부분 오역투성이에 엉망진창입니다.

- 스레드 개수가 충분하지 않을 경우, 기아 현상이나 데드락이 발생할 수 있기 때문에 CLR은 지속적으로 수행 가능한 스레드 숫자를 증가시키고 있습니다.
- 스레드 풀이 생성할 수 있는 최대 스레드 개수는 개발자가 설정할 수 있습니다. 하지만 응용프로그램 성능에 영향을 줄 수 있으므로 가능한 기본 설정을 사용하는 것을 권고하고 있습니다.

<br>

**워커 스레드는 어떻게 동작하는가**

<br>

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/27-1.png" width="70%" height="70%">

<br>

- Top-level에 해당하는 태스크들은 항상 작업 항목을 글로벌 큐(Global Queue)에 추가합니다.
- 워커 스레드가 글로벌 큐로부터 작업 항목을 가져갈 때에는 FIFO(First-in-First-out) 순서로 가져옵니다. 이때 두 개 이상의 스레드가 글로벌 큐에서 태스크를 가져가려 할 수 있기 때문에 글로벌 큐는 스레드 동기화 락으로 보호되고 있습니다.

<br>

- 자식 태스크가 생성되는 경우, 부모 태스크를 담당하는 스레드에 대응하는 로컬 큐(local queue)가 생성되어 태스크가 삽입됩니다.
- 워커 스레드는 작업을 수행할 수 있는 상황이 되면 자신의 로컬 큐를 확인하여 태스크를 꺼내갑니다. 
  - 로컬 큐의 가장 앞쪽은(head) 해당 큐를 소유하고 있는 워커 스레드 만이 접근할 수 있도록 구성되어 있어 스레드 동기화가 필요하지 않습니다.(LIFO)
  - 자신의 로컬 큐에 태스크가 남아있지 않은 경우 워커 스레드는 글로컬 큐의 뒤쪽을 참조해 태스크를 가져갑니다.(FIFO)
  - 글로벌 큐가 비면 이번에는 다른 스레드의 로컬 큐 뒤쪽의(tail) 태스크를 가져갑니다. 이 경우 다수의 스레드가 접근하는 경우가 있으므로 스레드 락이 필요합니다.(FIFO)
  - 다른 큐에도 태스크가 남아있지 않으면 스레드는 sleep 상태로 변경됩니다. sleep 상태에서 일정 시간이 지나면 스레드는 스스로 깨어나 자기 자신을 제거하고 자원을 반환합니다.
  - 위의 방법으로 캐시 지역성을 보존하고 스레드 간 경합을 줄일 수 있습니다.
  - [Microsoft : TaskScheduler](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?redirectedfrom=MSDN&view=net-5.0#remarks)
  - [stack overflow : why-does-clr-threadpool-worker-thread-use-lifo](https://stackoverflow.com/questions/53461132/why-does-clr-threadpool-worker-thread-use-lifo-order-to-process-tasks-from-the-l)

</details>

## 28장 I/O 중심의 비동기 작업

<details>
<summary>fold/unfold</summary>

### 윈도우 운영체제가 I/O 작업을 수행하는 방법
...

### C#의 비동기 함수
- 함수에 async 키워드를 추가하여 비동기 함수로 지정할 수 있습니다. 컴파일러는 자동적으로 비동기 함수의 코드를 상태 기기(State Machine)를 구현하고 있는 타입으로 변환합니다. 
  - 이렇게 하여 메서드가 전부 수행된 이후에야 결과값을 반환하는 것이 아니라 상태 기기를 이용하여 메서드 내의 코드 중 일부만을 수행하고도 반환될 수 있도록 코드를 생성합니다.
- 메서드 정의 시 async를 포함하면, 컴파일러는 상태 기기가 최초로 시작될 때 Task 객체를 생성하도록 코드를 생성합니다. 이후에 상태 기기가 끝까지 작업을 완료하였을 때 이 Task 는 완료 상태로 변환됩니다.

<br>

비동기 함수를 사용할 때는 아래와 같은 제약이 있다.
- 응용프로그램의 Main 메서드를 비동기 함수로 변경할 수는 없습니다. 또한 생성자나 속성 접근자 메서드 혹은 이벤트 접근자 메서드는 비동기 함수가 될 수 없습니다.
  - 현재 C# 에서 Main 메서드는 비동기 함수가 될 수 있습니다 
- 비동기 함수는 out 이나 ref 매개변수를 가질 수 없습니다.
- catch, finally, unsafe 블록 내에서는 await를 사용할 수 없습니다.
- await 앞쪽에서 스레드의 소유권/재귀호출을 허용하는 락을 획득하였다가 await 뒤쪽에서 이를 해제할 수 없습니다.
  - 이러한 방식이 허용되지 않는 이유는 await 앞쪽의 코드를 수행하는 스레드와 await 뒤쪽의 코드를 수행하는 스레드가 다를 수 있기 때문입니다.
  - c#에서는 lock 내부에서 await 를 사용하면 컴파일러가 오류를 발생시킵니다.
- 쿼리 표현식 내부에서는 from 절의 첫 번째 컬렉션 나타내는 부분이나 join 절의 컬렉션을 나타내는 부분에서만 await 연산자를 사용할 수 있습니다.


#### Await
- await 연산자는 피연산자가 나타내는 비동기 작업이 완료될 때까지 바깥쪽 비동기 메서드의 평가를 일시 중단합니다. 비동기 작업이 완료되면 await 연산자는 작업 결과를 반환합니다(있는 경우). 이미 완료된 작업을 나타내는 피연산자에 await 연산자가 적용되면 바깥쪽 메서드를 일시 중단하지 않고 작업 결과를 즉시 반환합니다. await 연산자는 비동기 메서드를 평가하는 스레드를 차단하지 않습니다. await 연산자가 바깥쪽 비동기 메서드를 일시 중단하면 제어가 메서드 호출자에게 반환됩니다.

#### 참고
- [microsoft : await](https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/operators/await)


### 컴파일러가 비동기 함수를 상태 기기로 변환하는 방법
- 예제 코드는 책을 확인할 것
- 비동기 함수의 유일한 목적은 블로킹되지 말아야 하는 코드를 작성해야 할 때 좀 더 단순하게 코딩을 할 수 있도록 하기 위함입니다.

### 비동기 함수의 확장성
- 예제 코드는 책을 확인할 것

### 비동기 함수와 이벤트 핸들러
- 비동기 함수의 반환형을 void 로 정의할 수도 있는데, 이는 이벤트 핸들러를 비동기로 구현하는 경우를 단순화하기 위해서 c# 컴파일러가 허용하는 아주 특별한 경우입니다.

이벤트 핸들러 메서드는 다음과 유사한 형태를 띠는 것이 보통입니다.


`void EventHandlerCallback(Object sender, EventArgs e);`
- 그러나 이벤트 핸들러 내부에서는 I/O 작업을 수행하는 것이 보통입니다.

### 프레임워크 클래스 라이브러리(FCL) 내의 비동기 함수
- FCL을 살펴보면 많은 타입들이 I/O 작업을 비동기로 수행하는 XxxAsync 메서드를 제공하고 있습니다.
  - 예를 들어 System.IO.Stream 을 상속하는 모든 클래스들은 ReadAsync, WriteAsync, FlushAsync를 구현하고 있습니다.

### 비동기 함수와 예외 처리
- 비동기 작업에서 오류가 발생하는 경우, 예를 들어서 네트워크롤 통해 데이터를 송신한 수 응답을 기다릴 때 타임 아웃이 발생한다면 예외를 던질 것입니다.
  - 이때 디바이스 드라이버는 완료된(Completed) IRP를 CLR의 스레드 풀로 통지하고 스레드 풀 내의 스레드가 task 객체를 예외 상태로 완결시킵니다. 이제 비동기 작업을 수행하였던 상태 기기의 메서드가 다시 수행되고, await 연산자는 작업이 실패하였음을 발견하고 예외를 발생시킵니다.

- 여기서 IRP는 IO Request Packet 입니다.
- Task 객체에서는 AggregateException을 통해 예외를 던지지만 Task객체와 await 연산자를 같이 사용하는 경우에는 AggregateException 대신 첫 번째 InnerException 에 대응하는 예외가 발생하게 됩니다.
- 비동기 작업을 수행했던 상태 기기가 처리되지 앟은 예외를 만나게 된다면 Task 객체를 처리되지 않은 예외 상태로 완결 짓게 됩니다. 따라서 Task 객체가 완료되기를 기다리던 코드는 비동기 예외가 발생하였음을 알 수 있습니다. 그러나 반환 타입이 void인 비동기 함수의 경우, 처리되지 않은 예외가 발생하였음을 확인할 수 있는 방법이 없습니다. 이를 대비하기 위해서는 동기화 컨텍스트(synchronization context)를 활용하는 방법이 있습니다.

### 비동기 함수의 다른 기능
- 비동기 작업이 빨리 수행되는 경우가 있을 수 있습니다. 이런 간단한 작업들을 다른 스레드에서 수행하도록 하는 것은 비효율적일 수 있습니다.
  - 컴파일러는 이런 상황을 고려하여 await를 사용하는 경우 비동기 작업을 호출한 스레드에서 동기적으로 수행하도록 코드를 작성합니다.
  - 만약 이런 컴파일러 최적화를 원하지 않는 경우 Task.Run()을 활용하면 동작을 비동기로 수행하게 됩니다.

### 응용 프로그램과 스레딩 모델
- SynchronizationContext를 상속한 클래스의 객체는 응용프로그램 모델을 스레드 모델에 연결하는 역할을 수행합니다. 
- Task 객체에 대하여 await 연산자를 사용한 경우를 살펴보면, 호출하는 측의 스레드가 미리 SynchronizationContext 객체를 획득해두었다가, 스레드풀 내의 스레드가 작업을 완료하는 경우, 앞서 획득해둔 SynchronizationContext 객체를 사용하여 응용프로그램의 모델에 맞추어 올바른 스레드 모델이 적용될 것임을 보장해줍니다.
- 예제 코드는 책을 확인할 것

### 서버를 비동기로 구현하려면?
...

### I/O 작업의 취소
...

### 반드시 동기적으로 수행되어야만 하는 I/O 작업
...

### I/O 요청의 우선순위
...




</details>

## 29장. 단순 스레드 동기화 요소

<details>
<summary>fold/unfold</summary>

<br>

락의 문제점
- 성능을 해칩니다. 락을 획득하고 해체하는 작업은 추가적인 함수 호출이 필요하며, cpu가 여러 스레드들 중 어떤 스레드가 처음으로 락을 획득하도록 할 것인지 결정해야 하기 때문에 상당한 시간을 소요합니다.
- 스레드 동기화 락은 특정 시간에 하나의 스레드 만이 접근 가능하는 것만을 허용하기 때문에 다른 스레드는 블로킹 상태가 되는데, 스레드를 블로킹함에 따라 cpu가 더 많은 스레드를 생성하게 될 수 있습니다. 스레드 풀이 cpu가 스레드 사용성이 낮다고 판단하기 때문입니다. 이때 추가 스레드를 생성하는 동작은 오버헤드가 되며, 블로킹 되는 스레드가 다시 작업을 재개할 때 다시 스케줄링 되며, 더 많은 스레드 사이에서 문맥전환이 발생하는 것도 오버헤드가 됩니다.

### 클래스 라이브러리와 스레드 안전성
- 마이크로소프트의 FCL는 모든 정적 메서드에 대하여 스레드 안전성을 보장합니다. 하지만 인스턴스 메서드는 항상 스레드 안정성을 보장하는 것은 아닙니다. 시스템 락을 사용하는 경우 비효율적일 수 있기 때문입니다.
- 스레드 안정적으로 만든다는 것은 내부적으로 스레드 동기화 락을 반드시 사용해야 하는 것을 의미하지는 않습니다. 예를 들어 값 타입을 활용하는 경우라면 매개변수를 전달할 때 값 복사가 발생하므로 다수의 스레드가 동일 시점에 접근해도 그 값이 손상되지 않습니다.
- 고유의 클래스 라이브러리를 만들 때도 정적 메서드는 스레드 안전성을 보장하도록 인스턴스 메서드에 대해서는 반드시 그렇지 않도록 하는 것을 책에서 추천하고 있습니다.

### 단순 유저 모드 동기화 요소와 커널 모드 동기화 요소
...

### 유저 모드 동기화 요소
- int(Int32) 타입에 대해서는 동작이 원자적으로 이루어지기 때문에 아래의 코드 에서 값을 변경하는 스레드가 아닌 다른 스레드가 값을 얻어간다 하더라도 변경 중인 값을 읽지 않습니다.
```cs
 internal static class SomeType{
      public static Int32 x = 0;
 }

 //어떤 스레드가 아래의 코드를 수행 중
 SomeType.x = 0x01234567;
```

-  하지만 long 타입에 대해서는 이야기가 다릅니다. 원자적으로 수행된다고 보장할 수 없기 때문에 다른 스레드는 변경 중인 값을 획득할 가능성이 있습니다.
  - 예를 들어 어떤 값 x를 0x000000000000000 에서 0x0123456701234567 로 변경하고 있을 때 다른 스레드가 값을 읽는다면 0x0123456700000000 과 같이 변경 중인 값을 얻을 수 있습니다.
- 단순 유저 모드 동기화 요소를 이용하면 해당 값에 대해서도 원자적으로 수정이 이루어지도록 강제합니다.

<br>

단순 유저모드 동기화 요소에는 두 가지가 있습니다. 이들은 단순 데이터 타입의 변수에 대해서 지정된 시간에 원자적으로 쓰고 읽을 수 있게 합니다.
- Volatile 동기화 요소
- Interlocked 동기화 요소

**Volatile**

컴파일러가 지원하는 최적화는 사용자 입장에서 도움을 주기도 하지만 멀티스레딩을 이용하는 환경에서 컴파일러 최적화는 왜곡된 동작을 유발할 가능성이 있습니다.

```cs
internal static class StrnageBehavior
{
    private static bool s_StopWorker = false;

    public static void Main()
    {
        var worker = new Thread(Worker);
        worker.Start();
        Thread.Sleep(5000);
        s_StopWorker = true;
        Console.WriteLine("Wait For WorkerThread");
        worker.Join();
    }

    private static void Worker(Object o)
    {
        int x = 0;
        while (!s_StopWorker) x++;
        Console.WriteLine("worker Stop");
    }
}
```

위의 코드에서 컴파일러는 Worker 메서드를 수행하는 새로운 스레드를 생성할 때 최적화를 수행합니다. 이때 s_StopWorker 는 스레드 내에서 수정되는 일이 없으니 Worker 내부의 while문을 최적화하게 됩니다. 이 말인즉, Main 스레드에서는 s_StopWorker가 변경될 수 있는 값임에도 불구하고 Worker를 수행하는 스레드에서는 s_StopWorker를 불변값으로 인식해 while문을 최적화하는 것입니다. 이 결과로 코드 상의 while문을 벗어날 수 없게 됩니다.
- 릴리즈 빌드시 문제가 발생합니다.

또한 컴파일러 최적화는 경우에 따라 메서드 내부의 명령 실행 순서를 임의로 변경하기도 합니다.

```cs
internal sealed class ThreadsSharingData
{
    private int m_Flag = 0;
    private int m_Value = 0;

    //1번 스레드가 수행합니다.
    public void Thread1()
    {
        //참고 : 아래 코드는 실행 순서가 뒤집혀서 수행될 수 있습니다.
        m_Value = 5;
        m_Flag = 1;
    }

    //2번 스레드가 수행합니다.
    public void Thread2()
    {
        //참고 : m_Value 가 m_Flag 이전에 조회될 수 있습니다. m_Flag는 1이면서 m_Value 는 0 값이 출력될 수 있습니다.
        if(m_Flag == 1)
        {
            Console.WriteLine(m_Value);
        }
    }
}
```

<br>

- System.Threading.Volatile 네임스페이스의 Volatile 정적 메서드는 아래의 기능을 제공합니다.
  - Volatile.Write : 이 메서드를 호출한 위치에서 그 값이 반드시 쓰여질 것임을 보장합니다. 또한 프로그램 코드 순서상 이 코드를 호출한 위치보다 앞쪽에서 수행된 로드(load)/스토어(store) 과정은 반드시 이 코드보다 앞서 수행될 것임을 보장합니다.
  - Volatile.Read : 이 메서드를 호출한 위치에서 그 값이 읽혀질 것임을 보장합니다. 또한 프로그램 코드의 순서상 이 코드 이후에 위치한 로드(load)/스토어(store) 과정은 반드시 이 메서드가 수행된 이후에 수행될 것임을 보장합니다.

 <br>

 위의 코드를 아래처럼 변경할 수 있습니다.
 ```cs
 internal sealed class ThreadsSharingData
 {
     private int m_Flag = 0;
     private int m_Value = 0;
 
     //1번 스레드가 수행합니다.
     public void Thread1()
     {
         //참고 : m_Flag 값이 1로 바뀌기 이전에 m_Value 값이 먼저 5로 변경될 것입니다. 순서가 바뀔 염려가 없습니다. 하지만 Volatile.Write 이전에 다수의 명령이 있다면 해당 명령들의 실행 순서까지 보장하진 못합니다.
         m_Value = 5;
         Volatile.Write(ref m_Flag, 1);
     }
 
     //2번 스레드가 수행합니다.
     public void Thread2()
     {
         //참고 : m_Flag 값을 먼저 가져온 다음 m_Value 값을 가져옵니다.
         if(Volatile.Read(ref m_Flag) == 1)
         {
             Console.WriteLine(m_Value);
         }
     }
 }
```


- c# 이 지원하는 volatile 키워드를 필드에 적용할 수도 있습니다.
  - 기본 타입 및 Enum 타입에 대해서 지원하며 해당 필드에 접근하는 코드를 컴파일 할때, Volatile.Read, Volatile.Write 메서드를 사용하게 해줍니다.
  - 또한 이 키워드를 사용하면 C# 컴파일러와 JIT 컴파일러에게 이 필드의 값을 CPU 레지스터에 캐싱하지 않도록 하며, 항상 메모리로부터 값을 읽고 쓰도록 합니다.
  - 하지만 volatile 필드의 경우 최적화 대상에서 제외되는 만큼 메모리를 차지하는 크기도 커질 뿐더러 동작 속도도 느려집니다.
  - C# 에서는 volatile 필드에 대한 참조 값을 전달하지 못합니다 
```cs
internal sealed class ThreadsSharingData
{
    private volatile int m_Flag = 0;
    private int m_Value = 0;

    //1번 스레드가 수행합니다.
    public void Thread1()
    {
        //참고 : m_Flag 값이 1로 바뀌기 이전에 m_Value 값이 먼저 5로 변경될 것입니다.
        m_Value = 5;
        m_Flag = 1;
    }

    //2번 스레드가 수행합니다.
    public void Thread2()
    {
        //참고 : m_Flag 값을 먼저 가져온 다음 m_Value 값을 가져옵니다.
        if (m_Flag == 1)
        {
            Console.WriteLine(m_Value);
        }
    }
}
```

<br>


**Interlocked**

- Interlocked 클래스의 메서드들을 이용하면 원자적으로 값을 읽고 쓸 수 있을 뿐 아니라, 완벽히 메모리 펜스(memory fence)기능을 제공한다. 메모리 펜스 기능이란 Interlocked 메서드를 호출하기 이전에 수행된 쓰기 작업은 반드시 Interlocked 메서드 호출 이전에 호출될 것임을 보장하고, Interlocked 이후에 호출한 읽기 작업은 반드시 Interlocked 메서드 호출 이후에 수행될 것임을 보장하는 것을 말합니다.
  - Interlocked 메서드들의 경우, 상대적으로 속도도 빠른 편이고 다용도로 활용할 수 있습니다. 

```cs
public static class Interlocked
{
    //return(++location)
    public static int Increment(ref int location);

    //return (--location)
    public static int Decrement(ref int location);

    //return (location += value)
    public static int Add(ref int location, int value);

    //int old = location; location = value; return old;
    public static int Exchange(ref int location, int value);

    //int old = location;
    //if (location == comparand) location = value;
    //return old;
    public static int CompareExchange(ref int location, int value, int comparand);
}
```

<br>


**간단한 스핀락 구현하기**

- System.Threading 에도 spinlock 구조체가 존재합니다.
- 간단한 구현방식의 가장 큰 문제는 락을 소유하기 위한 경쟁 상태가 발생한 경우에, 스레드들이 계속해서 로프를 헛돌 수 있다는 것입니다. 이 경우 cpu 시간을 허비하게 되므로 스핀락 방식은 짧고 금방 벗어나는 구간에 대해서 사용하는 것이 좋습니다.
  - 단일 cpu 구조에서는 스핀락을 잘 사용하지 않습니다. 어떤 스레드가 락을 소유하고 다른 스레드가 루프를 돌고 있을 때 락을 빠르게 해제할 수 없기 때문입니다. 

```cs
//Interlocked 를 활용하여 간단한 스레드 동기화 락을 구현합니다.
internal struct SimpleSpinLock
{
    private int m_ResourceInUse; //0 기본값, 1 = true

    public void Enter()
    {
        while (true)
        {
            //리소스가 사용 중인 상태가 아니라면 사용 중인 상태로 변경한 후 바로 반환된다.
            if (Interlocked.Exchange(ref m_ResourceInUse, 1) == 0) return;
            //여기서 락을 얻지 못한 스레드는 블로킹
        }
    }

    public void Leave()
    {
        Volatile.Write(ref m_ResourceInUse, 0);
    }
}
```
아래처럼 사용합니다.
```cs
public sealed class SomeResource
{
    private SimpleSpinLock m_SpinLock = default;

    public void AccessResource()
    {
        m_SpinLock.Enter();
        //특정 시점에 단 하나의 스레드만이 이곳에 진입하여 리소스에 접근할 수 있습니다.
        m_SpinLock.Leave();
    }
}
```

**타입에 상관없이 Interlocked 요소를 사용하기 위한 패턴**

- 데이터 베이스 레코드를 수정할 때 흔히 사용되는 낙관적 동시성(Optimistic concurrency) 패턴
```cs
public static int Maximum(ref int target, int value)
{
    int current = target, start, desired;

    //루프 내에서는 target의 값을 변경하는 경우를 제외하고는 이 값에 접근해서는 안 된다.
    //왜냐하면 다른 스레드가 이 값을 변경할 수도 있기 때문이다.
    do
    {
        start = current;
        desired = Math.Max(start, value);

        //수행 중이던 스레드가 여기서 선점 당할 수 있다.

        current = Interlocked.CompareExchange(ref target, desired, start);

        //이번 순회 과정 중에 targe 값이 외부에서 변경되었다면 루프를 다시 돈다.
    } while (start != current);
    return desired;
}
```
- 위의 메서드가 한창 수행 중에 다른 스레드가 target의 값을 변경할 수도 있다. 그때 start와 현재의 target 값이 동일하지 않기 때문에 이때 desired 값은 유효하지 않은 값입니다. 즉 다른 스레드가 target 값을 변경하지 않았을 때 연산된 desired 값을 반환해야하며 이를 위해 Interlocked.compareExchange를 사용합니다.

- Morph 패턴
```cs
public delegate int Morpher<TResult, TArgument>(int start, TArgument argument, out TResult result);
public static TResult Morph<TResult, TArgument>(ref int target, TArgument arguemnt, Morpher<TResult, TArgument> morpher)
{
    TResult result;
    int current = target, start, desired;
    do
    {
        start = current;
        desired = morpher(start, arguemnt, out result);
        current = Interlocked.CompareExchange(ref target, desired, start);
    } while (start != current);
    return result;
}
```

### 커널 모드 등기화 요소
- 커널 모드 동기화 요소는 유저 모드 동기화 요소에 비해서 상당히 느립니다. 커널 모드 동기화 요소들이 운영체제에게 스레드 간의 동기화를 요청하는 것이기 때문입니다.
  - 또한 각각의 메서드들은 커널 객체를 이용하게 되고 이로 인해 스레드가 관리 코드에서 네이티브 사용자 코드를 거쳐 네이티브 커널 모드 코드로까지 전환되었다가 다시 역순으로의 전환을 반복할 수 밖에 없기 때문이기도 합니다.
  - 위의 전환 과정은 상당한 cpu 시간을 소비하기 때문에, 자주 발생할 경우 응용프로그램의 전체적인 성능에 나쁜 영향을 미치게 됩니다.

<br>

- 하지만 커널 모드 동기화 요소들이 단순 요저 모드 동기화 요소에 비해서 다음과 같은 경우에 이점을 제공합니다.
  - 리소스에 대한 경쟁 상태를 확인할 수 있어서, 운영체제에게 관련 스레드가 더 이상 CPU 시간으로 허비하지 않도록 하여, 프로세서 자원을 낭비하지 않도록 합니다.
  - 네이티브 스레드와 관리 스레드 사이에도 동기화를 수행할 수 있습니다.
  - 동일 컴퓨터 내의 서로 다른 프로세싱에서 수행 중 스레드 간에도 동기화를 수행할 수 있습니다.
  - 커널 모드 동기화 요소는 보안 체계가 적용되어 있어서, 인증되지 않은 계정이 이에 접근하는 것을 막을 수 있습니다.
  - 일련의 커널 모드 동기화 요소를 묶어서 전체가 가용 상태가 되거나 그 중 하나만 가용 상태가 될 때까지 스레드를 블로킹할 수 있습니다.
  - 타임 아웃 시간을 지정하여 스레드를 블로킹 할 수 있습니다. 지정된 시간 이내에 스레드가 리소스에 접근할 수 없는 경우,블로킹된 스레드의 수행을 재개하여 다른 작업을 수행하도록 할 수도 있습니다.

<br>

두 개의 주요 커널 모드 동기화 요소는 이벤트(event)와 세마포어(semaphore) 입니다. 뮤텍스(mutex)와 같은 다른 커널 모드 동기화 요소는 이 두 가지 주요 요소를 근간으로 만들어진 것입니다.
- System.Threading 내부에는 WaitHandle 이라는 추상 기본 클래스가 포함되어 있습니다. 해당 클래스는 윈도우 커널 오브젝트 핸들을 나타내기 위한 목적으로 만들어졌으며, FCL 안에는 WaitHandle을 상속한 클래스가 여러 개 존재합니다.
- 커널 모드 동기화 요소를 이용하는 모든 메서드들은 완벽히 메모리 펜스(memory fence) 기능을 제공합니다.

<br>

WaitHandle 이 가지는 메서드들
- WaitOne 는 커널 객체가 시그널 상태가 될 때까지 이 메서드를 호출한 스레드를 대기시키기 위해서 사용됩니다. 내부적으로 이 메서드는 Win32의 WaitForSingleObjectEx 함수를 호출합니다. 커널 객체가 시그널 상태가 된 경우 true를 타임아웃이 발생한 경우 false를 반환힙니다.
- WaitAll 메서드는 WaitHandle[] 배열 내에 포함되어 있는 모든 커널 객체들이 시그널 상태가 될 때까지 이 메서드를 호출한 스레드를 대기시키기 위해서 사용됩니다. 전부 시그널 상태가 되면 true를 타임아웃이 발생하면 false를 반환합니다.
- WaitAny 메서드는 WaitHandle[] 배열 내에 객체 중 하나라도 시그널 상태가 되면 true를 반환합니다.
- WaitAll과 WaitAny 메서드에 전달되는 배열 내의 커널 객체의 수는 64개를 넘어서는 안되며 만약에 초과할 경우 Sytem.NotSupportedException 이 발생합니다.
- 커널 객체의 핸들을 닫기 위해서 WaitHandle의 Dispose 메서드를 호출할 수 있습니다. 이 메서드 내부에서는 다른 어떤 스레드도 동일 커널 객체를 사용하고 있지 않음을 확인하는 과정이 포함되기 때문에 직접 호출하는 것은 좋지 않습니다. 가비지 컬렉터가 자동으로 커널 객체를 삭제해주기도 하니 내버려 두는 것지 좋습니다.

```cs
public sealed class Program
{
    public static void Main()
    {
        bool createdNew;

        using (new Semaphore(0, 1, "SomeUniqueStringIdentifyingMyApp", out createdNew))
        {
            if (createdNew)
            {
                //이 스레드가 주어진 이름의 커널 객체를 생성하였으므로 이제 이 응용프로그램의 다른 인스턴스는 수행될 수 없습니다. 
                //응용프로그램의 나머지 코드를 여기서 수행합니다.
            }
            else
            {
                //이 스레드는 이미 생성딘 동일 이름의 커널 객체을 열었습니다.
                //즉 응용 프로그램의 다른 인스턴스가 이미 수행 중이라는 의미이므로,
                //두 번째 수행된 응용프로그램의 인스턴스에서는 작업을 수행하지 않고 Main 메서드를 종료합니다.
            }
        }
    }
}
```
- 위의 예시에서 Semaphore를 사용하였지만 EventWaitHandle이나 Mutex를 사용할 수도 있습니다.
- 동일 응용 프로그램의 두 개의 인스턴스가 동시에 수행되고 있을 때, 두 개의 프로세스는 각자 고유의 스레드를 가지고 있을 것이며, 동일한 문자열을 이용하여 커널 객체 생성을 시도할 것입니다.
- 윈도우 커널은 이 중 하나의 스레드만이 지정된 이름의 커널 객체를 생성하도록 하고, createdNew 변수로 true 값을 돌려줍니다.
  - 두 번째 프로세스의 스레드가 동일 이름으로 커널 객체를 생성하려 하면 윈도우는 생성하려는 커널 객체가 이미 존재하고 있으므로 동일 이름의 커널 객체를 신규로 생성하지 못하도록 막고, 대신 앞서 다른 프로세스의 스레드가 생성하였던 동일 커널 객체를 사용할 수 있도록 해줍니다.
  - 이 방식으로 서로 다른 프로세스에 존재하는 스레드들이 단일의 커널 객체를 통해 상호 통신을 수행할 수 있습니다. 두 번째 프로세스는 객체 생성 시에 createdNew 값으로 false을 돌려받게 됩니다.

  <br>

  **이벤트**
  - 이벤트는 커널에서 관리되는 단순한 bool 변수입니다. 이벤트가 false이면 스레드가 블로킹되고 true 일때에는 블로킹이 해제됩니다. 
  - 이벤트는 크게 두 가지 종류가 있습니다.
    - 자동-리셋 이벤트는 여러 스레드가 자동-리셋 이벤트에 의해서 블로킹 되어있는 상태에서, 그 값이 true로 변경되면, 단 하나의 스레드만 블록킹을 해제합니다. 이후 커널이 자동적으로 이 이벤트를 리셋하여 false로 변경합니다.
    - 수동-리셋 이벤트는 동일 상황에서 그 값이 true로 변경되면 대기 중인 모든 스레드의 블록킹을 해제하며, 자동으로 리셋되지 않으므로 false로 변경되지 않습니다. 즉 코드를 통해서 수동으로 이벤트의 값을 false로 변경해줘야 합니다.


 <br>

 아래는 이벤트와 관련된 클래스들입니다.
```cs
public class EventWaitHandle : WaitHandle
{
    public bool Set();  //bool 값을 true로 설정합니다. 항상 true를 반환합니다.
    public bool Reset(); // bool 값을 false로 설정합니다. 항상 false를 반환합니다.
}

public sealed class AutoResetEvent : EventWaitHandle
{
    public AutoResetEvent(bool initialState);
}

public sealed class ManualResetEvent : EventWaitHandle
{
    public ManualResetEvent(bool initialState);
}
```

자동-리셋 이벤트를 사용하면 앞서 살펴본 SimpleSpinLock과 유사한 기능을 수행하는 스레드 동기화 락을 손쉽게 만들 수 있습니다.

```cs
internal sealed class SimpleWaitLock : IDisposable
{
    private readonly AutoResetEvent m_Available;

    public SimpleWaitLock()
    {
        m_Available = new AutoResetEvent(true); // true로 초기화
    }

    //리소스가 사용 가능할 때까지 커널에서 블로킹 수행
    public void Enter() => m_Available.WaitOne();

    //다른 스레드가 리소스를 사용할 수 있도록 해줌
    public void Leave() => m_Available.Set();

    public void Dispose() => m_Available.Dispose();
}
```

- SimpleWaitLock은 SimpleSpinLock 과 동일한 방법으로 사용할 수 있으며, 외부에서 보기에는 완전히 동일하게 동작하는 것처럼 보입니다. 하지만 이 두 가지 클래스를 성능적이 측면에서 비교해보면 근본적인 차이가 있습니다.
  - 여러 스레드들이 락을 획득하기 위해서 경쟁 상태에 있는 경우가 아니라면, SimpleWaitLock이 SimpleSpinLock에 비해 훨씬 느립니다. 왜냐하면 SimpleWaitLock의 Enter와 Leave 메서드를 호출할 때마다, 스레드는 관리 코드와 커널 코드 사이를 오가야 하기 때문입니다. (단점)
  - 하지만 스레드들이 경쟁 상태에 있는 경우라면, 락을 대기해야 하는 스레드들을 커널이 알아서 블로킹시켜주기 때문에, 스피닝으로 인한 CPU 소비가 발생하지 않습니다.(장점)
  - 더불어서 AutoResetEvent를 생성할 때는 Dispose 메서드를 호출할 때에는 관리 코드로부터 커널 코드로의 전환이 일어나며, 이로 인해 성능에 좋지 않은 영향을 미칠 수 있습니다.

```cs
public static void Main()
{
    int x = 0;
    const int iterations = 5000000;    //오백만 번

    var stopWatch = Stopwatch.StartNew();
    for(int i = 0; i < iterations; i++)
    {
        x++;
    }

    Console.WriteLine($"Incrementing {nameof(x)} : {x} : {stopWatch.ElapsedMilliseconds}");

    //아무런 작업도 하지 않는 메서드를 추가한 후에 오백만번 반복하는데 소요되는 시간을 측정
    stopWatch.Restart();
    for(int i = 0; i< iterations; i++)
    {
        M();
        x++;
        M();
    }
    Console.WriteLine($"Incrementing {nameof(x)} : {x} in M : {stopWatch.ElapsedMilliseconds}");

    //경쟁 상태가 발생하지 않는 상황에서 SimpleSpinLock을 상요하는 코드를 추가한 후에 오백만 번 반복하는 데 소요되는 시간을 측정
    var spinLock = new SpinLock(false);
    stopWatch.Restart();
    for (int i = 0; i < iterations; i++)
    {
        bool taken = false;
        spinLock.Enter(ref taken);
        x++;
        spinLock.Exit();
    }
    Console.WriteLine($"Incrementing {nameof(x)} : {x} in SpinLock : {stopWatch.ElapsedMilliseconds}");

    //경쟁 상태가 발생하지 않는 상황에서 SimpleWaitLock을 사용하는 코드를 추가한 후에 오백만 번 반복하는 데 소요되는 시간을 측정
    using (var waitLock = new SimpleWaitLock())
    {
        stopWatch.Restart();
        for (int i = 0; i < iterations; i++)
        {
            waitLock.Enter();
            x++;
            waitLock.Leave();
        }
        Console.WriteLine($"Incrementing {nameof(x)} : {x} in SimpleWaitLock : {stopWatch.ElapsedMilliseconds}");
    }
}

//이 메서드는 아무런 작업도 수행하지 않습니다.
[MethodImpl(MethodImplOptions.NoInlining)]
private static void M() { }
```

- 실행 결과
```console
Incrementing x : 5000000 : 3
Incrementing x : 10000000 in M : 25
Incrementing x : 15000000 in SpinLock : 136
Incrementing x : 20000000 in SimpleWaitLock : 11084
```

- 결과에서 알 수 있듯 스레드 동기화는 가능한 피하는 것이 좋고 반드시 동기화가 필요한 경우에는 유저모드 동기화 요소를 사용하되 커널 모드 동기화 요소는 가능한 사용을 피하는 것이 좋다.

<br>

**세마포어**

세마포어는 커널에서 관리되는 단순한 int 변수입니다. 세마포어의 값이 0이면 스레드들은 블로킹되고 0보다 크면 블로킹이 해제됩니다. 세마포어를 대기하던 스레드가 블록킹이 해제되면, 세마포어의 값은 1만큼 늘어납니다. 세마포어는 사용자가 설정할 수 있는 최댓값을 가질 수 있어서 현재 세마포어 카운트 값은 이 값을 초과할 수 없습니다.

```cs
public sealed class Semaphore : WaitHandle
{
    public Semaphore(int initialCount, int maximumCount);
    public int Release(); //Release(1)을 호출하고 이전 세마포어 값을 반환합니다.
    public int Release(int releaseCount); //이전 세마포어 값을 반환합니다.
}
```

<br><br>
- 세 가지 커널 모드 동기화 요소의 동작 방식을 정리해보면
  - 여러 스레드들이 자동 리셋 이벤트에 의해서 블로킹되어 있는 상태에서 이벤트가 설정 상태(시그널 상태) 가 되면 하나의 스레드 만이 블록킹이 해제됩니다.
  - 여러 스레드들이 수동 리셋 이벤트에 의해서 블로킹되어 있는 상태에서 이벤트가 설정 상태(시그널 상태) 가 되면 모든 스레드가 블로킹이 해제됩니다.
  - 여러 스레드들이 세마포어에 의해서 블로킹되어 있는 상태에서는 releaseCount에서 지정한 개수만큼의 스레드가 블로킹이 해제됩니다.

- 자동 리셋 이벤트는 최댓값을 1로 설정한 세마포어와 유사하게 동작합니다. 이벤트와 세마포어의 차이점이라면 자동 리셋 이벤트의 경우 연속적을 Set 메서드를 호출할 수 있고, 그 때마다 하나씩의 스레드가 블로킹 상태를 벗어나는 반면, 세마포어의 Release를 연속적으로 호출하였을 때 내부 카운트 값을 증가시켜서, 여러 스레드들이 동시에 블로킹 상태를 벋어날 수 있습니다. 하지만 세마포어의 release를 너무 많이 호출해서 설정된 최댓값을 넘어서게 된다면 SemaphoreFullException을 호출합니다.

<br>

- 아래는 세마포어를 이용하여 SimpleWaitLock을 구현한 코드입니다.
```cs
internal sealed class SimpleWaitLock : IDisposable
{
    private readonly Semaphore m_Available;

    public SimpleWaitLock(int maxConcurrent)
    {
        m_Available = new Semaphore(maxConcurrent, maxConcurrent);
    }

    //리소스가 사용 가능할 때까지 커널에서 블로킹 수행
    public void Enter() => m_Available.WaitOne();

    //다른 스레드가 리소스를 사용할 수 있도록 해줌
    public void Leave() => m_Available.Release(1);

    public void Dispose() => m_Available.Dispose();
}
```

<br><br>

**뮤텍스**
뮤텍스는 상호 배제 락을 표현하기 위한 요소입니다. 이는 AutoResetEvent나 최대 카운트가 1인 세마포어와 유사해서 블록킹된 스레드가 여러 개일 때, 이 중 하나의 스레드만이 수행될 수 있도록 해줍니다. Mutex클래스는 다음과 같습니다.

```cs
public sealed class Mutex : WaitHandle
{
    public Mutex();
    public void ReleaseMutex();
}
```

- 뮤텍스는 객체는 자신을 소유하고 있는 스레드의 ID 값을 기록해두었다가 특정 스레드가 ReleaseMutex를 호출하였을 때, 이 스레드의 ID값과 뮤텍스가 기록해두었던 스레드의 ID 값이 동일한지를 비교합니다. 만약 일치하지 않는다면 뮤텍스 객체의 상태는 변경되지 않고, ApplicaitonException을 발생시킵니다.
  - 또한 Mutex를 소유하고 있던 스레드가 어떤 이유에서 종료되면 AbandonedMutexException을 발생시켜, 동일 뮤텍스를 대기하던 다른 스레드를 깨웁니다. 이 예외를 처리하지 않는다면 프로세스는 종료됩니다.
- 뮤텍스 객체는 재귀 카운트(recursion count)를 가지고 있어서 뮤텍스를 이미 소유한 스레드가 뮤텍스를 다시 소유하려고 하면 이 값을 증가시키며 스레드를 블로킹시키는 대신 계속 수행될 수 있도록 해줍니다. ReleaseMutex를 호출하면 재귀 카운트 값은 줄어들고, 재귀 카운트가 0이 되어야만 다른 스레드가 뮤텍스를 소유할 수 있게 됩니다.
- 뮤텍스 객체는 스레드 ID와 재귀 카운트 등 추가적인 메모리 공간을 요구하므로, 성능상의 오버헤드가 있으며, 반드시 필요한 경우가 아니라면 뮤텍스를 사용을 피하는 편입니다.

<br>

- 보통 뮤텍스와 같이 재귀가 지원되는 락이 필요한 경우는 특정 메서드가 락을 소유한 채로 다른 메서드를 호출하고, 호출된 메서드 내부에서도 락을 필요로 하는 경우입니다.

```cs
internal class SomeClass : IDisposable
{
    private readonly Mutex m_Mutex = new Mutex();

    public void Method1()
    {
        m_Mutex.WaitOne();
        //여기서 작업을 수행합니다.
        Method2();  //내부에서 다시 락을 요구합니다.
        m_Mutex.ReleaseMutex();
    }

    public void Method2()
    {
        m_Mutex.WaitOne();
        //여기서 작업을 수행합니다.
        m_Mutex.ReleaseMutex();
    }

    public void Dispose() => m_Mutex.Dispose();
}
```

- 뮤텍스 객체는 재귀 방식을 지원하기 때문에, 동일 스레드가 이 뮤텍스 객체를 두 번에 걸쳐 소유하고 해제할 수 있습니다. Mutex 대신 AutoResetEvent를 사용한다면  Method2 내부에서 블로킹되어버릴 겁니다.
  - 책에서는 AutoResetEvent를 재귀 방식으로 활용할 수 있도록 작성한 코드 예시가 있습니다. 이 경우 뮤텍스와 달리 소유권을 추적하기 위한 코드들이 관리 코드에서 수행되기 때문에 동작은 동일하지만 속도는 더 빠릅니다.
</details>

## 30장. 복합 스레드 동기화 요소

<details>
<summary>fold/unfold</summary>

- 유저 모드 스레드 동기화 요소와 커널 모드 스레드 동기화 요소를 결합하여 `복합 스레드 동기화 요소`를 만들 수 있습니다.
  - 복합 스레드 동기화 요소는 스레드 들이 경쟁 상태가 아닐 때에는 유저 모드 동기화 요소의 성능상의 장점을 취하며, 동시에 다수의 스레드가 경쟁 상태일 경우에는 커널 모드 스레드 동기화 요소를 이용하여 CPU 시간을 소비하는 스피닝(spinning) 이 발생하지 않도록 합니다.

### 간단한 복합 스레드 동기화 락

- 복합 스레드 동기화 락의 예제 코드
  - 단순 유저 모드 동기화 요소인 Interlocked와 단순 커널 동기화 요소인 AutoResetEvent를 동시에 사용해서 최대한의 성능을 얻어내고 있습니다.
  - 처음 스레드가 락을 획득할 때에는 Interlocked 를 통해 빠르게 획득할 수 있도록 합니다.
  - 두 번째 스레드가 블로킹될 때에는 커널 동기화 요소인 AutoResetEvent의 WaitOne를 호출합니다. 이때 WaitOne은 커널에 접근하기 때문에 느리지만, 어차피 해당 스레드는 블로킹될 스레드이기 때문에 완전히 멈추는데 시간이 걸리더라도 성능적 손해는 크지 않을 것입니다.
  - 이 방식은 장점이 있어서 스레드가 완전히 블로킹되면 CPU 시간을 낭비하는 스피닝을 피할 수 있습니다.
  - 스레드가 락을 반환할 때에도 마찬가지로 먼저 Interlocked를 활용합니다. m_Waiters 를 확인해 스레드가 경쟁상태에 있는지 먼저 확인합니다.
  - 만약 대기하는 스레드가 없다면 별다른 동작 없이 빠져나옵니다. 이때 수행 성능은 꽤 빠릅니다.
  - 대기하는 스레드가 있다면 AutoResetEvent 의 set을 호출합니다. 이 경우 커널에 접근하기 때문에 속도는 느리지만, 다행히 스레드가 경쟁상태에 있을 때에만 커널 전환을 수행하게 됩니다.

```cs
internal sealed class SimpleHybridLock : IDisposable
{
    //단순 유저 동기화 요소(Interlocked) 에서 사용하기 위한 값
    private int m_Waiters = 0;

    //커널 모드 동기화 요소인 AutoResetEvent 선언
    private readonly AutoResetEvent m_WaiterLock = new AutoResetEvent(false);

    public void Enter()
    {
        //이 스레드는 락을 필요로 합니다.
        if(Interlocked.Increment(ref m_Waiters) == 1)
        {
            return;
        }

        //다른 스레드가 락을 소유하고 있는 경우(경쟁 상태). 이 스레드를 대기시킵니다.
        m_WaiterLock.WaitOne(); //성능에 나쁜 영향을 미친다.
        //WaitOne 메서드가 반환되면, 이 스레드가 락을 소유합니다.
    }

    public void Leave()
    {
        //이 스레드는 락을 해제합니다.
        if(Interlocked.Decrement(ref m_Waiters) == 0)
        {
            return;
        }

        //다른 스레드가 대기하고 있으므로, 그 중 하나를 깨운다.
        m_WaiterLock.Set(); //성능상 나쁜 영향을 미친다.
    }

    public void Dispose() => m_WaiterLock.Dispose();
}
```


### 스피닝, 스레드 소유권, 중복 소유
- 스레드가 커널 모드로 전환하게 되면 아주 짧은 시간 동안이라 락을 소유하는 경우라도 성능에 상당히 좋지 않은 영향을 미치게 됩니다. 따라서 스레드가 락을 대기하기 위해서 커널 모드로 전환하기에 앞서 유저 모드에서 스피닝을 수행하면 커널 모드로 전환하지 않을 수 있어 응용프로그램의 성능을 향상시킬 수 있습니다.
- 이와 별개로 일부 락을 소유한 스레드만이 락을 해제할 수 있는 경우가 있습니다. 이러한 락을 사용하면 락을 소유하고 있는 스레드가 중복적으로 락을 다시 획득하는 것이 가능합니다.
  - Mutex가 바로 이러한 특징을 가진 락의 전형적인 예라 볼 수 있습니다. 그러나 뮤텍스를 사용하지 않더라도 약간의 코드를 추가하면 스피닝과 더불어 스레드의 소유권 및 중복 소유가 가능한 복합 스레드 동기화 요소를 만들어낼 수 있습니다.

```cs
internal sealed class AnotherHybridLock : IDisposable
{
    private int m_Waiters = 0;
    private AutoResetEvent m_WaiterLock = new AutoResetEvent(false);

    //이 필드는 성능 향상을 위해서 스피닝 횟수를 제어합니다.
    private int m_SpinCount = 4000;
    //이 필드는 어떤 스레드가 락을 소유하고 있으며, 몇 회에 걸쳐 락을 중복적으로 소유하려 했는지를 저장합니다.
    private int m_OwningThreadId = 0;
    private int m_Recursion = 0;

    public void Enter()
    {
        //이 메서드를 소유한 스레드가 이미 락을 소유하고 있다면 중복 횟수만 증가시키고 반환합니다.
        var threadId = Thread.CurrentThread.ManagedThreadId;
        if(threadId == m_OwningThreadId)
        {
            m_Recursion++;
            return;
        }

        //이 메서드를 호출한 스레드가 락을 소유하고 있지 않은 경우 락을 획득하기 위해서 다음과 같이 수행합니다.
        var spinWait = new SpinWait();
        for(int spinCount = 0; spinCount < m_SpinCount; spinCount++)
        {
            //락이 해제되었다면 현재 스레드가 락을 획득할 것입니다. 락을 소유한 스레드는 상태 저장 후 반환합니다.
            if(Interlocked.CompareExchange(ref m_Waiters, 1,0) == 0)
            {
                goto GotLock;
            }

            //... 여기서 다른 스레드가 수행될 기회를 줍니다.
            //락을 소유하고 있는 스레드가 빨리 수행되어 소유하고 있던 락을 해제할 수 있도록 하는 거싱 좋습니다.
            spinWait.SpinOnce();
        }

        // 주어진 횟수만큼 스피닝을 수행하였으나 여전히 락을 획득하지 못한 경우, 한번만 더 스피닝을 수행해봅니다.
        if (Interlocked.Increment(ref m_Waiters) > 1)
        {
            //여전히 경쟁 상태이므로, 스레드는 대기할 수밖에 없습니다.
            m_WaiterLock.WaitOne(); //락을 대기합니다. 성능 저하 발생
            // 스레드가 깨어나면, 락을 소유하게 됩니다. 이제 락을 소유한 스레드는 상태 저장 후 반환합니다.
        }

    GotLock:
        //스레드가 락을 소유하면, 스레드의 ID를 저장하고 중복 횟수를 1로 설정합니다.
        m_OwningThreadId = threadId;
        m_Recursion = 1;
    }

    public void Leave()
    {
        //이 메서드를 호출한 스레드가 락을 소유한 것이 아니면 오류
        int threadId = Thread.CurrentThread.ManagedThreadId;
        if (threadId != m_OwningThreadId)
        {
            throw new SynchronizationLockException("Lock not owned by calling thread");
        }
        //중복 횟수를 감소시킵니다. 만일 현재 스레드가 계속 락을 소유해야 하는 상황이면 바로 반환합니다.
        if(--m_Recursion > 0)
        {
            return;
        }

        m_OwningThreadId = 0;
        if(Interlocked.Decrement(ref m_Waiters) == 0)
        {
            //락을 획득하기 위해서 대기하는 스레드가 없다면 바로 반환합니다.
            return;
        }

        //다른 스레드가 대기 중이라면 그 중 하나를 깨웁니다.
        m_WaiterLock.Set(); //여기서 성능저하가 발생합니다.
    }

    public void Dispose() => m_WaiterLock.Dispose();
}
```

- 여기서 29장에서 했던 방식대로 성능 측정을 해보면
```console
Incrementing x : 5000000 : 2
Incrementing x : 10000000 in M : 29
Incrementing x : 15000000 in SpinLock : 138
Incrementing x : 20000000 in SimpleWaitLock : 10156
Incrementing x : 25000000 in SimpleHybridLock : 76
Incrementing x : 30000000 in AnotherHybridLock : 206
```
- AnotherHybridLock이 SimpleHybridLock 에 비해 성능이 좋지 않습니다. 전자의 경우 몇 가지 필드를 더 가지고 있으며 그에따라서 코드도 복잡해지기 때문에 성능저하가 발생하는 것입니다.


### 프레임워크 클래스 라이브러리(FCL) 내의 복합 동기화 요소
- FCL에는 사용자 스레드를 가능한 커널 모드로 전환하지 않고 유저 모드에서 수행될 수 있도록 해주어 응용프로그램의 성능을 향상시킬 수 있는 다양한 복합 스레드 동기화 요소를 포함합니다.
  - 몇몇 동기화 요소는 경쟁 상태가 발생할 때까지 커널 모드 스레드 동기화 요소를 생성하지 않도록 해주어, 객체 생성이나 추가적인 메모리 소요가 발생하지 않도록 해줍니다.
  - 또한 FCL에 포함된 대다수의 동기화 요소는 CancellationToken과 같이 사용될 수 있어서 락을 대기하는 블로킹된 스레드의 작업을 취소할 수도 있습니다.

**ManualResetEventSlim과 SemaphoreSlim 클래스**
- AutoResetEventSlim 과 같은 클래스는 제공되지 않지만, 대부분의 상황에서SemaphoreSlim객체의 maxCount를 1로 설정하여 유사 기능을 수행할 수 있을 것입니다.
- 이 동기화 요소들은 이름에 포함된 커널 모드 동기화 요소들과 각각 대응되며, 단지 유저 모드에서 스피닝을 추가적으로 수행하며 경쟁상태가 발생할 때까지 해당 커널 동기화 요소를 생성하지 않는다는 데 차이가 있습니다.
  - 개별 객체가 제공하는 Wait 메서드들은 타임아웃과 CancellationToken을 매개변수로 취할 수도 있습니다.

**Monitor 클래스와 싱크 블록**
- Monitor는 스피닝과 더불어 스레드 소유권, 중복 소유를 지원하는 상호 배제 락입니다.
- 힙에 생성되는 모든 객체는, 객체와 연관된 동기화 블록(sync block)을 가지고 있습니다. 동기화 블록은 앞에서 살펴본 AnotherHybridLock과 유사한 필드를 가지고 있습니다. (커널 객체를 위한 필드, 싱크 블록을 소유하고 있는 스레드 ID, 중복 횟수, 대기 중인 스레드의 개수)
- Monitor 클래스는 static 클래스로 선언되어 있고, 각각의 메서드들은 힙 객체에 대한 참조 값을 매개변수로 취하여, 해당 객체와 연관되어 있는 동기화 블록의 필드를 수정합니다.

<br>

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/30-1.png" width="70%" height="70%">

<br>

- 이때 힙 상의 모든 객체에 대해서 동기화 블록 구조체를 생성한다는 것은 낭비적입니다. 대부분의 객체들은 동기화 블록을 사용하지 않습니다.
  - 그러므로 CLR에서는 자신이 초기화될 때 동기화 블록을 저장할 수 있는 배열을 네이티브 힙에 미리 할당해둡니다.
    - 4장에서 살펴본대로 힙 상에 객체가 생성된다면 객체별로 두 개의 필드가 추가됩니다.(동기화 블록 인덱스, 타입 객체 포인터) 여기서 동기화 블록 인덱스는 동기화 블록 배열의 인덱스를 나타냅니다.
  - 객체가 최초로 생성되면 객체의 동기화 블록 인덱스 값을 -1로 초기화하며 이는 동기화 블록을 가지지 않음을 나타냅니다.
  - 이후에 Monitor.Enter를 호출하면 CLR은 동기화 블록 배열에서 사용되지 않고 있는 동기화 블록을 찾아서 그 인덱스 값을 할당해줍니다. 즉 이 시점에 힙의 객체는 동기화 블록과 연계되는 것입니다.
  - 이제 Monitor.Exit를 호출하면 동일 싱크 블록을 사용하기 위해서 대기중인 스레드가 있는지 확인하게 되는데, 대기 중인 스레드가 없다면 싱크 블록을 해제 하기 위해서 객체가 가지고 있던 동기화 블록 인덱스를 -1로 변경합니다. 이렇게 함으로써 추후 다른 객체가 동일 싱크 블록을 재사용할 수 있도록 해줍니다.

<br>

- Monitor 사용 시 주의사항으로는 Monitor.Enter ~ Exit 내부에서 비동기 동작을 호출하여 외부 스레드가 잠긴 영역으로 다시 접근하는 경우는 반드시 피해야 한다는 것입니다.
  - MoreEffective C# 항목 42 : 잠긴 영역에서는 외부 코드 호출을 삼가라 참조
- Monitor가 static 클래스라서 내포하는 문제점들이 존재하비다.
  - 만일 어떤 객체가 참조하는 객체의 타입이 System.MarshalByRefObject 클래스를 상속한 경우라면 해당 객체는 프록시 객체를 참조하고 있을 수 있습니다. 프록시 객체를 Monitor의 메서드에 매개변수로 전달하게 되면, 프록시가 참조하는 실제 객체가 락이 되는 것이 아니라 프록시 객체가 락이 될 것입니다.
  - 스레드가 도메인 중립(domain neutral) 공간에 로드된 타입 객체를 매개변수로 Monitor.Enter를 호출하면 프로세스 내의 모든 앱도메인에 걸쳐서 해당 타입의 락을 소유하게 됩니다. 따라서 타입 객체를 Monitor의 메서드에 매개변수로 전달하지 않는 것을 권장합니다.
  - 문자열은 공유될 수 있기 때문에, 서로 완전히 분리되어 있는 코드들이 부지불식간에 동일한 string 객체를 참조할 수 있습니다. 이러한 문자열이 Monitor에 전달되면 서로 전혀 연관없는 코드들이 동기화되어 수행되게 됩니다.
  - Monitor의 메서드들이 매개변수로 Object 타입을 취하기 때문에, 만일 매개변수로 값 타입을 전달하게 되면, 박싱이 일어나게 되고 결국 박싱된 객체에 대해 락을 획득하게 됩니다.
  - [MethodImpl(MethodImplOptions.Synchronized)] 특성을 메서드에 적용하면 JIT 컴파일러는 메서드 내의 코드를 Monitor.Enter와 Monitor.Exit으로 감쌉니다. 만일 이 메서드가 인스턴스 메서드라면, 메서드에 전달된 this 객체에 대해 암시적으로 public 노출된 것과 다름이 없는 락을 소유하게 됩니다. 이 특성은 사용하지 않을 것을 권장합니다.
  - 특정 타입의 타입 생성자를 호출하면 CLR은 이 타입의 타입 객체에 대한 락을 획득하여 단일 스레드를 이용하여 타입 객체를 초기화한 후 정적 필드를 초기화합니다. 다시 말하지만 이 타입은 도메인 중립 공간에 로드될 수도 있기 때문에, 문제를 일으킬 수 있습니다. 예를 들어 타입 생성자의 코드가 무한 루프에 빠지게 되면 특정 프로세스에 포함된 모든 앱도메인에 걸쳐 해당 타입을 사용하지 못하게 됩니다. 따라서 타입 생성자는 가능한 사용하지 않을 것을 권장합니다.

<br><br>

- C# 언어는 lock이라는 키워드를 제공하여 락을 획득하고 해제하는 절차를 단순화할 수 있도록 배려합니다.
```cs
private void SomeMethod()
{
    lock (this)
    {
        //이 코드는 배타적으로 데이터에 접근합니다.
    }
}
```
위의 코드는 아래와 동작이 동일합니다.
```cs
private void SomeMethod()
{
    bool lockTaken = false;
    try
    {
        //여기에서 ThreadAbortException 같은 예외가 발생할 수 있습니다.
        Monitor.Enter(this, ref lockTaken);
        //이 코드는 상호 배타적으로 데이터에 접근합니다.
    }
    finally
    {
        if (lockTaken)
        {
            Monitor.Exit(this);
        }
    }
}
```

- 하지만 lock 키워드는 문제점을 내포하는데, 
  - finally 블록에서 락을 해제하도록 하지만 좋은 생각이 아닙니다. 예외가 발생했다는 것은 객체의 상태 정보가 손상되었을 수도 있다는 것을 의미하고 finally에서 락이 해제되고 나면 다른 스레드가 손상된 데이터를 가지고 작업을 하게 될 위험이 있습니다.
    - 차라리 응용 프로그램을 멈추는게 더 좋을 수도 있습니다.
  - try 블록을 들락날락하는 것은 성능상 좋지 않은 영향을 줍니다. 일부 JIT 컴파일러는 try 블록 내부에서 호출하는 메서드를 인라인 처리하지 않는 경우도 있는데, 이 경우 성능 저하는 더욱 심해집니다.
  - c#의 lock 키워드는 사용하지 않는 것을 권장합니다.

<br><br>

**ReaderWriterLockSlim 클래스**
- 공유 데이터 자원이라 해도 모든 스레드가 데이터를 읽기만 하는 경우라면 데이터에 동시에 접근해도 무방합니다. 반대로 수정하는 경우에는 반드시 상호 배제된 방식으로 데이터에 접근해야만 합니다. ReaderWriterLockSlim 요소는 이러한 문제를 해결하기 위해서 구현된 것으로, 다음과 같이 스레드를 제어합니다.
  - 특정 스레드가 데이터를 쓰고 있으면, 다른 스레드들의 모든 데이터 접근 요청은 블로킹됩니다.
  - 특정 스레드가 데이터를 읽고 있으면, 다른 스레드들의 읽기 요청은 블로킹되지 않고 수행될 수 있습니다. 하지만 쓰기 요청은 블로킹됩니다.
  - 데이터를 쓰고 있던 스레드가 작업을 완료하면, 쓰기 요청을 한 스레드들 중 단 하나의 스레드만 블로킹을 해제하여 데이터를 쓸 수 있도록 하거나 읽기 요청을 한 다수의 스레드들의 블로킹을 해제하여 데이터를 동시에 읽을 수 있도록 해줄 수 있습니다. 만일 블로킹된 스레드가 없다면 락을 해제하여 다음에 스레드들이 사용할 수 있도록 합니다.
  - 여러 스레드들의 읽기 작업이 모두 완료되면, 쓰기 요청을 한 스레드들 중 단 하나의 스레드만이 블로킹을 해제하여 데이터를 쓸 수 있도록 해줍니다. 만일 블로킹된 스레드가 없다면 락을 해제하여 다음에 스레드들이 사용할 수 있도록 합니다.



**OneManyLock 클래스**

저자가 직접 작성한 ReaderWriterLockSlim 클래스

...

**CountdownEvent 클래스**

내부 카운터 값이 0이 될 때까지 스레드를 블로킹시킨다.(세마포어의 동작방식을 거꾸로 뒤집어 놓은 방식)

...

**Barrier 클래스**
흔히 발생하는 문제를 해결하려고 만들어진 클래스는 아닙니다. 개발자들이 활용할 일은 적습니다.
- Barrier는 보통 여러 스레드들을 이용하여 병렬적으로 알고리즘을 단계별로 수행하려는 경우, 이들 스레드를 제어하기 위한 용도로 사용됩니다.


#### 스레드를 동기화 요소에 대한 요약
- 스레드를 블로킹하는 코드를 최대한 작성하지 않는 것을 권장합니다. Interlocked와 같은 메서드를 활용하는 쪽이 스레드 블로킹을 방지할 수 있습니다.
- 그래도 만일 스레드 블로킹을 고려해야 하는 경우
  - 프로그래밍 모델 단순화 : 스레드 블로킹을 사용한다는 것은 콜백 메서드 없이 프로그램의 코드를 순차적으로 작성하기 위해서 일부 리소스와 성능을 희생하는 것입니다. 하지만 콜백 메서드 없이 응용 프로그램을 순차적으로 작성하기만 하면 됩니다.
  - 스레드가 고유의 목적을 가진다 : GUI 기능을 담당하는 스레드를 배정할 경우, gui 스레드는 다른 작업이 수행될 때 잠시간 블로킹 해두었다가 그 이후에 ui나 컨트롤러를 갱신하는 경우가 있습니다.
- 락을 중복 소유하는 것은 성능에 나쁜 영향을 끼칩니다. 하지만 Monitor는 중복 소유를 허용 함에도 성능이 상당히 좋은 편입니다.(Monitor의 일부가 관리 코드가 아니라 네이티브 코드로 구현되었기 때문입니다) 
- 또한 finally 블록 내에서 락을 해제하는 것은 피하는 것이 좋습니다. 예외 처리 블록으로 진입하거나 빠져 나오는 작업은 상당한 성능 저하를 유발하거니와 상태를 변경하던 중간에 예외가 발생하면 상태 정보가 손상되어 다른 스레드들이 이로 인해 이상 동작을 할 수 있습니다.

### 잘 알려진 이중 확인 락 기법
- 싱글톤 패턴에서 다수의 스레드가 처음 싱글톤 객체에 접근할 때 객체가 여러 개 생성되는 일은 막아야 합니다(늦은 초기화, lazy initialization). 

```cs
internal sealed class Singleton
{
    private static readonly object s_Lock = new object();
    private static Singleton s_Value = null;
    
    //생성자를 private로 선언하여 외부에서 이 클래스의 인스턴스를 생성할 수 없도록 하고 있다.
    private Singleton()
    {

    }

    //c#을 이용하여 구현한 이중확인 락 기법
    public static Singleton Instance
    {
        get
        {
            if(s_Value != null)
            {
                return s_Value;
            }
            Monitor.Enter(s_Lock);
            if(s_Value == null) //메모리 펜스를 통해 CPU 레지스터에 캐싱된 s_Value 값을 읽는것이 아닌 메모리에서 직접 s_Value 값을 조회하도록 합니다.
            {
                var tmp = new Singleton();
                Volatile.Write(ref s_Value, tmp);   //메모리 펜스
            }
            Monitor.Exit(s_Lock);
            return s_Value;
        }
    }
}
```
메모리 펜스가 없다면
- 컴파일러는 이 코드를 만났을 때 Singleton 객체를 위한 메모리를 할당하고, 생성자를 호출하여 필드의 값을 초기화한 후, 그 값을 s_Value 필드에 그 참조 값을 할당하도록 코드를 생성할 것이라고 생각합니다.
  - 스레드가 변수의 값을 살펴볼 수 있도록 하는 작업을 퍼블리싱(publishing) 이라고 하는데 사실 컴파일러는 Singleton을 위한 메모리를 할당하고, s_Value에 참조 값을 퍼블리싱(할당)한 후에 생성자를 호출합니다.
  - 단일 스레드의 경우 이렇게 순서가 바뀌더라도 문제가 발생하지 않지만, 다중 스레드에서는 문제가 됩니다. s_Value에 참조 값을 퍼블리싱하고 생성자를 아직 호출하기 이전인 상황에서 다른 스레드가 싱글톤 객체를 참조한다면 이 스레드는 s_Value가 null이 아님을 확인하고 해당 객체를 사용하려 할 것이다.(하지만 생성자 호출이 완료되지 않은 상태)
- Volatile.Write를 이용하여 이 같은 문제를 해결합니다. 이 방법을 통해 tmp내의 참조 값을 s_Value로 퍼블리싱하기 전에 생성자가 수행을 완료하였음을 보증할 수 있습니다.

```cs
internal sealed class Singleton
{
    private static Singleton s_Value = new Singleton();
    public static Singleton Instance => s_Value;
    
    //생성자를 private로 선언하여 외부에서 이 클래스의 인스턴스를 생성할 수 없도록 하고 있다.
    private Singleton()
    {

    }
}
```
- 싱글톤을 구현하는 다른 방법
  - CLR은 타입 생성자의 스레드 안정성을 보증하므로 해당 싱글톤 객체는 단 한개만 생성됩니다.
  - 대신 해당 타입 생성자는 타입을 참조할때 수행되므로, 싱글톤 객체를 참조하는 것이 아닌 다른 정적 멤버를 참조하는 경우에도 싱글톤 객체가 생성됩니다.

```cs
internal sealed class Singleton
{
    private static Singleton s_Value = new Singleton();
    public static Singleton Instance
    {
        get
        {
            if(s_Value != null)
            {
                return s_Value;
            }

            var tmp = new Singleton();
            Interlocked.CompareExchange(ref s_Value, tmp, null);

            //만약 다수의 스레드가 동시에 싱글톤 객체를 생성한다 하더라도, s_Value에는 단 하나의 객체만이 할당되게 됩니다. 나머지는 전부 가비지로 수집됩니다.

            return s_Value;
        }
    }
    
    //생성자를 private로 선언하여 외부에서 이 클래스의 인스턴스를 생성할 수 없도록 하고 있다.
    private Singleton()
    {

    }
}
```
- 싱글톤을 구현하는 세 번째 방법
  - Interlocked를 활용함으로써 스레드를 블로킹하지 않고도 빠른 성능으로 싱글톤 객체를 참조할 수 있습니다.

**Lazy 활용**
- System.Lazy 클래스를 통해 위의 기법을 활용하도록 코드를 작성할 수 있습니다.

```cs
public static void Main()
{
    //DateTime을 이용하는 늦은 초기화 랩퍼(lazy-Initialization wrapper)를 생성합니다.
    Lazy<string> s = new Lazy<string>(() => DateTime.Now.ToLongTimeString(), true);

    Console.WriteLine($"value Created : {s.IsValueCreated}");   // Value 값을 가져올 수 없으므로 false를 반환
    Console.WriteLine($"value : {s.Value}");    // 이 시점에 매개변수로 전달한 델리게이트가 호출
    Console.WriteLine($"value Created : {s.IsValueCreated}");   // Value 값을 가져올 수 있으므로 true 반환
    Thread.Sleep(1000);
    Console.WriteLine($"value : {s.Value}");    // 이번에는 델리게이트 호출 X, 이전과 동일한 값 출력
}
```

- LazyInitializer 활용
```cs
public static void Main()
{
    //아래 방식은 내부적으로 Interlocked.CompareExchange를 활용합니다.

    string name = null;
    //name이 null이므로, 델리게이트가 수행되고 name이 초기화됩니다.
    LazyInitializer.EnsureInitialized(ref name, () => "Jeffrey");
    Console.WriteLine(name);

    //name이 null이 아니므로, 델리게이트가 수행되지 않으며, name이 변경되지 않습니다.
    LazyInitializer.EnsureInitialized(ref name, () => "Richter"); 
    Console.WriteLine(name);    //여전히 "Jeffrey" 출력



    //아래 방식은 내부적으로 Monitor의 Enter와 Exit을 사용할 수 있도록 syncLock을 전달합니다.
    name = null;
    var lockObj = new object();
    LazyInitializer.EnsureInitialized(ref name, ref lockObj, () => "Richter");
    Console.WriteLine(name);

    LazyInitializer.EnsureInitialized(ref name, ref lockObj, () => "Jeffrey");
    Console.WriteLine(name);    //여전히 "Richter" 출력
}
```


### 조건 변수 패턴
- 복잡한 조건이 참일 경우에만 특정 코드를 수행하도록 하고 싶을 수 있습니다. 이를 위한 하나의 방법으로 스레드를 계속 스피닝시키면서 조건을 지속적으로 확인하는 방법이 있을 수 있습니다. 그러나 이 방법은 CPU 시간을 낭비하게 되는데 여러 변수로 구성되어 있는 복잡한 조건 계산을 효율적으로 동기화할 수 있는 패턴이 있습니다.
- 조건 변수 패턴(condition variable pattern)이라 부릅니다.

```cs
internal sealed class ConditionVariablePattern
{
    private readonly object m_Lock = new object();
    private bool m_Condition = false;

    public void Thread1()
    {
        Monitor.Enter(m_Lock);

        //lock 을 획득한 상태로 복잡한 조건을 "원자적"으로 확인합니다.
        while (!m_Condition)
        {
            //조건을 만족하지 않으면 다른 스레드가 조건을 변경할 때까지 기다립니다.
            Monitor.Wait(m_Lock); // 임시로 작을 해제해서 다른 스레드가 락을 획득할 수 있도록 해줍니다.
        }

        //...
        //조건을 만족하면 데이터를 처리합니다

        Monitor.Exit(m_Lock);
    }

    public void Thread2()
    {
        Monitor.Enter(m_Lock);

        //...
        //데이터를 처리하고 조건을 수정합니다.

        m_Condition = true;

        Monitor.Pulse(m_Lock);      //락을 해제하고 대기 중인 스레드 중 하나를 깨웁니다.
        //Monitor.PulseAll(m_Lock);   //락을 해제하고 대기 중인 모든 스레드를 깨웁니다. 여기서 다른 모든 스레드를 깨우더라도 다시 락을 획득하는 스레드는 하나입니다.

        Monitor.Exit(m_Lock);
    }
}
```
- 첫번째 스레드에서는 조건을 만족하지 않을 시 해당 스레드를 블로킹 시키고 다른 스레드가 조건 처리 작업을 수행할 수 있도록 합니다. 스레드를 스피닝시키면서 계속 조건을 확인할 수도 있지만, 이는 CPU시간을 낭비하기 때문에 Wait 메소드를 호출합니다.
- 두번째 스레드에서는 조건을 처리하는 작업을 수행하고 블로킹된 스레드를 다시 깨웁니다. 


- 조건 변수 패턴을 활용한 스레드 안전한 큐의 구현
```cs
//스레드 안정적인 큐의 구현
internal sealed class SynchronizedQueue<T>
{
    private readonly object m_Lock = new object();
    private readonly Queue<T> m_Queue = new Queue<T>();

    public void Enqueue(T item)
    {
        Monitor.Enter(m_Lock);
        //큐에 아이템을 삽입한 후에 대기 중인 스레드 중 하나(혹은 전체)를 깨웁니다.
        m_Queue.Enqueue(item);
        Monitor.PulseAll(m_Lock);
        Monitor.Exit(m_Lock);
    }

    public T Dequeue()
    {
        Monitor.Enter(m_Lock);
        while(m_Queue.Count == 0)
        {
            Monitor.Wait(m_Lock);
        }

        var item = m_Queue.Dequeue();
        Monitor.Exit(m_Lock);
        return item;
    }
}
```


### 비동기 동기화
- 락은 매우 대중화된 기법이지만, 락을 너무 오랫동안 소유하게 되면 확장성에 치면적인 문제를 야기할 수 있습니다. 따라서 락이 필요한 위치에 비동기 동기화 요소를 사용하는 것은 상당히 유용하다고 할 수 있습니다. 락을 획득할 수 없을 때 단순히 반환해 버리거나 다른 일을 처리할 수 있어서, 스레드가 블로킹되는 것을 피할 수 있으며 이후 락을 획득할 수 있는 상황이 되면 어떤 식으로든 작업을 재개하여 락으로 보호하려던 자원에 접근할 수 있습니다.
- SemaphoreSlim 클래스의 WaitAsync 메서드는 이러한 아이디어를 구현하였습니다. 이 메서드를 이용하면 비동기적으로 리소스에 대한 동기 접근을 수행할 수 있습니다.(스레드를 블로킹하지 않고)

```cs
private static async Task AccessResourceViaAsyncSynchronization(SemaphoreSlim asyncLock)
{
    //...
    //여기서는 어떤 코드든지 수행할 수 있습니다.

    await asyncLock.WaitAsync(); //리소스에 대한 배타적인 접근을 위해서 락을 요청합니다.
                                 //여기서 락을 회득하였다면 다른 스레드가 리소스에 접근 하지 못합니다.

    //...
    //여기서 상호 배타적으로 리소스를 활용합니다.

    //작업을 마쳤다면 락을 반환하여 다른 코드에서 리소스를 사용할 수 있게 합니다.
    asyncLock.Release();

    //...
    //여기서는 어떤 코드든지 수행할 수 있습니다.
}
```
- 아래는 책에서 저자가 작성한 리더-라이터 구조의 비동기 락
  - 내부적으로 커널 모드 스레드 동기화 요소를 사용하지 않기 때문에 스레드를 블로킹하지 않습니다.
```cs
private static async Task AccessResourceViaAsyncSynchronization(AsyncOneManyLock asyncLock)
{
    // 여기서는 어떤 코드든지 수행 가능

    //동시에 접근하려면 OneManyMode.Exclusive나 OneManyMode.Shared를 사용
    await asyncLock.WaitAsync(OneManyMode.Shared);

    //상호 배타적으로 리소스를 읽는다.

    asyncLock.Release();
    // 여기서는 어떤 코드든지 수행 가능
}

public enum OneManyMode
{
    Exclusive, 
    Shared
}

public sealed class AsyncOneManyLock
{
    #region 락 코드
    private SpinLock m_Lock = new SpinLock(true); //읽기 전용으로 사용하지 않음
    private void Lock()
    {
        bool taken = false;
        m_Lock.Enter(ref taken);
    }
    private void Unlock()
    {
        m_Lock.Exit();
    }
    #endregion

    #region 락의 상태와 헬퍼 메서드
    private int m_State = 0;
    private bool IsFree => m_State == 0;
    private bool IsOwnedByWriter => m_State == -1;
    private bool IsOwnedByReaders => m_State > 0;
    private int AddReaders(int count) => m_State += count;
    private int SubtractReader() => --m_State;
    private void MakeWriter() => m_State = -1;
    private void MakeFree() => m_State = 0;
    #endregion

    //경쟁 상태가 아닌 경우에는 성능을 높이고 메모리 소비를 줄이기 위해서 사용
    private readonly Task m_NoContentionAccessGranter;

    //대기 중인 개별 라이터 스레드는 큐잉된 각자의 TaskCompletionSource에 의해서 깨어납니다.
    private readonly Queue<TaskCompletionSource<Object>> m_WaitingWriters = new Queue<TaskCompletionSource<object>>();

    //대기 중인 모든 리더 스레드는 단일의 TaskCompletioniSource 의해서 깨어난다
    private TaskCompletionSource<Object> m_WaitingReadersSignal = new TaskCompletionSource<Object>();
    private int m_NumWaitingReaders = 0;

    public AsyncOneManyLock()
    {
        m_NoContentionAccessGranter = Task.FromResult<Object>(null);
    }

    public Task WaitAsync(OneManyMode mode)
    {
        var accessGranter = m_NoContentionAccessGranter; //경쟁 상태가 아니라고 가정

        Lock();
        switch (mode)
        {
            case OneManyMode.Exclusive:
                {
                    if (IsFree)
                    {
                        MakeWriter(); // 경쟁 상태가 아니다.
                    }
                    else
                    {
                        //경쟁 상태 : 새로운 라이터 태스크를 큐에 삽입하여 라이터 스레드가 대기하게 한 후 이를 반환
                        var tcs = new TaskCompletionSource<object>();
                        m_WaitingWriters.Enqueue(tcs);
                        accessGranter = tcs.Task;
                    }
                    break;
                }
            case OneManyMode.Shared:
                {
                    if(IsFree || 
                        (IsOwnedByReaders && m_WaitingWriters.Count == 0))
                    {
                        AddReaders(1); // 경쟁 상태가 아니다.
                    }
                    else
                    {
                        //경쟁 상태 : 대기 중인 리더 스레드의 개수를 증가하고, 리더 태스크가 대기하게 한 후 이를 반환
                        m_NumWaitingReaders++;
                        accessGranter = m_WaitingReadersSignal.Task.ContinueWith(task => task.Result);
                    }
                    break;
                }
        }
        Unlock();

        return accessGranter;
    }

    public void Release()
    {
        TaskCompletionSource<object> accessGranter = null; //어떤 코드도 해제하지 않았다고 가정

        Lock();
        if (IsOwnedByWriter)
        {
            MakeFree(); //라이터 스레드인 경우
        }
        else
        {
            SubtractReader(); //리더 스레드인 겅우
        }

        if (IsFree)
        {
            //프리 상태이면, 대기 중인 라이터 스레드 하나를 깨우거나 모든 리더 스레드를 깨웁니다.
            if(m_WaitingWriters.Count > 0)
            {
                MakeWriter();
                accessGranter = m_WaitingWriters.Dequeue();
            }
            else if(m_NumWaitingReaders > 0)
            {
                AddReaders(m_NumWaitingReaders);
                m_NumWaitingReaders = 0;
                accessGranter = m_WaitingReadersSignal;

                //추후 리더 스레드를 대기시키기 위해서 새로운 TCS를 생성
                m_WaitingReadersSignal = new TaskCompletionSource<object>();
            }
        }
        Unlock();

        //리더/라이터 스레드가 락을 벋어날 수 있도록 하여 경쟁 상태가 발생할 수 있는 가능성을 낮추어 성능을 개선
        accessGranter?.SetResult(null);
    }
}
```

### Concurrent 컬렉션 클래스
- FCL은 ConcurrentQueue, ConcurrentStack, ConcurrentDictionary, ConcurrentBag의 네 개의 스레드-안정적인 컬렉션 클래스를 제공합니다.
  - 해당 클래스들은 스레드를 블로킹하지 않습니다. 따라서 컬렉션 내에 존재하지 않는 항목을 가져오려고 하는 경우, 해당 항목이 삽입될 때까지 기다리는 것이 아니라 즉각 반환됩니다. (TryDequeue 등, 자원을 가져올 수 없다면 false 반환)
  - ConcurrentStack, ConcurrentQueue, ConcurrentBag 컬렉션은 IProducerConsumerCollection 인터페이스를 구현하고 있습니다. 이 인터페이스를 구현하고 있는 클래스는 블로킹 컬렉션으로 변경될 수 있는데 이와 같이 변경되면 컬렉션이 가득 찬 경우 항목을 생산하는 스레드가 블로킹될 수 있으며, 컬렉션이 비어있을 때는 항목을 소비하는 스레드가 블로킹될 수 있습니다.
</details>
