# 제프리 리처의 CLR via C# 4판

## 1장. CLR의 실행 모델

<details>
  <summary>fold/unfold</summary>

### 공용 언어 런타임(CLR, Common Language Runtime)
- 서로 다른 프로그래밍 언어들 사이에서 공동으로 사용할 수 있는 실행환경(Runtime)을 말합니다.
- CLR을 지원하는 언어라면 CLR의 기능(메모리 관리, 어셈블리 로딩, 스레드 동기화 등)을 자유롭게 사용할 수 있습니다.

<img src="https://1.bp.blogspot.com/-g9AYNMBpG1s/U7Qii8mJm_I/AAAAAAAAAqg/bTFteXucTQA/s1600/2014-07-02_111719.png" width="40%" height="40%">

- CLR은 관리모듈을 실행시킵니다. 관리 모듈(managed module)이란 CLR을 지원하는 프로그래밍 언어를 컴파일한 결과물로 크게 IL과 메타데이터로 이루어집니다.

### 메타데이터(metadata)
- 메타데이터는 모듈 내의 타입과 그들의 구성 멤버 등의 대한 데이터 테이블입니다.
  - 테이블은 크게 두 종류로 나누어집니다. 하나는 소스 코드에 포함된 타입들과 그 멤버들의 정보, 다른 하나는 소스 코드가 참조하는 타입들과 멤버들에 대한 정보입니다.
- 프로그램 실행 파일이 생성될 시 메타데이터는 해당 파일 안에 포함됩니다.
- visual studio의 인텔리센스는 메타데이터를 활용합니다.
- 메타데이터는 각각의 객체(object)들이 메모리 블록 안에 serialization 할 수 있도록 합니다. 이후 deserialization을 거쳐서 객체가 원래 상태로 복원될 수 있습니다.
- 가비지 컬렉터(garbage collector)가 객체의 생명주기를 추적할 때 메타데이터를 활용합니다.

### 어셈블리(assembly)
CLR은 실제로 모듈들을 다루지는 않으며, 어셈블리를 다루게 됩니다. 어셈블리는 명확하게 정의하기엔 추상적인 개념이며 아래와 같습니다.

- 하나의 어셈블리는 하나 이상의 모듈이나 리소스 파일들에 대한 논리적 그룹입니다.
- 하나의 어셈블리는 재사용, 보안, 버전 관리의 가장 작은 단위입니다.

<img src="https://i.stack.imgur.com/s6gSO.png" width="60%" height="60%">

위의 그림에서 다수의 모듈과 리소스 파일이 결합되어 하나의 어셈블리로 만들어집니다.
- 매니페스트 : 어셈블리 안의 모듈 및 리소스 파일들의 집합을 설명합니다.

### 어셈블리 실행

<img src="https://i.stack.imgur.com/LXVmH.png" width="60%" height="60%">

위의 그림에서 JIT(just in time) 컴파일러가 IL 명령어를 실행하는 과정은 대략 아래와 같습니다.

1. Main 메서드가 실행되기 바로 직전에, CLR은 main 메서드 안에서 참조된 모든 타입들을 파악합니다. 이때 CLR은 내부적으로 자료구조를 생성해 참조된 타입을 관리하는 용도로 사용합니다.
2. Main 메서드가 WriteLine 메서드를 호출할 때 JIT 컴파일러가 호출됩니다. 컴파일러는 메서드의 IL 코드를 네이티브 CPU 명령어로 컴파일합니다. 
3. CLR은 메모리를 동적할당한 뒤 해당 공간에 네이티브 cpu 명령어를 저장합니다.
4. CLR은 새로 생성된 네이티브 cpu 명령어의 메모리 주소를 저장합니다.
5. 실제 코드를 실행합니다.
6. 두번째로 WriteLine 메서드를 호출할 때 CLR은 이미 WriteLine 메서드에 대한 코드를 이미 검사하였고 컴파일이 완료했다는 사실을 확인합니다. 곧바로 네이티브 cpu 명령어가 저장된 메모리로 이동해 코드를 실행합니다. 추가적인 jit 컴파일러 호출은 없습니다.


- 성능 저하는 메서드가 최초로 호출될 때에만 발생합니다.
- JIT 컴파일러는 생성한 네이티브 cpu 명령어를 동적 메모리상에 저장하며 응용프로그램이 종료될 때 자동으로 반환합니다.

### IL과 검증, 안전하지 않은 코드
- IL은 스택 기반의 언어로 모든 IL 명령어들과 연산자가 실행 스택 위에 쌓이고 꺼내어가는 방식으로 실행됩니다.
- IL의 가장 큰 장점은 cpu 내부로부터 추상화된 동작들에 대한 것이 아닙니다. 응용프로그램의 견고함과 보안을 책임진다는 것에 더 의의가 있습니다.
  - IL을 네이티브 CPU 명령어로 컴파일하는 동안, CLR은 확인(verification) 과정을 통해 코드를 검사하고 안전성을 점검합니다.
  - 확인 과정을 통하여 메모리를 잘못된 방향으로 접근하거나 사용하지 않으며, 다른 응용프로그램 코드에 역으로 영향을 주는 일이 없게 합니다. 대표적인 예로 응용프로그램의 물리 메모리와 가상 메모리 주소가 달라 잘못 접근하는 경우를 방지하는 경우가 있습니다.
- C# 컴파일러는 기본적으로 안전한 코드를 만듭니다. 안전한 코드는 확인 과정을 안전하게 통과할 수 있습니다. 반면에 안전하지 않은 코드를 사용하는 경우도 있는데 unsafe 키워드를 추가해서 작성할 수 있습니다. 직접 메모리에 접근하거나 비관리 코드와의 상호운용을 할때 유용합니다.

### 공용 언어 사양
- 공용 타입 시스템(CTS, Common Type System) : 마이크로소프트는 공용 타입 시스템(CTS) 표준을 정의하여 CLR 에서 타입이 어떻게 정의되어야 하고 동작되어야 하는지 명시하고 있습니다.
  - 모든 타입은 미리 정의된 타입인 System.Object 를 상속받습니다.

- CLR은 서로 다른 언어 사이에서 통신할 수 있게 해주는 것 이상으로 모든 언어들을 연계하고 어떤 언어로 쓰인 객체가 다른 언어에서도 완전히 동일한 의미와 사용법을 가지는 동등한 객체로 인지할 수 있게 해줍니다.
  - 이러한 통합이 가능한 이유는 CLR의 표준 타입 집합들과 메타데이터 그리고 공용 실행 환경(Common Execution Environment) 덕분입니다.
- 공용 언어 사양(CLS, Common Language Specification) : 마이크로소프트는 공용 언어사양을 정의하여 컴파일러를 제조할 때 준수해야 할 최소한의 사항들을 정의합니다. 여기에는 다른 CLR 위에서 동작하는 언어들 사이에서 반드시 지원해야할 내용들을 포함합니다.
  - 공용 언어 사양을 통해 언어 사이의 공통적인 규칙이 필수적으로 포함될 수 있게 되었으며 CLR은 이를 통해서 다양한 언어간의 상호 연계를 가능하게 합니다.

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRLR0g7k3JcNHoagiCnQjDYZEEjiDnLTYpKkQ&usqp=CAU" width="40%" height="40%">

</details>

## 4장. 타입의 기초

<details>
<summary>fold/unfold</summary>

### 모든 타입은 System.Object를 상속한다.

#### Reference
- [Microsoft : Object Class](https://docs.microsoft.com/en-us/dotnet/api/system.object?view=net-5.0)
---

- 모든 타입들은 궁극적으로 System.Object 타입으로부터 파생됩니다.
- 따라서 C#의 모든 객체는 System.Object의 public/protected 메서드(GetHashCode, ToString 등)를 사용할 수 있습니다.

```cs
//아래 두 클래스 선언은 동일합니다.

class Widget 
{

}

class Widget : System.Object
{

}


```

- CLR은 모든 객체들을 반드시 new 연산자에 의하여 만들어지도록 하고 있습니다. 
```cs
Widget widget = new Widget("Construct Param");
```

- new 연산자는 아래의 일을 합니다.
  - 할당하려는 타입과 System.Object 타입, 그리고 System.Object를 상속받은 모든 기본 타입들에서 정의된 모든 인스턴스 필드들을 메모리에 할당하기 위한 바이트 수를 계산합니다.
     - 힙상의 모든 객체에는 타입 객체 포인터(Type Object Pointer)와 동기화 블록 인덱스(Sync Block Index)가 추가됩니다. CLR은 두 멤버를 통해 객체를 관리합니다.
     - 추가 멤버들을 위한 바이트는 객체의 실제 크기에 포함됩니다.
  - 필요한 만큼 메모리를 할당합니다. 처음 할당할 때 모든 바이트를 0으로 초기화합니다.
  - 객체의 타입 객체 포인터와 동기화 블록 인덱스 멤버를 초기화합니다.
  - 생성자를 호출하고 new 연산자에 서술된 매개변수가 전달됩니다. 파생클래스의 생성자 부터 호출되며 System.Object의 생성자가 가장 마지막에 호출됩니다.


### 타입 간 캐스팅하기

- CLR의 중요한 기능들 중 하나는 타입 안전성입니다. 실행 시점에서 CLR은 객체의 정확한 타입이 무엇인지 항상 파악하고 있습니다.

```cs

    //암시적으로 System.Object를 상속합니다.
    internal class Widget { }
    
    public sealed class Program
    {
        public static void Main()
        {
            Object o = new Widget(); //암시적 변환이며, 안전합니다.

            //Object 타입으로부터 Widget 클래스를 타입이 파생되었기 때문에 명시적 형 변환 연산자가 필요합니다.
            //경우에 따라 런타임 오류가 발생할 수 있습니다.
            Widget w = (Widget)o;
        }
    }

```
### C#의 is와 as 연산자로 캐스팅하기
- C#에서 캐스팅 연산을 다룰 때 is/as 를 활용할 수 있습니다.

```cs
    Object o = new Object();
    Boolean result1 = o is Object;  //true
    Boolean result2 = o is Widget;  //false
```
- 아래와 같이 활용할 수 있으나, 아래의 경우는 CLR 이 타입을 두 번 점검합니다.

```cs
    //if 문에서 한번 검사합니다.
    if(o is Widget)
    {
        //명시적 형변환을 수행하면서 또 한번 검사합니다.
        Widget w = (Widget)o;
    }
```

- 위와 같은 상황을 방지하기 위해 as 연산자를 사용할 수 있습니다.
```cs
    //여기서 한번 타입을 점검합니다.
    Widget w = o as Widget;
    if(w != null)
    {
        //여기서 w를 사용합니다.
    }
```

### 실행 시점과의 연관성

- 아래는 M1 메서드가 호출되기 직전의 스레드 스택의 상태입니다. 할당된 스레드에서 M1 메서드를 호출할 것입니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-2.jpg" width="40%" height="40%">

- 대게 메서드들은 프롤로그 코드(Prologue Code)를 포함하며 메서드 안의 코드가 동작하도록 초기화를 거치게 합니다.
- 여기에 대응되는 에필로그 코드(Epilogue Code)도 있어서 메서드 실행 후의 정리 작업을 수행하게 합니다. 그리고 원래 호출자에게 돌아갈 수 있게 준비합니다.


- 아래에서 프롤로그 코드는 스레드 스택에 지역변수를 위한 메모리 공간을 할당합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-3.jpg" width="40%" height="40%">

- 아래에서 M2 메서드를 호출합니다. 메서드로 넘길 매개변수와 호출이 끝나고 되돌아갈 위치를 나타내는 주소값이 스택에 올라갑니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-4.png" width="40%" height="40%">

- M2 메서드의 지역변수가 스택에 올라갑니다. M2 메서드가 종료되면 리턴 주소를 확인해 다시 M1 메서드를 수행하던 위치로 되돌아갈 것입니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-5.jpg" width="40%" height="40%">



- 이제 아래의 두 클래스가 정의되어 있다고 가정합시다.

```cs

    public internal class Employee
    {
        public Int32 GetYearsEmployed() { ... }
        public virtual string GetProgressReport() { ... }
        public static Employee Lookup(string name) { ... }
    }

    public internal class Manager : Employee
    {
        public override string GetProgressReport() { ... }
    }
```

- 처음에 Windows 프로세스가 실행되고, CLR이 로드되고, managed heap이 초기화되고, 스택공간과 스레드가 할당될 것입니다. 이 스레드는 초기 코드를 실행한 상태고 이제 M3 메서드를 호출하려고 합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-6.png" width="40%" height="40%">

- JIT 컴파일러가 M3 메서드의 IL 코드를 컴파일하면서 M3 메서드 안의 타입들과 변수 정보에 대해서 파악합니다.
  - 이 시점에서 CLR은 이러한 타입들을 포함하는 어셈블리들을 로드할 것이며, 어셈블리의 메타데이터를 통해 타입 정보를 추출하여 타입에 대한 정보를 서술하는 또다른 자료 구조를 생성합니다.
  - 아래 그림에서 Int32와 string 과 같은 기본적인 타입 정보는 이미 올라와 있다고 가정하며 나타내지 않습니다.

- 아래 그림처럼 힙 위에 만들어지는 모든 객체는 타입 객체 포인터와 동기화 블록 인덱스 멤버를 추가적으로 가집니다.
- 타입을 선언할 때 정의된 정적 데이터는 타입 객체 안에 포함됩니다. 그리고 타입 객체가 생성되는 시점에 초기화됩니다.
- 마지막으로 타입 내의 메서드 하나당 한 개의 항목이 포함된 메서드 테이블도 만들어지게 됩니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-7.png" width="40%" height="40%">

- 스레드의 스택상에 지역 변수를 위한 메모리를 할당합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-8.png" width="40%" height="40%">

- 매니저 객체가 생성됩니다. 역시 타입객체 포인터와 동기화 블록 인덱스를 가지며, 타입 객체 포인터는 Manager의 정확한 타입 객체를 가리키도록 초기화됩니다.
- CLR은 객체를 생성하면서 객체의 모든 인스턴스 필드를 0 또는 NULL 값으로 초기화합니다.
- 그 다음 객체의 생성자를 호출하면서 인스턴스의 데이터를 수정합니다.
- 이후 new 연산자는 만들어진 Manager 객체의 메모리 주소를 반환하여 스레드 스택상에 할당된 변수 e에 저장합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-9.png" width="40%" height="40%">

- Lookup 메서드를 호출할 때 JIT 컴파일러는 IL 코드를 컴파일하고 컴파일된 코드를 동적할당된 메모리에 저장합니다.
- joe가 관리직에 해당한다면 새로운 Mananger 객체가 생성되고 지역변수 e에 저장합니다. 
- 이때 처음 만들어진 Manager 객체는 아무도 참조하지 않으므로 가비지 수거 대상이 됩니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-10.png" width="40%" height="40%">

- GetYearsEmployed 메서드를 호출합니다. 마찬가지로 JIT 컴파일을 거친 뒤 코드를 수행합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-11.png" width="40%" height="40%">

- 가상 메서드 GetProgressReport를 호출합니다.
  - 가상 메서드를 호출할 때에는 JIT 컴파일러가 호출에 앞서 추가적인 코드를 메서드를 호출할 때마다 그 안에 추가하게 됩니다.
  - e의 타입은 Employee 이지만 실제 가리키는 객체는 Manager 타입입니다. 코드를 수행할 때 객체 타입 포인터 멤버가 가리키고 있는 타입 객체 정보를 확인하여 실제 어떤 객체를 가리키고 있는지 파악합니다.
  - 이후 실제 객체 타입의 메서드 테이블에서 호출하려는 메서드를 찾아냅니다. 역시 필요하면 JIT 컴파일을 수행합니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-12.png" width="40%" height="40%">

- 아래 그림에서 타입 객체 역시 객체에 해당하므로, 타입 객체 포인터를 멤버를 가진다는 것을 확인할 수 있습니다.
  - 해당 타입 객체 포인터의 경우 System.Type 이라는 MSCORLIB.DLL 안의 선언되어 있는 타입 객체를 가리키게 됩니다.
  - System.Type 타입 객체의 경우 타입 객체 포인터 멤버가 자기 자신을 가리킵니다. System.Type 타입 자체가 그 자체로 객체의 타입 객체이기 때문입니다.

<img src="https://github.com/wlsvy/TIL/blob/master/Document/C%23/CLRviaC%23_Image/4-13.png" width="40%" height="40%">

</details>

## 5장. 기본, 참조, 값 타입

<details>
<summary>fold/unfold</summary>

### 프로그래밍 언어 기본 타입

#### Reference
- [Microsoft : c# 내장 타입](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/built-in-types)
---

- 컴파일러가 직접 지원하는 데이터 타입들을 기본 타입(Primitive Type)이라고 부릅니다.
  - 대표적인 예로 int 타입이 있으며 아래 코드 4줄은 전부 같은 IL코드를 생성합니다.

```cs
    int a = 0;
    System.Int32 a = 0;
    int a = new int();
    System.Int32 a = new System.Int32();
```

- C#의 기본 타입들은 조금 독특한 특징을 가지고 있습니다. 다른 프로그래밍 언어에서 int는 32비트 운영체제에서는 32비트 정수로 64비트 운영체제에서는 64비트 정수로 취급되는 경우가 있지만, C#에서 int는 System.Int32의 별칭이기 때문에 반드시 32비트 정수로 취급됩니다. 64비트 정수는 System.Int64의 별칭인 long을 사용해야 합니다.

- C# 컴파일러는 기본 타입들을 다루는 작업들에 대해서 몇 가지 기능을 제공해줍니다.

1. 컴파일러는 아래의 타입들에 대해서 암묵적/명시적 형 변환을 지원합니다.
  - 암묵적 변환에 경우 변환 과정에서 데이터 손실이 없는 '안전한' 경우에만 지원합니다.
```cs
Int32 i = 5;        //Int32 -> Int32
Int64 l = i;        //Int32 -> Int64
Single s = i;       //Int32 -> Single
Byte b = (Byte)i;   //Int32 -> Byte(명시적)
Int16 v = (Int16)s; //Single -> Int16(명시적)
```

- 특히 부동 소수점 데이터를 다룰 때 주의해야 하는데 값을 정수형으로 변환할 때 컴파일러에 따라 버림/반올림 연산 중 어떤 것을 적용할지는 컴파일러마다 다릅니다. C#의 경우는 버림 연산이 적용됩니다.

2. 기본 타입은 변수가 아닌 리터럴 상수로 기재할 수 있습니다.
```cs
Console.WriteLine($"{123.ToString()}, {456.ToString()}");
```

3. 리터럴 상수로 구성되는 표현식이 있다면, 컴파일러가 해당되는 표현식을 컴파일 타임에 평가하여 응용프로그램의 성능을 향상시키도록 할 수도 있습니다.
4. 컴파일러는 +, -, *, /, &, ^ 등의  연산자가 사용되었을 때, 자동으로 연산자 처리 우선순위를 결정합니다.

### 기본 타입 연산의 오버플로우 여부 검사
- 언어마다 오버플로우를 처리하는 방식이 다릅니다. 오버플로우를 허용하는 C/C++ 과 다르게 Visual Baisc .NET에서는 오버플로우를 명백한 오류로 취급하고 발견될 경우 이 사실을 알립니다.
  - C#은 오버플로우를 어떻게 처리할지 개발자가 선택할 수 있게 합니다. 컴파일러 옵션을 바꾸거나, checked/unchecked 키워드를 활용합니다.

```cs
UInt32 valid = unchecked((UInt32)(-1)); 

int i = -1;
UInt32 invalid = checked((UInt32)(i));  //overflow exception

//블록 지정도 가능
checked
{
    Byte b = 100;
    b = (Byte)(b + 200);    //overflow exception
}

checked
{
    DoSomething(100);   //오버플로우 검사가 이루어지지 않을 수도 있습니다.
}

```

- checked 블록 안에서 메서드를 호출한다고 가정했을 때, 메서드가 어떻게 컴파일 되는지에 따라 오버플로우 검사가 이루어질 수도, 이루어지지 않을 수도 있습니다. 
  - checked 코드 블록은 단순히 컴파일 시점에 IL 코드의 오버플로우 검사여부를 결정하는 것에 불과하기 때문입니다.
- checked/unchecked 연산자와 코드 블록, 그리고 컴파일러 스위치는 Decimal 타입에 대해서 검사를 지원하지 않습니다. Decimal 타입은 CLR이 다루지 않는 특수한 타입이며, c# 내부적으로 Decimal 에 대해서는 특별히 다르게 취급하기 때문입니다.(Decimal을 연산하기 위한 정적메서드와 연산자 오버로딩이 추가적으로 존재합니다.)
  - System.Numerics.BigInteger 타입도 마찬가지입니다.

### 참조 타입과 값 타입

- 모든 클래스는 참조타입입니다.
- 모든 구조체와 열거타입은 값 타입입니다. 구조체는 System.ValueType을 상속받고, 열거형은 System.Enum 을 상속받습니다. 여기서 System.Enum 역시 System.ValueType을 상속받습니다.
  - 모든 값 타입은 Sealed 타입입니다. 어떤 타입도 값 타입을 상속받을 수 없습니다.
  - 값 타입이 스택에 할당될 때에는 참조 타입과 달리 타입 객체 포인터와 동기화 블록 인덱스가 멤버로 포함되는 오버헤드가 존재하지 않습니다.

- 어떤 상황에서 값 타입을 쓰는게 좋을지는 [MoreEffective CSharp 4장](https://github.com/wlsvy/TIL/blob/master/Document/C%23/MoreEffectiveCSharp/MoreEffectiveCSharp/Item04.cs) 을 참고합시다.
- 값 타입의 경우, GetHashCode 메서드의 결과값은 타입의 멤버 값을 통해 평가합니다. 서로 다른 두 값 타입 객체가 똑같은 hash 코드 결과값을 반환할 수도 있는 것입니다.

#### CLR의 메모리 레이아웃
- System.Runtime.InteropServices 네임스페이스를 참조합시다. 메모리 레이아웃을 개발자가 임의로 지정한다면 아래와 같은 방식으로 공용체를 만드는 것도 가능합니다.

```cs
using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Explicit)]
    public struct Union
    {
        [FieldOffset(0)]
        public int i;
        [FieldOffset(0)]
        public byte b;
        [FieldOffset(0)]
        public long l;
        [FieldOffset(4)]
        public int i2;
    }
```

### 박싱된 값 타입과 박싱되지 않은 값 타입

- 특정 인터페이스를 상속받은 값 타입에 대해서, 해당 값 타입 객체를 임의의 인터페이스 타입으로 캐스팅할 때 박싱이 필요합니다.
  - 인터페이스 변수는 참조타입입니다.

```cs
 int i = 1;
IComparable c = i;  //boxing
```

- 값 타입에 대해서 GetType, MemberwiseClone 과 같은 System.Object 에 정의된 비가상 메서드를 호출하려 할 때 박싱이 일어납니다. 힙에 할당된 참조 객체만이 해당 메서드를 호출할 수 있기 때문입니다.
- 박싱되지 않은 값 타입들은 동기화 블록 인덱스가 없기 때문에, 다중 스레드 환경에서 lock 구문 등의 설정 대상으로 지정할 수 없습니다.
- 값 타입은 sealed 타입이기 때문에 값 타입 객체가 ToString, Equals, GetHashCode 같은 가상 메서드를 재정의된 후 호출하려 하면 CLR이 이들을 비가상 메서드로서 호출하게 합니다. 추가적인 상속이 없는 것을 확신할 수 있기에 다형성을 무시하는 것입니다.

### 객체의 동일함과 식별
- [More Effective CSharp Item09](https://github.com/wlsvy/TIL/blob/master/Document/C%23/MoreEffectiveCSharp/MoreEffectiveCSharp/Item09.cs)를 확인합시다.

### 객체 해시 코드

### dynamic 기본 타입
- dynamic 타입을 확인하면, 컴파일러는 해당 소스에 대해 조금 특별한 IL코드(페이로드payload)를 만들어 냅니다. dynamic 타입은 런타임 바인더에 의하여, 런타임에 입력되는 값에 따라 타입이 변하게 됩니다.

</details>

## 6장. 타입과 멤버의 기본

<details>
<summary>fold/unfold</summary>

### 서로 다른 종류의 타입 멤버들
- 상수 : 절대불변의 데이터 값을 식별하는 기호입니다. 상수들은 항상 타입과 관계를 가지지만 타입의 인스턴스와는 무관합니다. 논리적 관점에서 정적 멤버입니다.
- 필드 : 일기 전용 혹은 읽기 / 쓰기 겸용 데이터 값에 대한 표현입니다. 필드는 타입의 상태를 정의하기 위하여 정적 멤버로 또는 인스턴스의 상태를 정의하기 위해 인스턴스 멤버로 선언될 수 있습니다.
- 인스턴스 생성자 : 인스턴스 생성자는 객체의 인스턴스 필드를 의도하는 대로 초기화하기 위한 목적으로 선언할 수 있는 메서드입니다.
- 타입 생성자 : 타입 생성자는 타입의 정적 필드들을 의도대로 초기화하기 위한 목적으로 선언할 수 있는 특별한 메서드입니다.
- 메서드 : 멤버로 추가할 수 있는 함수로, 특정한 타입에대한 상태를 변경하기 위하여 정적 메서드를 선언하거나 특정한 인스턴스에 대한 상태를 변경하기 위하여 인스턴스 메서드로 선언할 수 있습니다.
- 연산자 오버로드 : 서로 다른 두 객체애 대해 조작하는 방법을 정의하는 메서드입니다. 공용 언어 사양(CLS) 에는 포함되지 않습니다.
- 변환 연산자 : 암묵적/명시적으로 어떤 객체를 다른 객체 타입으로 변환할 수 있는 방법을 정의하는 메서드입니다. 공용 언어 사양(CLS) 에는 포함되지 않습니다.
- 속성 : 속성은 필드와 비슷한 문법을 사용하여 타입 내의 필드를 변경하거나 상태를 조회하기 위한 정적 속성, 객체 내의 필드를 변경하거나 상태를 조회하기 위한 인스턴스 속성으로 나눌 수 있습니다.
- 이벤트 : 정적 이벤트와 인스턴스 (비정적) 이벤트는 특정한 타입이 다른 정적 메서드 또는 인스턴스 메서드로 통지를 보낼 수 있는 방법을 제공합니다.
- 타입 : 타입 안에 또 다른 타입을 중첩해서 선언할 수도 있습니다. 규모가 큰 타입을 작은 타입들로 분해하여 단순화 시키기 위함입니다.

```cs
    public sealed class SomeType
    {
        //중첩된 클래스
        private class SomeNestedType { }

        //상수 필드, 읽기 전용 필드. 그리고 읽기/쓰기가 가능한 정적 필드
        private const int someConstant = 1;
        private readonly string someReadonlyFiled = "str";
        private static int someReadWriteField = 3;

        //타입 생성자
        static SomeType() { }

        //인스턴스 생성자
        public SomeType(int x) { }
        public SomeType() { }

        //인스턴스 및 정적 메서드
        private string InstanceMethod() { return null; }
        public static void StaticMethod() { }

        //인스턴스 속성
        public int SomeProperty
        {
            get { return 0; }
            set { }
        }

        //매개변수를 요구하는 인스턴스 속성(인덱서)
        public int this[string s]
        {
            get { return 0; }
            set { }
        }

        //인스턴스 이벤트
        public event Action SomeEvent;
    }
```

### 타입의 가시성
이웃 어셈블리
- TeamB 에서 작성한 어셈블리가 TeamA의 어셈블리 안에 들어있는 타입들을 사용하려면 TeamA가 만든 어셈블리 안의 타입들은 모드 public으로 선언해야만 합니다. 하지만, 이렇게 되었을 경우 TeamA가 public으로 선언한 모든 타입들은 TeamB 뿐만 아니라 다른 모든 이들에게도 공개가 됨을 의미하므로 의도하지 않은 결과일 수 있습니다. TeamB가 쓴 코드에서만 TeamA가 작성한 타입들을 사용하도록 의도되었을 때 TeamA가 만든 타입을 internal로 유지하면서도 TeamB에 대해서만 독점적으로 접근권한을 할당할 수 있도록 해야 합니다. CLR과 c#은 이러한 기능을 이웃 어셈블리(friend assmbly)라고 정의합니다.

### 멤버 접근성
- 타입 내의 중첩 타입과 멤버를 정의할 때에는 해당 타입과 멤버의 접근성을 설정할 수 있습니다.
IL 코드를 검증함으로써 참조하는 멤버의 접근성이 설령 컴파일러 수준에서 접근성에 대한 점검이 누락되었다고 할지라도 실행 중에 이를 검사하므로 기능성을 보장받을 수 있습니다. 

- C#에서 선언하는 멤버에 명시적으로 한정자를 지정하지 않을 경우, 컴파일러는 모든 경우는 아니지만 대개 private 한정자를 자동으로 선택하여 적용하게 됩니다. 그리고 CLR에서는 인터페이스에 선언되는 모든 멤버들은 반드시 public 한정자만을 사용할 수 있도록 하고 있습니다. c# 컴파일러는 이를 반영하여 인터페스 내의 멤버들에 명시적으로 한정자를 지정할 수 없도록 제한합니다. 대신 인터페이스 멤버들의 접근 한정자는 자동적으로 public이 됩니다.
- 상속받은 타입에서 기본 타입에 선언된 멤버를 재정의하는 경우, C# 컴파일러는 기존 멤버의 접근성을 그대로 가져옵니다. 예를 들어 기본 클래스의 protected 메서드를 파생클래스에서 재정의한다면 재정의된 메서드의 접근 한정자 역시 protected 입니다.
  - 이는 C#의 제약사항이며 CLR에서는 재정의하는 멤버의 접근성을 상위 타입보다 더 개방할 수 있습니다.

### 정적 클래스
- Console, Math 등 인스턴스로 생성되지 않도록 보호되는 클래스들은 정적 클래스입니다. 이러한 클래스들은 반드시 정적 멤버들만을 포함할 수 있습니다.
  - static 키워드는 값 타입에 대해서는 사용할 수 없습니다. CLR은 값 타입을 항상 인스턴스로 선언하여 사용하도록 제한하였기 때문입니다.
  - 정적 클래스는 반드시 System.Object 에서만 상속을 받도록 제한되었습니다. (자동적으로 sealed, abstract 특성이 부여됩니다)
  - 정적 클래스는 인터페이스를 구현할 수 없도록 제한되었습니다. 인터페이스 메서드는 클래스의 인스턴스로 생성될 때에만 호출할 수 있기 때문입니다.
  - 정적 클래스 안에서는 필드, 메서드, 속성, 이벤트 모두 정적 멤버로 선언되어야만 합니다.
  - 정적 클래스는 필드, 메서드 매개변수, 또는 지역 변수의 타입으로 사용될 수 없습니다. 이러한 작업은 모두 클래스 인스턴스화와 연관이 있기 때문입니다.

### 부분 클래스, 부분 구조체, 부분 인터페이스
- partial 키워드를 사용하면 한 소스 코드 파일 내에서 여러 조각으로 타입의 선언을 분할하거나 여러 소스 코드 파일에 걸쳐 여러 조각으로 타입의 선언을 분할할 수 있게 합니다.

### 컴포넌트, 다형성, 버전관리
컴포넌트 소프트웨어 프로그래밍(Component Software Programming, CSP)은 객체 지향 프로그래밍(OOP)의 수준을 끌어올렸습니다. <br>
다음은 컴포넌트로서 가져야 할 성격들입니다.
- 하나의 컴포넌트(.NET Framework에서는 하나의 어셈블리)는 "출판(Published)"된 것으로 간주합니다.
- 하나의 컴포넌트에는 식별할 수 있는 아이덴티티(이름, 버전, 문화권, 그리고 공개 키)가 존재합니다.
- 하나의 컴포넌트에는 영원히 유지되는 고유한 아이덴티티가 존재합니다. 어셈블리 안에 들어있는 코드는 다른 어셈블리에 정적으로 링크되는 일이 없으며, .NET 환경에서는 항상 동적 링크만 발생합니다.
- 하나의 컴포넌트는 의지하는 다른 컴포넌트들에 대해 정확한 정보를 표시합니다.(참조 메타데이터 테이블)
- 하나의 컴포넌트는 반드시 그 안에 들어있는 클래스와 멤버들에 대해 문서를 만들 수 있어야 합니다. C#에서는 소스 코드 내부에 XML 주석을 추가하여 컴파일러의 /doc 명령 줄 스위치를 사용하여 이러한 목적을 성취할 수 있습니다.
- 하나의 컴포넌트는 반드시 필요로 하는 권한에 대해 자세히 서술하고 있어야 합니다. CLR의 코드 액세스 보안(CAS) 기능을 통해 이를 달성할 수 있습니다.
- 하나의 컴포넌트는 새로운 서비스를 제공하더라도 변하지 않는 인터페이스나 객체 모델을 제공해야 합니다. 서비스 제공이라 함은 원래의 컴포넌트 버전과 호환성을 유지할 수 있는 새로운 버전의 컴포넌트를 제공하는 것입니다.

---

C#의 각 키워드와 컴포넌트 버전 관리에 주는 영향

| C# 키워드 | 타입에 대한 적용 | 메서드/속성/이벤트에 대한 적용 | 상수/필드에 대한 적용 |
|:---: | :--- | :--- | :---: |
|abstract| 여기에 해당하는 타입은 인스턴스로 만들 수 없게 된다. | 이 키워드로 선언된 멤버가 있는 타입을 상속받은 타입이 인스턴스로 생성될 수 있도록 하기 위해서는 반드시 해당 멤버를 구현해야만 한다. | (적용 불가) |
|virtual| (적용 불가) | 이 키워드로 선언된 멤버가 있는 타입을 상속받은 타입에서 이 멤버를 재정의할 수 있다. | (적용 불가) |
|override| (적용 불가) | 기본 타입의 가상 멤버를 현재 타입에서 재정의한다. | (적용 불가) |
|sealed| 여기에 해당하는 타입은 다른 타입의 기본 타입이 될 수 없다. | 이 키워드로 선언된 멤버는 상속 이후에 재정의할 수 없다. 이 키워드는 가상 메서드를 재정의하는 메서드에 대해서만 지정할 수 있다. | (적용 불가) |
|new| 중첩 타입에 적용되는 경우, 기본 타입에 존재할 수 있는 비슷한 멤버 메서드, 속성, 이벤트, 상수, 필드와는 전혀 관계가 없음을 명시하게 된다. |  |  |

### CLR이 가상 메서드, 속성, 이벤트를 호출하는 방법
- CLR은 한 타입 내에 같은 이름의 메서드 여러 개를 서로 다른 매개변수 또는 반환 타입을 사용하여 구분하는 것을 허용합니다.
  - 하지만 C#의 경우 메서드의 반환 타입은 무시하고 매개변수 목록의 차이를 통해 고유성을 식별합니다.

컴파일러가 코드를 컴파일할 때 메서드를 메서드 정의 테이블에 항목으로 추가하며, 각 항목들이 인스턴스 메서드인지, 가상 메서드인지, 정적 메서드인지의 여부를 플래그로 기록합니다.
- CLR은 다음의 두 IL 명령어를 사용하여 메서드를 호출합니다.
  - call : 정적/인스턴스/가상 메서드를 호출하기 위해 사용될 수 있습니다. 정적메서드 호출 시, 메서드가 정의된 타입을 정확하게 지정해야 합니다. 인스턴스/가상 메서드 호출 시 객체를 가리키는 변수를 반드시 지정해야 하며 이때 해당 변수는 절대 null이 아니어야 합니다. CLR은 넘겨받은 변수의 타입을 확인하여 일치하는 메서드를 찾는 데 사용합니다. 만약 해당 타입에서 발견하지 못했다면 상속 계통을 올라가면서 탐색합니다.
  - callvirt : 인스턴스/가상/비정적 메서드 호출에 사용됩니다. 인스턴스/가상 메서드 호출시 객체애 대한 참조를 반드시 지정해야 합니다. 비가상 인스턴스 메서드를 호출할 때 넘겨받은 객체 참조 변수의 타입을 통하여 CLR이 호출할 실제 메서드를 찾습니다. 이때 해당 참조 변수는 null일 수 있습니다. JIT 컴파일러는 메서드를 호출하기 전에 객체 참조가 null인지 검증하는 절차를 거칩니다.(null 이면 오류를 던집니다) 이런 추가적인 검사과정으로 인해 callvirt는 call 보다 조금 더 느리게 동작합니다.

컴파일러는 call 명령어를 값 타입에 정의된 메서드를 호출할 때 주로 사용하는 경향이 있습니다. 값 타입은 상속이 불가능하며 null 값을 가질 수 없기 때문입니다. <br><br>
타입을 설계할 때는 반드시 정의하는 가상 메서드의 수를 최소화해야 합니다.
1. 가상 메서드는 비가상 메서드보다 호출 속도가 느리다.
2. 가상 메서드는 JIT 컴파일러에 의하여 인라인으로 번역될 수 없어 성능에 영향을 줄 수 있습니다.
3. 가상 메서드는 컴포넌트 버전 관리를 어렵게 합니다.
4. 기본 타입을 선언할 때에는 편의를 위한 오버로드 메서드들의 집합을 제공하는 것이 보편적입니다.

### 타입의 가시성과 멤버의 접근성을 지능적으로 활용하는 방법
- 타입은 가능하면 sealed 타입으로, 멤버는 가능하면 priavte으로 -> 아래의 장점이 있습니다.
  - 버전관리 : 상속이 봉인된 클래스는 추후에 봉인을 해제할 수 있습니다만, 반대의 경우는 안됩니다.
  - 성능 : sealed 타입의 경우 컴파일러가 확인해서 가상메서드를 호출할 때에도 callvirt 대신 call을 활용할 수 있습니다. (가상 메서드를 비가상 메서드처럼 호출/타입이 봉인되 있다면 상속 계통을 전부 확인할 필요가 없기 때문에)
  - 보안 향상과 예측의 용이성 : 봉인되지 않은 클래스 타입의 경우, 추후 파생클래스에서 정의된 메서드로 인해 기본 클래스의 멤버가 의도치 않게 변경될 수 있습니다.

- 오래된 객체 지향 프로그래밍에 관한 격언 : 너무 복잡해지는 것 같다면 더 많은 타입을 만들라

### 타입에 대한 버전관리와 가상 메서드 사이의 조율
...


</details>

## 7장. 상수와 필드

<details>
<summary>fold/unfold</summary>

### 상수
- 절대 변하지 않는 값에 대한 기호
- 상수 기호를 정의할 때는 그 값이 반드시 컴파일 시점에서 확인할 수 있어야 합니다. 기본 타입으로 취급될 수 있는 경우 상수로 사용할 수 있습니다.(Int32, Boolean 등)
- 상수 기호를 참조하는 코드가 있을 때, 컴파일러는 어셈블리의 메타데이터 안에 정의된 상수 기호를 검색하여 상수의 실제 값을 추출한 후 만들어진 IL 코드에 값을 직접 첨부합니다.
  - 코드에 상수 값을 직접 첨부하므로 실행 시점에 상수 값을 위해서 추가로 메모리를 할당하지 않습니다.
  - 상수 값에 대해서 주소를 얻거나 이를 참조로 지정할 수 없습니다.

## 필드
- 필드는 값 타입의 인스턴스 또는 참조 타입에 대한 참조를 저장하는 데이터 멤버입니다.

<br>
필드 한정자
<br>

| CLR 키워드 | C# 키워드 | 설명 |
| :---: | :---: | :--- |
| Static | static | 타입의 상태의 일부로서 필드가 선언되며, 객체의 상태의 일부가 되는 것과는 반대되는 개념 |
| Instance | (기본값, 생략) | 타입 인스턴스(객체)의 상태의 일부로서 필드가 선언되며, 타입 그 자체와는 무관하다. |
| InitOnly | readonly | 해당 필드는 반드시 생성자 메서드에 의해서만 초기화가 가능하다. |
| Volatile | volatile | 해당 필드는 컴파일러, CLR, 하드웨어에 의하여 이루어지는 스레드 비안정성 최적화의 대상에서 제외된다.|

* C#은 성능상의 문제 때문에 필드를 인라인 문법을 사용하여 초기화하는 것과 생성자 안에서 대입 문법을 사용하여 초기화하는 것에 차등을 두고 있습니다.(8장에서 자세히)


</details>


## 8장. 메서드

<details>
<summary>fold/unfold</summary>

### 인스턴스 생성자와 클래스(참조 타입)
- 생성자는 특별한 유형의 메서드로 타입의 인스턴스를 올바른 상태로 초기화하는 것을 돕습니다. .ctor라는 이름으로 메타데이터에 등록됩니다.
- 참조 타입으로 객체의 인스턴스를 생성하면, 인스턴스의 데이터 필드들을 저장하기 위해서 메모리가 할당되는데, 먼저 객체의 오버헤드 필드(타입 객체 포인터, 동기화 블록 인덱스)가 초기화되고, 그 다음으로 타입의 인스턴스 생성자가 호출됩니다.
  - 인스턴스 생성자는 재정의할 수 없습니다.
  - 클래스를 abstract로 선언하면 컴파일러는 기본 생성자를 protected로 선언하며, 그렇지 않은 경우에는 public으로 선언된 것으로 간주합니다.
  - C# 컴파일러는 상속한 클래스가 명시적으로 기본 클래스의 생성자를 호출하지 않으면, 기본 클래스 생성자를 자동으로 호출하도록 코드를 생성합니다.

- 특별한 상황에서는 타입의 인스턴스 생성자가 호출되지 않고도, 해당 타입의 인스턴스가 생성될 수 있습니다.
  - Object 타입의 MemberwiseClone 메서드를 호출하여 메모리를 할당하고, 객체의 오버헤드 필드를 초기화한 다음, 원본 객체의 바이트들을 새 객체로 직접 복사해 넣습니다.
  - 또한 런타임 Serialization을 통하여 만들어진 데이터를 deserialization하는 경우에도 생성자 호출이 별도로 이루어지지 않습니다.

- 생성자에서 가상 메서드를 호출하지 않습니다. 하위 타입 멤버의 초기화가 덜 끝난 상태에서 재정의된 메서드를 호출한다면 의도하지 않은 결과가 나타날 수 있습니다.
  - C#에서는 객체 멤버에 대해서 인라인 초기화 문구가 작성되어져 있다면, 생성자를 호출하기 전에 해당 멤버에 초기화 데이터를 대입하게 됩니다.

```cs
        //만약 인스턴스 필드를 초기화하는 인라인 코드가 여럿 있고, 오버로드된 생성자를 많이 만들어야 한다면, 
        //필드 초기화 구문 대신, 공통적인 초기화 작업을 수행하는 단일의 생성자를 생성하는 것이 좋습니다.
        class SomeType
        {
            //인라인 초기화 구문은 전부 제거
            private int x;
            private string s;
            private double d;
            private byte b;

            // 기본 생성자에서는 모든 필드를 기본값으로 설정하고 있습니다.
            // 나머지 다른 생성자들은 이 생성자를 명시적으로 호출합니다.
            public SomeType()
            {
                x = 5;
                s = "Hi, There";
                d = 3.1459;
                b = 0xff;
            }

            public SomeType(int x) : this()
            {
                this.x = x;
            }

            public SomeType(string s) : this()
            {
                this.s = s;
            }
        }
```

### 인스턴스 생성자와 구조체(값 타입)
- CLR 에서는 값 타입의 인스턴스를 언제든 생성할 수 있도록 허용할 수 있으므로 값 타입은 내부에 생성자를 정의할 필요가 없습니다. C# 컴파일러에는 값 타입에 대해서는 매개변수가 없는 기본 생성자 코드를 생성하지 않습니다.
  - 컴파일러가 값 타입의 기본 생성자를 자동으로 생성해줄 것처럼 예상할 수도 있지만 사실 애플리케이션의 성능을 개선하기 위해서 c# 은 자동으로 생성자를 작성하지 않습니다.
  - 따라서 컴파일러는 애당초 생성자를 자동으로 호출해야 할 의무가 사라지게 됩니다.
- 신뢰할 수 있는 코드를 위하여 값 타입의 모든 필드들은 읽기 작업을 수행하기 전에 반드시 쓰기 작업을 한번 거쳐야 합니다. 따라서 생성자는 반드시 해당 타입 내의 모든 필드들을 명시적으로 초기화해줘야 합니다.

```cs
        struct widget
        {
            public int x, y, z, w;

            //문제 없이 컴파일됩니다.
            public widget(int x)
            {
                //참조 타입에서 this는 읽기 전용이지만, 값 타입에서는 this가 인스턴스 그 자체를 나타내며 새 인스턴스를 대입하는 것이 가능
                this = new widget();
                this.x = x;
            }


            //모든 필드를 초기화하지 않는 경우. -> 컴파일 X
            public widget(int x, int y)
            {
                this.x = x;
                this.y = y;
            }
        }
```

### 타입 생성자
- 타입 생성자는 static 키워드를 사용해서 정의되며 C# 에 의해 자동으로 private으로 지정됩니다. (외부에서 임의로 호출되지 못하도록 보호)
- JIT 컴파일러가 메서드를 컴파일 할 때 메서드 내의 코드가 어떤 타입들을 참조하는지 확인합니다. 만약 타입 생성자를 정의하고 있는 타입을 참조하고 있다면, JIT 컴파일러는 이 타입의 타입 생성자가 현재의 앱 도메인에서 실행된 적이 있는지 검사합니다. 만약 한 번도 실행되지 않았다면 JIT 컴파일러는 타입 생성자를 호출하는 코드를 네이티브 코드에 추가합니다.
  - 컴파일된 코드를 스레드가 실행할 때 여러 스레드가 동시에 타입 생성자를 실행하는 경우를 방지하기 위해 이 메서드를 호출하는 스레드가 상호 배타적인 락을 획득할 수 있도록 요구합니다. 
  - 정적 생성자는 CLR이 앱 도메인 당 단 한 번씩만 수행할 수 있도록 스레드 안정성을 보장하기 때문에 필요하다면 싱글톤 객체를 초기화 하기에 최적의 위치라고 할 수 있습니다.

```cs
        struct SomeValueType
        {
            // C#은 값 타입에 대해 매개변수 없는 값 타입 생성자를 정의할 수 있도록 허용합니다.
            // 하지만 CLR은 값 타입의 정적타입 생성자를 호출하지 않습니다.
            static SomeValueType()
            {
                Console.WriteLine("This never gets displayed");
            }
        }
        class SomeRefType
        {
            static SomeRefType()
            {
                //해당 타입을 처음 사용하는 경우 실행됩니다.
                Console.WriteLine("SomeRefType type ctor");
            }
        }

```
- 타입 생성자로 생성된 타입 객체의 경우 앱도메인이 언로드하는 경우에만 가비지 컬렉터의 수거대상이 됩니다.
  - CLR은 따로 정적 소멸자를 지원하지 않습니다. 

### 연산자 오버로드 메서드
- CLR에서는 연산자 오버로딩 개념이 존재하지 않습니다. 또한 연산자라는 개념 역시 없습니다. C#에서는 연산자를 대응되는 다른 이름의 메서드로 치환해서 사용합니다.
  - C#에서 +는 op_UnaryPlus, -는 op_UnaryNegation 등으로 호환되는 메서드가 존재합니다. 해당 메서드들은 specialname 플래그 셋을 포함하며, 만약 플래그가 true 이면 연산자 오버로딩에 활용되는 것을 나타냅니다.
  - CLR에서는 연산자 오버로드는 반드시 public 접근자를 사용하면서 정적 메서드로 사용되어야 합니다.


### 변환 연산자 메서드
- 변환 연산자(Conversion method)는 어떤 타입에서 다른 타입으로의 변환을 담당하는 메서드입니다.
  - 변환 연산자는 명시적(explicit)/암시적(implicit) 연산을 구현할 수 있습니다.
  - 자릿수나 정밀도에 손상을 주거나 정보를 잃어버리는 변환의 경우, 암시적 변환보다 명시적 변환 연산을 활용하는 것이 좋습니다.
  - is/as 연산자는 변환 연산자 메서드를 호출하지 않습니다.

### 확장 메서드
- 확장 메서드는 사용자가 정의한 정적 메서드를 인스턴스 메서드의 일부인 것처럼 보이게 합니다.
  - 컴파일러가 메서드를 바인딩할 때, 특정 메서드에 해당하는 인스턴스 메서드가 있을 경우, 컴파일러는 해당 메서드를 호출하는 IL 코드를 만들어냅니다. 하지만 인스턴스 메서드가 없는 경우, 컴파일러는 첫 번째 매개변수로 호출하려는 대상 타입의 인스턴스를 받는 정적 메서드를 포함하는 정적 클래스가 있는지 확인합니다. 이때 첫 번재 인자는 반드시 this 키워드로 표시되어야 합니다.
- 확장 메서드는(첫 번째 매ㅐ개변수에 this 키워드가 붙는 메서드)는 반드시 제네릭이 아닌 정적 클래스 위에서 정의되어야만 합니다.
- 확장 메서드는 단순히 정적 메서드에 대한 호출에 불과하기 때문에 CLR은 호출 과정에서 전달되는 객체가 null인지 검사하는 코드를 내보내지 않습니다.
- 정적 클래스의 이름은 임의로 작명할 수 있기 때문에 C# 컴파일러는 파일 수준의 모든 정적 클래스를 확인해야 하며 확장 메서드를 찾는데 시간이 필요합니다.
  - 검색 성능을 개선하기 위해 c# 컴파일러는 확장 메서드에 ExtensionAttribute를 내부적으로 추가합니다. 더 나아가 확장 메서드를 하나라도 포함하고 있는 정적 클래스/어셈블리에도 해당 특성이 추가됩니다. 컴파일러는 해당 특성이 부여된 정적 클래스/메서드들을 확인해나가면서 검색의 범위를 좁힙니다.

### 부분 메서드
...

</details>



## 26장. 스레드의 기본

<details>
<summary>fold/unfold</summary>

### 윈도우는 왜 스레드를 지원하는가?
...

### 스레드의 비용
모든 스레드는 아래에 나열한 것들을 하나씩 가지고 있습니다.
- 스레드 커널 객체 : os는 시스템 내에서 생성되는 개별 스레드별로 고유의 데이터 구조체를 할당하고 초기화합니다. 이 구조체는 스레드를 나타내는 여러 속성들을 가지고 있으며 그 중에는 스레드의 컨텍스트라고 불리는 정보도 있습니다.
- 스레드 환경 블록(Thread environment block, TEB) : TEB는 유저 모드(응용 프로그램이 빠르게 접근할 수 있는 주소 공간)에 할당되고 초기화되는 메모리 블록입니다.
- 유저 모드 스택 : 지역 변수와 함수의 매개변수를 저장할 용도로 사용되며, 현재 수행 중인 함수가 반환될 때 그 다음으로 수행해야 할 위치를 저장합니다. 윈도우 os는 기본적으로 각각의 스레드에 대해서 유저모드 스택 1MB를 할당합니다.
- 커널 모드 스택 : 응용프로그램이 os의 커널 모드 함수로 매개변수를 전달해야 할 때 사용됩니다. 보안상의 이유로 유저 모드 코드에서 커널 모드로 매개변수를 전달할 때 유저 모드 스택의 내용을 커널 모드 스택으로 복사해서 넘겨줍니다. 응용프로그램은 커널 모드 스택에 접근을 못하기 때문에 커널 코드는 안전하게 동작을 수행합니다.
- DLL의 스레드 attach/detach 통지 : 윈도우 os는 프로세스 내에서 새 스레드가 생성되면 해당 프로세스의 메모리 공간에 로드된 모든 비관리 DLL들의 DllMain 함수를 DLL_THREAD_ATTACH 플래그를 매개변수로 호출합니다. 스레드가 종료될 때는 마찬가지로 DllMain 함수를 DLL_THREAD_DETACH 플래그를 매개변수로 호출합니다.

특정 시간에 윈도우 운영체제는 하나의 CPU에 하나의 스레드를 할당합니다. 스레드는 주어진 타임 슬라이스(time-slice 혹은 퀀텀(Quantum))동안만 수행됩니다. 스레드가 타임 슬라이스 만큼 수행을 완료하고 나면, 다른 스레드로 컨텍스트를 전환합니다.
<br>
컨텍스트를 전환할 때 os 는 아래의 동작을 수행합니다.
1. cpu 레지스터의 값을 현재 수행 중인 스레드의 컨텍스트 구조체에 저장합니다. 컨텍스트 구조체는 스레드 커널 객체 내부에 있습니다.
2. 여러 스레드들 중 다음 번에 수행할 스레드를 선택합니다. 만일 선택된 스레드가 다른 프로세스에 속해 있다면 (프로세스간 컨텍스트 스위치 수행) 스레드가 수행할 코드와 데이터가 접근하기 위해 가상 메모리 주소를 먼저 전환합니다.
3. 선택된 스레드의 컨텍스트 구조체 내의 값을 cpu 레지스터로 로드합니다.

컨텍스트 스위칭은 순전히 오버헤드에 해당하는 작업입니다. 하지만 이를 통해 좀 더 견고하고 사용자에게 응답성이 좋은 운영체제를 구현할 수 있습니다.
- 어떤 프로그램이 실행 중에 무한루프에 빠졌다고 해봅시다. 컨텍스트 스위칭이 없다면 해당 무한루프에서 빠져나올 방법이 없습니다. 하지만 일정시간마다 os는 컨텍스트 스위칭을 통해서 작업 관리자와 같은 새로운 스레드에게 cpu를 할당할 수 있으며 사용자는 작업 관리자를 활용해서 무한 루프에 빠진 프로그램을 종료시키고 다시 작업을 할 수 있을 것입니다.
- 추가적으로 가비지 컬렉션이 호출될 때 CLR은 모드 스레드를 일시 정지시킵니다. 그 후 힙 내의 객체를 마크하기 위해 모든 스레드의 스택을 추적해 루트 객체를 찾아야 하고, 컴팩트 작업이 완료되면 스택 내의 루트를 갱신한 후에야(메모리 위치가 바뀌므로) 비로소 스레드를 재개할 수 있습니다.
- 응용프로그램을 디버깅 할때 중단점에 다다를 경우 모든 스레드가 일시 정지됩니다. 이런 특징 탓에 스레드 개수가 많다면 디버깅 속도가 느려지게 됩니다.

### 바보짓은 이제 그만
...

### CPU 트렌드
...

### CLR 스레드와 윈도우 스레드
...

### 계산 중심의 비동기 작업을 수행하기 위해서 전용 스레드 사용하기
보통 상태가 아니라 특수한 용도를 위한 스레드가 필요한 경우가 있습니다.
- 보통 스레드 우선순위가 아닌 스레드가 필요한 경우. 스레드 풀 내의 모든 스레드는 보통 우선순위를 가지며 임의로 바꿀 수 있긴 하지만 권장되지 않습니다. 우선순위를 바꾼다 하더라도 스레드 풀 작업중에 바뀐 우선순위가 계속 유지되는 것도 아닙니다.
- 포그라운드 스레드처럼 동작하는 스레드가 필요한 경우, 이 스레드가 작업을 완료하면 응용 프로그램이 종료되거나 종료되지 않을 것을 보장하기 위해 필요합니다. 스레드 풀의 모든 스레드는 백그라운드 스레드이므로 CLR이 프로세스를 종료하려 하면, 수행 중이던 작업을 완료하지 못할 수도 있습니다.
- 계산 중심의 작업이 상당히 오랫동안 수행되어야 할 때, 스레드 풀을 이용하는 경우 추가 스레드를 생성할지 여부를 사용자가 결정할 수 없습니다.
- 스레드를 명시적으로 수행하거나 Thread의 Abort 메서드를 호출하여 스레드를 강제로 종료하는 것이 가능해야 하는 경우.

<br>
Join 메서드는 호출한 스레드 객체가 파괴되거나 종료될 때까지 이 메서드를 호출한 스레드를 중단시킵니다. 비동기적으로 갈라져나간 프로그램 흐름을 다시 합칠 수 있습니다.

### 여러 스레드를 사용하는 이유
- 응답성(클라이언트 측 gui 응용 프로그램에 대해서) : 윈도우 os는 각 프로세스별로 전용의 스레드를 할당하여 응용프로그램이 무한 루프에 빠지더라도 사용자가 다른 응용프로그램까지 사용하지 못 하는 상황을 미연에 방지하고 있습니다. 다수의 스레드를 활용하는 것은 시스템의 리소스를 낭비하고 성능에 좋지 않은 영향을 끼칠 수 있지만, 사용자에게는 응답성이 좋은 인터페이스를 제공할 수 있습니다.
- 성능(클라이언트 측, 서버 측 응용 프로그램에 대해서)

### 스레드 스케줄링과 우선순위
- 앞서 모든 스레드들은 커널 객체 내부에 컨텍스트 구조체를 포함하고 있다고 설명한 바 있는데, 이 컨텍스트 구조체에는 스레드가 마지막으로 수행되었던 CPU 레지스터의 상태 정보를 가지고 있습니다. 운영체제가 주어진 타임 슬라이스 만큼 특정 스레드를 수행하고 나면 현존하는 모든 커널 객체들 중 다른 작업이 완료되기를 기다리지 않는 스케줄 가능 스레드가 있는지 확인하게 되고, 이 중 하나를 선택해서 컨텍스트 전환을 수행합니다.
<br>

- 모든 스레드는 0(가장 낮은)에서 31(가장 높은)까지 우선순위 레벨을 할당받게 됩니다. (31의 우선순위를 가진 스레드가 있으면 해당 스레드를 가장 먼저 처리)
  - 이때 31 우선순위를 가진 스레드를 처리할 때 더 낮은 우선순위의 스레드에게는 cpu를 할당하지 않는데 이를 `기아 상태starvation` 이라고 부릅니다.

<br>

- 프로세스 우선순위 클래스의 역할을 혼돈할 수 있습니다. 윈도우 운영체제는 프로세스가 아니라 스레드를 스케쥴링의 대상으로 지정합니다. 프로세스 우선순위 클래스는 수행 중인 응용프로그램 간에 우선순위를 구성할 목적으로 만들어낸 추상화된 개념이며 다른 목적은 가지고 있지 않습니다.

### 포그라운드 스레드와 백그라운드 스레드
- CLR은 모든 스레드를 포그라운드 스레드나 백그라운드 스레드 중 하나로 간주합니다. 프로세스의 모든 포그라운드 스레드가 종료되면 CLR은 수행 중인 백그라운드 스레드들을 모두 강제로 종료시키려 합니다. 그렇게 되면 백그라운드 스레드는 아무런 예외를 발생시키지 않고 즉각 종료됩니다.
  - 따라서 메모리 버퍼의 내용을 디스크의 쓰는 것과 같이 반드시 완료해야 하는 작업은 포그라운드 스레드를 활용해야 합니다. 그렇지 않고 표 계산 프로그램에서의 셀 연산식 같이 덜 중요한 작업의 경우에는 백그라운드 스레드를 사용하는 것이 좋습니다. 이러한 작업들은 응용 프로그램이 재시작된 이후에 수행 중이던 작업을 다시 수행해도 되므로 사용자가 작업을 중단하려는 상황에서까지 작업을 끝까지 완료하려고 노력할 필요가 없습니다.
<br>
- 스레드가 살아있는 동안 포그라운드 스레드를 백그라운드 스레드로 변경하거나 그 반대로 변경하는 것은 언제든지 가능합니다. 응용 프로그램의 주 스레드와 Thread 객체를 명시적으로 생성하여 만들어진 스레드는 기본적으로 포그라운드 스레드로 동작합니다. 반면 스레드 풀 내의 스레드는 백그라운드 스레드로 동작합니다. 또한 네이티브 코드에 의해서 생성되어 관리 수행 환경으로 진입한 스레드들도 모두 백그라운드 스레드로 동작합니다.

</details>
