using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

//PLINQ가 병렬 알고리즘을 구현하는 방법을 이해하라(ebook에 메모한 것 봅시다)
namespace MoreEffectiveCSharp
{
    /// <summary>
    /// 모든 병렬 쿼리는 분할partitioning 과정부터 시작한다. PLINQ는 입력 요소를 분할한 후, 쿼리를 실행하기 위해 생성한 태스크들에 분할된 요소들을 분배해야 한다.
    /// 
    /// PLINQ는 입력 소스와 쿼리의 종류에 따라 다음 네가지 분할 중 하나를 사용한다. 
    /// ● 범위 분할range partitioning 
    /// ● 덩어리 분할chunk Partitioning 
    /// ● 줄 단위 분할striped partitioning 
    /// ● 해시 분할hash partitioning
    /// 
    /// 가장 단순한 알고리즘은 범위 분할이다. 입력값의 범위를 태스크 수로 나누고, 나눈 집합을 각 태스크에 할당하는 것이다.
    /// 덩어리 분할 알고리즘은 태스크가 추가작업을 요구할 때마다 입력값의 덩어리, 즉 청크chunk를 할당하는 방식이다.
    /// 나머지 두 분할 방식은 특정 쿼리 연산에 최적화돼 있다. 줄 단위 분할은 범위 분할의 특수한 형태로, 시퀀스에서 첫 번째 요소를 찾아내는 처리하는 방법을 최적화한다.
    /// 해시 분할은Join, GroupJoin, GroupBy, Distinct, Except, Union, Intersect를 사용하 는 쿼리를 위해 특별히 설계된 알고리즘이다.
    /// 
    /// 
    /// 
    /// 분할 알고리즘과 별개로, PLINQ는 태스크를 병렬화하기위해 3개의 알고리즘을 사용하는데, 파이프라이닝pipelining, 스톱앤고stop and go, 역열거형inverted enumeration이 있다.
    /// 
    /// 파이프라이닝에서는 하나의 스레드가 순회 과정(foreach 블록이나 쿼리시퀀스)을 처리한다.
    /// 시퀀스의 각 요소에 대한 쿼리를 수행할 때에는 여러 개의 스레드를 이용한다. 
    /// 시퀀스에서 새 로운 요소가 요청될 때마다 다른 스레드가 이를 처리한다. 파이프라이닝 모드에서 PLINQ가 사용하는스레드 수는 일반적으로 코어 수와 같다
    /// 
    /// 실제로는 순회 과정을 처리하는 스레드도 존재한다. 즉, 파이프라이닝은 ‘코어 수 +1’개의 스레드를 생성한다. 
    /// 대부분의 경우 순회 과정을 담당하는 스레드는 대부분의 시간 동안 대기상 태일 것이기 때문에 별도의 스레드로 생성하는 것이 좋다.
    /// 
    /// 스톱앤고 알고리즘에서는 순회를 시작한 스레드가 쿼리 표현식을 수행하는 나머지 스레드와 조인join한다.
    /// 
    /// 역열거형 알고리즘에서는 결과를 생성하지는 않고, 모든 쿼리식의 결과에 다른 액션을 취하는 경우 사용된다.
    /// LINQ to Objects (비병렬) 쿼리는 지연 평가lazy evaluation 된다. 
    /// 즉, 각 값은 요청될 때만 생성된다. 쿼리의 결과를 처리할 때에 (약간 다른) 병렬 실행 모델을 사용할 수도 있는데 이때 필요 한 것이 바로 역열거형 모델이다.
    /// 
    /// 역열거형은 스톱앤고보다 메모리를 적게 사용하며 결과에 대해 병렬 액션을 수행할 수 있다. ForAll()을 사용하고 싶다면 쿼리에AsParallel()을 사용해야 함을 기억하자. 
    /// ForAll()은스 톱앤고보다 메모리를 적게 사용한다. 몇몇 경우에는 쿼리 결과에 대하여 수행되어야 하는 액션의 작업량에 따라 역열거형이 가장 빠른 열거형 방식이 될 수도 있다.
    /// </summary>
}
