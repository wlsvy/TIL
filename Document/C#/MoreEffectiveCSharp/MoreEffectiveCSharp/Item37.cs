using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

//스레드를 생성하지 말고 스레드 풀을 사용하라
namespace MoreEffectiveCSharp
{
    /* 스레드를 수동으로 생성하는 것보다 스레드 풀의 성능이 더 좋은 두 가지 이유 
     * 첫째, 스레드 풀은 작업을 수행할 준비가 된 스레드를 재사용한다. 
     * 스레드를 수동으로 생성하면 작업마다 새로운 스레드를 만들어야 하며 스레드 생성/폐기 비용은 스레드 풀 관리 비용보다 비싸다.
     * 
     * 둘째, 스레드 풀이 활성 스레드의 개수를 자동으로 관리한다. 
     * 스레드를 너무 많이 만들면 시스템은 충분한 리소스가 확보될 때까지 일부 태스크를 큐에 대기시킨다. 
     * QueueUserWorkItem() 은 스레드 풀에서 가용한 스레드에 작업을 할당하는 식으로 스레드 리소스를 관리한다. 
     * 만약 스레드 풀의 모든 스레드가 바쁜 상태라면 가용 상태의 스레드가 생길 때까지 태스크를 큐에 대기 시킨다.
     * 
     * 하지만 .NET의 스레드 풀은 특정 시스템의 스레드 수를 최적화할 때 필요한 모든 정보를 지니고 있다. 
     * 그뿐만 아니라 해당 장비에서 처리하기에 너무 많은 태스크나 스레드를 생성하면 스레드 풀이 새로운 백그라운드 스레드를 사용할 수 있을 때까지 추가 요청들을 대기시킨다. 
     * 게다가 Task 기반 라이브러리는 Task.Run()으로 태스크를 수행하면 이 스레드 풀을 활용한다.
     * 
     * 스레드 풀 안의 스레드 수는 가용스레드의 개수를 최대화하고, 할당 후 사용되지 않은 리소스의 개수를 최소화하는 방식으로 조율된다. 
     * 작업할 항목을 큐에 넣으면, 가용스레드가 있는 경우 스레드 프로시저가 바로 수행된다. 
     * 사용한 스레드를 빠르게 작업에 할당하는 것이 스레드 풀의 역할이다. 핵심은 ‘요청을 던지고 잊으라fire the request and forget it’ 정도로 요약할 수 있다.
     * 
     */
}
