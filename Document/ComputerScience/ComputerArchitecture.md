Computer Architecture(우종정 저)
==========

#### 폰 노이만 아키텍쳐 (von neumann Architecture)
<details>
  <summary>접기/펼치기</summary>

ENIAC 개발 프로젝트의 고문 존 폰 노이만John von Neumann이 제안한 `프로그램 내장식 컴퓨터 stored program computer` 입니다. 컴퓨터 내부에 프로그램과 데이터를 저장하여 컴퓨터가 필요한 내용을 순서에 따라 인출하고 해독하도록 구성하였습니다.

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Von_Neumann_Architecture.svg/1920px-Von_Neumann_Architecture.svg.png" height = "300" width = "600">

[위키](https://ko.wikipedia.org/wiki/%ED%8F%B0_%EB%85%B8%EC%9D%B4%EB%A7%8C_%EA%B5%AC%EC%A1%B0)

</details>

### CPU Instruction Pipeline

<details>
  <summary>접기/펼치기</summary>
 
![](https://www.cybercomputing.co.uk/Languages/LANGgraphics/diagrams/pipelineGraphical.png)
![](https://qph.fs.quoracdn.net/main-qimg-e4fade0a0e249ed852f75c8ec5ce6d5e.webp)

- cpu instruction pipeline 이란 cpu 내에서 다수의 명령을 병행처리하기 위한 기술입니다. 입력으로 넘어오는 명령을 다수의 연속된 단계로 분리하여 cpu 의 모든 부분을 쉴 새 없이 활용할 수 있게 합니다.

- IF = Instruction Fetch
- ID = Instruction Decode
- EX = Execute
- MEM = Memory access
- WB = Register write back

- RISC 와 큰 연관이 있습니다. RISC 는 CISC의 비해 명령어 갯수가 적고 간결화되었으며, 명령어의 크기(피연산자 개수) 등이 가변적이 아니라 고정되었습니다. 이런 특징은 CISC 가 가지는 복잡한 명령어 형식에 비해서 파이프라인을 구현하기에 더 효율적입니다.
  - RISC 구조가 가지는 load store 아키텍쳐는 RISC의 명령어를 메모리 접근 동작과 ALU 동작으로 구분하며 연산을 수행할 때, 메인 메모리의 값을 레지스터로 가져와(load) 연산을 수행하고 다시 메모리에 저장(store)하는 방식을 활용합니다.

#### Reference
- [wikipedia : Instruction_pipelining](https://en.wikipedia.org/wiki/Instruction_pipelining)

</details>

## 3장 명령어 집합

<details>
  <summary>접기/펼치기</summary>
  
- 명령어는 CPU가 사용하는 언어이고, `명령어 집합 Instruction Set`은 특정 CPU를 위해 정의된 명령어 모음을 의미합니다. `명령어 집합 구조 Instruction Set Architecture`는 작성된 프로그램과 그 프로그램을 수행할 컴퓨터 하드웨어 사이의 인터페이스에 대한 정의 혹은 명세라고 볼 수 있습니다. 명령어 집합 구조는
  - 컴퓨터 하드웨어가 어떤 연산을 수행할 수 있고, 각 연산에 어떤 데이터가 필요한지를 명시합니다.
  - 사용할 수 있는 데이터의 표현 방식, 즉 `데이터 형식data type`을 명시합니다.
  - 데이터의 위치에 대한 정보를 알려주는 `주소 지정 방식addressing mode`을 명시합니다.

- 일반적으로 연산은 전송/처리/제어/입출력 연산으로 구분됩니다.
  - 전송 연산 : CPU 내의 레지스터와 메모리 사이에 데이터를 교환하는 적재 및 저장 연산입니다. `LDA`, `STA` 명령어가 이에 해당됩니다.
  - 처리 연산 : `산술 논리 장치 arithmetic logic unit(ALU)` 를 사용하여 데이터를 조작하는 연산입니다. 연산의 종류에 따라 일항/이항/삼항 연산자로 구분되며 `ADD`, `SUB`와 같은 명령어가 있습니다.
  - 제어 연산 : CPU의 제어장치가 프로그램의 실행 순서를 제어하는 연산입니다. 반복문/조건문/프로시저 등에서 명령을 비순차적으로 실행할 때 `무조건 분기 unconditional branch`, `조건 분기 conditional branch`, `프로시저 호출/복귀 cal proc/ret`, `인터럽트 interrupt` 을 활용하는 것을 예로 들 수 있습니다. `HLT`, `RET` 등의 명령어가 있습니다.
  - 입출력 연산 : CPU 내의 레지스터와 외부 장치 사이의 데이터 이동을 수행하는 연산입니다. 데이터를 전송하므로 전송 연산에 포함되기도 합니다.
  
- 대부분의 명령어는 3개의 피연산자 주소를 가지기 때문에 `3-주소 명령어`라고 합니다. `누산기 Accumulator(ACC)`를 사용하는 경우, 피연산자로 누산기를 명시할 필요가 없어서 근원지 피연산자 중의 하나만 명시하므로 `1-주소 명령어`가 됩니다. `스택stack`을 사용하는 명령어는 피연산자의 대한 위치를 명시할 필요가 없기 때문에 `0-주소 명령어`가 됩니다.
  - CPU 내부에 소규모 기억장치(누산기)를 포함한다면 폰노이만 병목에 발생하는 트래픽을 크게 감소시킬 수 있습니다. 반복적으로 사용되는 데이터를 위한 메모리 접근을 줄여주고, 명령어의 길이가 축소되어 명령어 인출을 위한 트래픽이 감소되기 때문입니다.

- CPU의 기본 구성은 다음과 같습니다.
  - 제어장치는 명령어를 해석하고 실행합니다. `프로그램 계수기 PC` 와 `명령어 레지스터 IR`가 여기 포함됩니다.
  - `산술 논리 장치 arithmetic logic unit(ALU)` 는 범용 연산을 수행합니다. `누산기 ACC`가 여기 포함됩니다. 
  - `프로그램 계수기 Program counter(PC)`는 다음에 실행할 명령어의 주소를 보관하는 레지스터입니다. 명령어를 인출한 후에 명령어 길이만큼 값을 장가시켜 다음 명령어를 가리킵니다. 조건/무조건 분기 명령어를 통해 프로그램의 흐름을 변경할 수 있습니다.
  - `명령어 레지스터 instruction register(IR)` 는 가장 최근에 인출한 명령어를 보관하는 레지스터입니다.
  - `누산기 Accumulator(ACC)` 는 데이터를 일시적으로 보관하는 레지스터입니다.
  - `메모리 주소 레지스터memory address register(MAR)` 은 CPU가 메모리에 접근하기 위해 참조하려는 데이터의 주소를 버퍼를 말합니다.
  - `메모리 버퍼 레지스터memory buffer register(MBR)` 은 프로세서가 메모리로부터 읽거나 메모리에 저장할 데이터 자체를 보관하기 위한 버퍼를 말합니다. `메모리 데이터 레지스터memory data register(MDR)` 이라고도 합니다.
  - cpu가 메모리의 데이터를 읽는 것을 `적재load`, 메모리에 데이터를 기록하는 것을 `저장store` 라고 합니다. cpu가 데이터를 적재하거나 저장할 때는 MAR 과 MBR을 사용합니다.

- `프로시저procedure` 는 프로그래밍 언어 또는 사용 방법에 따라 `서브루틴subroutine`, `함수function`, `메소드method`, `서브프로그램subprogram` 으로 불리기도 합니다. 프로시저는 특정 작업을 하나의 패키지처럼 수행하기 위한 일련의 명령어를 의미하며, 이때 명령어를 모듈화하여 사용합니다. 특정 작업이 필요한 곳이라면 어디에서든지 몇 번이라도 호출할 수 있습니다.
  - 프로그램의 중복된 코드를 줄이며, `코드 재사용률code reuse`을 높입니다.
  - 프로그램 구현의 상세 내역을 숨겨줍니다. 이를 통해 구현 내역을 추상화 시킬 수 있습니다.
  - 명령어 그룹을 프로시저의 이름으로 나타내기 때문에 프로그램의 의미를 쉽게 파악할 수 있습니다.
  - 프로시저를 호출할 때 `cal proc (proc : 프로시저 이름)` 과 같은 명령어를 사용하며 이때 `스택의 최상위Top of stack(TOS)`에 `복귀 주소 return address`를 저장합니다. 그 후 프로시저의 명령어를 전부 수행하면 `ret` 명령어를 통해 프로시저를 호출한 프로그램으로 복귀시킵니다.

</details>

## 4장 명령어 집합의 분류와 주소 지정 방식

<details>
  <summary>접기/펼치기</summary>
  
- 명령어 내부에 명시적으로 나타난 피연산자의 수에 따라 0-주소 명령어, 1-주소 명령어, 2-주소 명령어 등으로 분류합니다.
  - 0-주소 명령어는 스택 컴퓨터에서 사용됩니다. 연산자를 스택에 올려, 스택의 윗 부분의 값들을 피연산자로 활용합니다.
  - 1-주소 명령어는 누산기 컴퓨터에서 사용됩니다. 누산기의 값을 피연산자로 활용합니다.
  - 2-주소/ 3-주소 명령어는 범용 레지스터 컴퓨터에서 사용됩니다. 다수의 레지스터를 활용해 연산합니다.

- 범용 레지스터 컴퓨터 중에서 적재 명령어와 저장 명령어만 메모리에 접근할 수 있도록 제한하는 컴퓨터를 적재/저장 명령어 컴퓨터라고 합니다.
- 범용 레지스터 컴퓨터는 메모리 주소에 비해 짧은 레지스터 주소를 사용하므로 명령어의 길이가 축소되고, 또한 사용 빈도가 높은 데이터가 레지스터에 있기 때문에 메모리 트래픽이 줄어드는 효과가 큽니다.

- `워드word` 는 명령어와 데이터를 포함할 수 있는 메모리 구성 요소 중 하나이며 cpu에서 사용되는 고정 크기의 데이터 단위입니다.
- 주소 지정 단위는 아키텍처에 의해 직접 명시될 수 있는 정보의 최소 단위를 명시하며, 주소 해상도를 결정합니다. 메모리가 데이터를 담는 그릇의 집합이라고 한다면, 메모리 주소는 그릇에 붙이는 번호표이고, 주소지정 단위는 그릇의 크기를 뜻합니다.

- 메모리 정렬은 데이터와 명령어가 자신의 길이에 대한 배수의 주소에 위치하도록 강제하는 방식으로, 컴퓨터를 구현할 때 실행 속도를 높이기 위해 필요한 사항입니다.
  - 2바이트로 구성된 명령어와 데이터는 2의 배수로 시작되는 주소를 갖고
  - 4바이트로 구성된 명령어와 데이터는 4의 배수로 시작되는 주소를 갖도록 강제합니다.
- 엔디언은 하나의 워드에포함된 바이트를 배열하는 방법을 의미합니다. 빅 엔디언 방식은 제일 작은 주소값의 바이트가 앞자리에 위치하고, 리틀 엔디언 방식은 제일 큰 주소값의 바이트가 앞자리에 위치합니다.
  - 아래는 32bit 정수 0A0B0C0D 를 little/big 엔디언 방식으로 표현한 예시입니다. 빅 엔디언의 경우 우리가 숫자를 읽는 방식 그대로, 리틀 엔디언의 경우 빅 엔디언의 바이트 순서의 반대라는 것을 알 수 있습니다.
![](https://images.squarespace-cdn.com/content/v1/549dcda5e4b0a47d0ae1db1e/1490746414666-EM74IA60AFM16OEH9G22/ke17ZwdGBToddI8pDm48kOMlUb6YZjvz-j7uj5wTIAtZw-zPPgdn4jUwVcJE1ZvWQUxwkmyExglNqGp0IvTJZamWLI2zvYWH8K3-s_4yszcp2ryTI0HqTOaaUohrI8PICROjhJFkM8GI5jSypQ9qrB6ZUKEpH8g8X8GW3p0wQZI/image-asset.png)

- 주소 지정 방식은 명령어의 일부를 사용하여 데이터가 실제 위치한 유효 주소를 결정하는 방법입니다.
  - 즉치 주소 지정 방식/ 묵시 주소 지정 방식/ 레지스터 직접 주소 지정 방식/ 직접 주소 지정 방식 등으로 나뉘어 집니다.
  
- `RISC reduced instruction set computer` 구조는 자주 사용하는 소수의 명령어만을 명령어 집합에 포함하여 하나의 사이클에 실행시키는 방식의 아키텍쳐입니다.
  - RISC 구조의 명령어는 기계어에 가까운 구조로서 소프트웨어를 강조합니다.
  - 단순한 명령어는 하나의 사이클 내에서 실행할 수 있으며, 또한 짧은 사이클 시간도 허용하기 때문에 `파이프라인pipeline` 구현에 적합합니다.
  - 단순한 명령어는 `마이크로 명령어microinstruction`와 거의 일치하며 복잡한 명령어도 단순 명령어의 조합으로 구현합니다.
  - 짧은 사이클 시간을 가집니다. 단순 명령어를 실행하는 데이터 경로가 간단하므로 명령어 실행에 필요한 사이클 시간이 짧습니다.
  - 적재 저장 구조를 사용합니다.
  - 고정된 길이의 명령어/ 단순 명령어 형식은 명령어를 빠르게 해독할 수 있게 합니다.
  - 제한된 종류의 주소 지정 방식. 데이터의 유효 주소를 계산할 필요가 없거나 계산 속도를 향상시킵니다.
  - `하버드 아키텍쳐havard architecture`. 명령어와 데이터가 독립적인 경로를 사용하기 때문에 메모리 대역폭이 증가합니다.
    - 하버드 아키텍쳐는 명령어와 데이터가 사용하는 데이터 경로를 분리하는 구조입니다. 데이터와 명령어가 데이터 경로, 메모리를 공유하는 폰 노이만 아키텍쳐와는 대조되는 형식입니다.
      - 메모리를 2개로 분할하여 명령어와 별도의 메모리에 저장합니다.
      - cpu의 제어장치와 연산장치를 별도의 버스로 각각 연결하여 명령어와 데이터를 병렬로 인출합니다.
- `CISC complex instruction set computer` 구조는 강력하고 복잡한 명령어까지 명령어 집합에 포함하여 코드 밀도를 높이는 아키텍쳐입니다.
  - CISC 구조는 고급언어에 가까운 구조로서 하드웨어를 강조합니다.
  - 복잡한 명령어를 사용하기 위해 가변 명령어 형식을 활용할 수 밖에 없는 특징을 가집니다. 피연산자의 개수가 고정되지 않으며, 많은 종류의 주소 지정 방식을 동반하고, 명령어의 길이를 알 수 없습니다.
  - 복잡한 프로그램 제어는 제어장치의 구성과 `파이프라인pipeline` 구현에 영향을 끼쳐, CISC 같은 경우 복잡하고 강력한 명령어가 실행시간을 증가시킵니다.
  - 컴퓨터의 성능에 있어 최종적으로 고려해야 할 것은 `CPI cycle per instruction`나 사이클 시간이 아니라 애플리케이션 실행 시간입니다. 이에 대해서 CISC가 RISC에 대해 항상 비효율적이라고 볼 수 없으며 최근에는 RISC와 CISC을 범용적으로 사용하는 추세입니다.
  
| 구분 | RISC | CISC |
|:---: | :---: | :---: |
|명령어 형식 | 고정적 | 가변적 |
|명령어 종류 | 적음 | 많음|
|명령어 길이 | 고정적 | 가변적 |
|적재/저장 구조 | 사용 | 미사용 |
|주소 지정 방식 | 단순하고 소수 | 복잡하고 다수|
|회로 구성 | 단순함 | 복잡함|
|장점 | 구현 용이, 파이프라이닝에 효율적 적용 | 호환성 양호, 코드 밀도 양호|
|예 | MIPS, ARM, PowerPC | 인텔x86, DEC VAX 11/780 |

#### Reference
- [네이버 블로그, maxuper : Risc, Cisc 비교](http://blog.naver.com/maxuper/30015489886)

</details>

## 5장 데이터와 디지털 논리회로

<details>
  <summary>접기/펼치기</summary>

- 유부호 정수의 표현 방법은 부호-크기 방식, 2의 보수 방식, 1의 보수 방식, 초과 코드 방식 등이 있습니다.
  - 부호-크기 방식은 가장 왼쪽 비트를 부호비트로 사용하고 나머지 비트는 크기로 사용합니다. 왼쪽 비트가 0일때 양수 1일때 음수를 나타냅니다.
    - 부호 비트만 바꾸면 음수를 양수로, 양수를 음수로 변환할 수 있습니다.
  - 1의 보수 방식은 음수를 표현하기 위해 각 비트를 0과 1 사이에 상호 반전하는 것입니다.
  - 부호-크기 방식과 1의 보수 방식은 양수와 음수 사이의 변환이 쉽지만 0이 2개 존재합니다.
  - 2의 보수 방식은 음수를 표현할 때 1의 보수값에서 +1을 합니다. 양수와 음수 사이의 변환이 복잡하지만 0은 하나입니다.
    - 그런데 0에 대한 표현의 유일성이 범위의 대칭성보다 더 중요하기 때문에 대부분의 아키텍처는 2의 보수 방식을 사용한다.
    - 2의 보수는 부호-크기 방식이나 1의 보수 방식과 달리 (int)의 경우 -2^31 부터 +2^31 - 1 을 표현할 수 있습니다. 

##### 4비트 유부호 정수 표현 방식
| 10진수 | 부호-크기 | 2의 보수 | 1의 보수 |
|:---: | :---: | :---: | :---: |
|+7| 0111 | 0111 | 0111 |
|+6| 0110 | 0110 | 0110 |
|+5| 0101 | 0101 | 0101 |
|+4| 0100 | 0100 | 0100 |
|+3| 0011 | 0011 | 0011 |
|+2| 0010 | 0010 | 0010 |
|+1| 0001 | 0001 | 0001 |
|+0| 0000 | 0000 | 0000 |
|-0| 1000 | - | 1111 |
|-1| 1001 | 1111 | 1110 |
|-2| 1010 | 1110 | 1101 |
|-3| 1011 | 1101 | 1100 |
|-4| 1100 | 1100 | 1011 |
|-5| 1101 | 1011 | 1010 |
|-6| 1110 | 1010 | 1001 |
|-7| 1111 | 1001 | 1000 |
|-8| - | 1000 | - |

- IEEE-754 표준에서 float은 1개의 부호비트, 8개의 지수 비트, 23개의 가수 비트를 가집니다. (double의 경우 부호 1, 지수 11, 가수 52)
  - 가수 부분을 표현할 때, 가장 왼쪽의 숫자는 반드시 1 이므로 이 부분은 따로 비트로 표현하지 않습니다. 이를 잠복 비트(hidden bit)라고 합니다.
  - 부호 S, 가수 M, 지수 E 에 대하여 실수 값 V 는 : V = (-1)^S * (1.M) * 2^(E - 127)
    - 예를 들어 float : C0C0000 에 대해 S = 1, E = 10000001, M = 10000000000000000000000 => V = (-1)^1 * (1.M) * 2 ^ (129 - 127) = -1 * 1.5 * 2^2 = -6.0 (여기서 1.M은 비트표현)
    
- BCD 코드는 2진화 10진 코드라고 불리며 숫자, 알파벳, 특수 기호를 나타내기 위해 6비트로 구성된 코드입니다.
- ASCII 코드는 미국 정보 교환 표준 부호(American Standard Code for Information Interchange)의 줄임말이며 미국 국립표준연구소(ANSI american national standards institute) 가 제정한, 알파벳을 사용하는 대표적인 문자코드입니다.
- 유니코드는 ASCII 코드와 같은 8비트 코드는 영문자를 부호화하기에는 문제가 없지만 한글, 한자, 일본어등 다양한 문자를 표현하는데 가지는 한계를 극복하고자 등장하였습니다.
  - 다국적 문자체계를 표현하기 위해 16비트 체계로 구성한 코드로서 만국 공통의 국제 문자 부호 체계(UCS universal Code System)을 의미합니다.

</details>

## 9장 파이프라이닝

<details>
  <summary>접기/펼치기</summary>

- `파이프라이닝pipelining` 은 명령어 처리 동작을 단계별로 나누고 이를 중첩적으로 수행함으로써 성능을 향상시키는 컴퓨터 기술입니다. 데이터 경로를 여러 단계로 분할하여 명령어가 수행할 작업을 병행 처리합니다.

- 파이프라이닝 기법에서는 다수의 명령어가 동시에 실행되기 때문에 임의의 단계에서 실행 중인 명령어가 다른 단계의 자원을 사용할 수 없습니다.
- 파이프라인이 이상적인 성능 향상을 도모하려면 무시할 수 있을 정도로 작은 래치 지연 시간, 충분한 데이터, 동일한 크기의 파이프라는 조건을 만족해야 하며, 명령어나 데이터 사이의 의존성에 의한 해저드가 없어야 합니다.

- 해저드는 명령어나 데이터가 준비되지 않아서 파이프라인을 멈춰야 하거나 새로운 명령어를 파이프라인에 투입할 경우 잘못된 결과가 초래되는 모든 상황이나 조건을 뜻합니다.
  - 해저드는 크게 구조적 해저드, 데이터 해저드, 명령어 해저드로 구분됩니다.
  - `구조적 해저드structural hazard`는 파이프라인에서 실행 중인 2개 이상의 명령어가 동일한 하드웨어 자원을 동시에 필요로 하여 파이프라인을 멈춰야 하는 상황을 뜻합니다. `자원 해저드resource hazard` 라고도 합니다.
  - `데이터 해저드 data hazard`는 연산할 데이터가 준비되지 않아서 파이프라인을 멈춰야 하는 모든 상황이나 조건을 뜻합니다. `데이터 종속data dependency`이라고도 합니다.
    - 쓰기 후 읽기(RAW read after write), 읽기 후 쓰기(WAR write after read), 쓰기 후 쓰기(WAW write after write) 로 구분됩니다.
    - 주로 선행 명령어나 후행 명령어의 동작에 의해 데이터가 갱신되고 이후 갱신된 데이터를 읽을 때 문제가 발생하는 상황을 일컫습니다.
  - `명령어 해저드instruction hazard`는 실행할 명령어가 결정되지 않았거나 준비되지 않아서 파이프라인을 멈춰야 하는 상황이나 조건으로 `분기 해저드branch hazard`, `제어 해저드control hazard`라고도 합니다.
  - 해저드를 해결하기 위한 방법으로 `전방 전달forwarding`, `지연 적재 delayed slot`, `지연 분기delayed branch`, `분기 예측branch prediction`등 을 활용합니다.

</details>

## 10장 메모리

<details>
  <summary>접기/펼치기</summary>

- `메인 메모리main memory`란 명령어 집합에 의해 정의된 메모리로서 **실행될 프로그램과 데이터가 머무는 장소**를 의미합니다.
  - Cpu 와 메모리는 물리적으로 메인보드의 `노스브리지north bridge`를 통해 서로 연결됩니다. 논리적으로는 주소버스와 데이터버스에 의해 연결되었다고 볼 수 있습니다.
  - 메모리로는 주로 DRAM이 사용되며, CPU는 `메모리 버퍼 레지스터 MBR memory buffer register`와 `메모리 주소 레지스터 MAR memory address register` 를 사용하여 메모리와 데이터를 교환합니다.

- 최대 메모리 용량은 주소 지정 기법에 달려 있습니다. 16비트 주소를 사용하는 컴퓨터의 최대 메모리 용량은 2^16 = 64K 이며, 32비트의 경우 4G 입니다.
- 데이터 버스는 일반적으로 컴퓨터가 사용하는 워드의 크기, 즉 메모리에 접근할 때마다 CPU 사이에 이동하는 데이터의 크기를 결정합니다.
  - 예를 들어, 데이터버스가 16비트라면 워드의 크기도 16비트이며 데이터버스가 32비트이면 워드의 크기도 32비트입니다.
  
- 메모리 지연 시간에는 메모리 접근 시간과 메모리 사이클 시간이 있습니다. 
  - `메모리 접근 시간memory access time`은 데이터 요청부터 데이터 도착까지의 시간입니다
  - `메모리 사이클 시간memory cycle time`은 연속된 데이터 2개의 읽기/쓰기 요청에 대한 시간 간격입니다.
  
- `RAM random access memory`는 `DRAM dynamic random access memory`과 `SRAM static random access meemory` 두 종류로 나누어 집니다.
  - DRAM의 경우 메모리 셀은 시간이 지남에 따라 누전되어 데이터가 사라지므로 데이터 유실을 막으려면 DRAM을 주기적으로 재충전해야 합니다.
  - RAM은 휘발성 메모리이므로 데이터를 유지하려면 전원이 필요합니다.

| 구분 | DRAM | SRAM |
|:---: | :---: | :---: |
|속도|느림|빠름|
|비트당 가격|저렴|비쌈|
|밀도|높음|낮음|
|전력 소모|적음|많음|
|재충전|필요 | 불필요|
|용도|메인 메모리|캐시|

- 메모리는 일반적으로 메모리 셀의 이차원 배열로 구성됩니다.
  - n 비트 주소와 m 비트 데이터를 가진 메모리 배열은 행이 2^n 개, 열이 m 개이므로, 2^n * m DRAM 이라고 합니다.
  
- `ROM read only memory`은 기본적으로 한 번 기록하면 데이터를 변경할 수 없는 메모리이지만, 데이터를 삭제하거나 기록할 수 있는 `PROM programmable ROM`, `EPROM erasable PROM`, `EEPROM electically erasable PROM` 등 다양한 변종이 있습니다.
  - RAM과 달리 비휘발성 메모리이므로 컴퓨터의 기본 구성에 대한 정보나 초기화 루틴, 부팅 프로그램의 경우 ROM 에 저장됩니다.
  
- 프로그램은 주소 공간의 일부에서 일정한 시간 동안 그룹 형태로 참조되는 경향이 있습니다. 이를 `지역성의 원리 principle of locality` 혹은 `참조의 지역성 locality of references`라 하며 두 가지 종류가 있습니다.
  - `시간적 지역성 temporal locality` 는 최근의 참조된 명령어나 데이터가 가까운 미래에 다시 참조되는 경향을 말합니다.
  - `공간적 지역성 spatial locality` 는 최근의 참조된 명령어나 데이터의 이웃이 가까운 미래에 참조되는 경향을 말합니다.
    - 예를 들어 특정 컨테이너 자료구조를 순회하는 경우 공간적 지역성이 나타납니다.

- 컴퓨터 메인 메모리로 사용되는 DRAM의 성능은 많이 향상되었지만, CPU의 빠른 속도를 따라가지 못하고 있습니다. 이런 CPU와 메모리의 속도 차이를 극보하기 위해 `계층적 메모리hierarchical memory` 시스템이 고안되었습니다.
  - 소용량의 속도가 빠른 메모리는 cpu에 가깝게 배치하고, 느리지만 대용량의 메모리를 cpu에 멀리 배치한 계층 구조입니다.
  - 메모리 계층 구조의 궁극적인 목적은 유효 접근 시간을 줄이는 것입니다. 

| 구분 | 레지스터 | 캐시 메모리 | 메모리 | 보조 기억 장치 |
|:---: | :---: | :---: | :---: | :---: |
| 전형적인 용량 | < 1KB | < 16MB | < 16GB | > 100GB |
| 구현 기술 | 다중 포트를 가진 맞춤 메모리, CMOS | 온칩이나 오프칩 CMOS 또는 SRAM | DRAM | 자기디스크, SSD |
| 접근 시간(ns) | 0.15 ~ 0.30 | 0.5 ~ 15 | 30 ~ 200 | 5,000,000 |
| 대역폭(MB/s) | 100.000 ~ 1.000.000 | 10.000 ~ 40.000 | 5.000 ~ 20.000 | 50 ~ 500 |
| 관리 | 컴파일러 | 하드웨어 | 운영체제 | 운영체제 또는 조작원 |

</details>

## 11장 캐시 메모리

<details>
  <summary>접기/펼치기</summary>

- 메인 메모리는 cpu에 비해 속도가 매우 느리기 때문에 메모리에 접근할 때마다 cpu를 효율적으로 사용할 수 없습니다. 이런 점을 보완하고자 cpu와 메모리 사이의 속도 차이를 줄이기 위해 고속 메모리인 `캐시 메모리 cache memory`를 완충 장치로 사용합니다. 
  - 캐시 메모리는 cpu와 메모리 사이의 속도 차이를 줄이기 위한 고속 메모리로 컴퓨터의 기능과는 관계가 없고 성능에만 영향을 미칩니다.
  - 일반적으로 컴퓨터 시스템은 캐시 메모리를 조작할 수 있는 명령어를 프로그래머에게 제공하지 않습니다.

- 캐시 메모리를 포함하는 컴퓨터 시스템의 경우, 메모리에 접근할 때 먼저 캐시에 접근하여 원하는 명령어나 데이터의 존재 여부를 확인합니다.
  - 이때 원하는 항목이 캐시에 있다면 `적중hit`, 없다면 `실패miss`라고 합니다.
  - 캐시의`적중률hit ratio`은 요청한 데이터를 캐시에서 찾을 확률을 의미합니다. `캐시 적중 횟수 / 전체 메모리 참조 횟수` 로 정의합니다.

- 캐시는 메모리보다 용량이 작기 때문에 다수의 메모리 블록이 동일한 캐시 블록에 사상됩니다. 따라서 메모리 블록을 캐시 속에 어떻게 배치하는지에 관한 전략도 중요합니다.
  - 블록 사상 방식은 캐시 블록과 메모리 블록을 대응시키는 방식으로 직접 사상, 완전 연관 사상, 집합 연관 사상 등이 있습니다.
  - 블록 교체 방식은 캐시 실패가 발생하고 캐시 메모리에 적절한 빈 블록이 없을 때 사용 중인 캐시 블록 가운데 어느 것을 교체할지를 결정하는 방식입니다.
    - 무작위, 선입선출, 최소 최근 사용 방식 등이 있습니다.
  - 블록 갱신 방식은 캐시 메모리의 데이터가 수정되었을 때 대응하는 메모리 블록에 대한 갱신 시점을 결정하며, 즉시 쓰기와 나중 쓰기 등이 있습니다.

</details>

## 15장 병렬 처리

<details>
  <summary>접기/펼치기</summary>

- 단일 프로세서를 활용하는 구조의 경우, 아래와 같은 한계점을 지닙니다.
  - 병행적으로 수행될 명령어의 개수를 증가시키는 것은 프로세서의 내부 회로를 복잡하게 만들고 발열을 초래하므로 집적회로에 대한 공정상의 문제가 발생합니다.
  - 클록 속도를 높이면 전력 소모량이 많아져서 발열을 초래하므로 집적회로에 대한 공정상의 문제가 발생합니다.
  - 트랜지스터 사이에 이동하는 전자의 속도가 `RC 지연resistance capacitance delay`, 즉 저항과 커패시턴스capacitance에 의해 제한됩니다. 
    - 프로세스의 성능을 개선하기 위해 칩 밀도를 높이면 저항과 커패시턴스가 증가하므로 오히려 성능이 떨어질 수 있습니다.

- 병령 처리는 다수의 프로그램이나 하나의 프로그램에서 분할된 다수의 프로그램 조각을 다수의 프로세서에 분산 실행함으로써 처리 속도를 향상하는 기술입니다.
  - 전력은 전압의 제곱에 비례하기 때문에 2개의 저전압 프로세서가 1개의 고전압 프로세서보다 전력 소모량이 적습니다. 따라서 병렬 처리는 전력 소모를 줄입니다.
  
- n개의 프로세서를 사용하여 병렬로 처리하면 이론상 최대 n배까지 성능을 향상시킬 수 있지만 아래와 같은 한계점으로 인해 실제 n배까지의 성능 향상은 어렵습니다.
  - 프로그램의 분할 - 병렬 처리를 위해 프로그램의 모든 부분을 분할할 수 있는 것은 아닙니다. 일반적으로 프로그램은 순차적으로 처리해야 할 많은 부분을 포함하는데 프로세스의 이용률을 극대화하려면 순차적으로 처리할 부분을 최소화할 수 있는 병렬 알고리즘이 필요합니다.
  - 분할된 프로그램을 프로세서에 배정하는 스케쥴링 - 독립적으로 실행될 수 있는 작업도 존재하지만, 어떤 작업은 다른 작업이 시작되기 전에 완료되어야 합니다. 또한 대부분의 프로그램 조각을 일부 프로세서가 처리한다면 병렬 처리 효과를 얻기 힘듭니다.
  - 공유 자원의 경합에 대한 중재 및 공유 데이터의 동기화 - 분할된 문제를 다수의 프로세서가 동시에 처리하려면 흔히 프로세서 사이에 데이터를 공유하거나 교환해야 합니다. 이 경우 다수의 프로세서가 공유 자원에 동시에 접근하려는 상황에 대비한 매커니즘이 필요합니다.
  
- Flynn 분류법은 2개의 다른 독립적인 개념인 `명령어 스트림instruction stream`과 `데이터 스트림data stream`을 기준으로 컴퓨터를 분류합니다.
  - 명령어 스트림은 컴퓨터에 의해 수행되는 연속적인 명령어 그룹을 의미하고, 데이터 스트림은 명령어 스트림에 의해 호출되는 연속적인 데이터 그룹을 의미합니다.
  
- Flynn 분류법은 두 가지 스트림에 대한 구조를 네 가지 경우로 분류합니다.
  - `단일 명령어 스트림 단일 데이터 스트림 SISD single instruction stream/single data stream` 구조
    - 하나의 명령어가 하나의 데이터를 한 번에 처리하는 컴퓨터 시스템 구조를 말합니다. 단일 프로세서를 가진 폰노이만 구조가 여기 해당됩니다.
    - SISD 구조는 파이프라이닝이나 슈퍼스칼라와 같은 방법으로 성능을 향상할 수 있습니다.
  - `단일 명령어 스트림 다중 데이터 스트림 SIMD single instruction stream/multiple data stream` 구조
    - 하나의 명령어가 다수의 데이터를 동시에 처리하는 컴퓨터 시스템 구조를 말합니다.
    - 하나의 제어장치와 다수의 처리장치로 구성되며, 배열 프로세서나 벡터 프로세서가 여기에 해당됩니다.
  - `다중 명령어 스트림 단일 데이터 스트림 MISD multiple instruction stream/single data stream` 구조
    - 다수의 명령어 스트림이 하나의 데이터를 처리하는 컴퓨터 시스템을 말합니다. MISD 구조는 아직까지 구현되지 않았으며 실용적인 측면에서 존재하기 어렵습니다.
  - `다중 명령어 스트림 다중 데이터 스트림 MIMD multiple instruction stream/multiple data stream` 구조
    - 다수의 명령어 스트림이 다수의 데이터를 처리하는  컴퓨터 시스템 구조를 말합니다.
    - MIMD 구조는 매우 광범위하고 대부분의 병렬 처리가 여기 속합니다. SIMD 구조보다 설계가 복잡하지만 융통성이 큰 MIMD 구조의 모든 프로세서는 상호 연결망(IN interconnection network)으로 연결됩니다.
    - MIMD 구조는 프로세서-메모리 인터페이스 수준에서 구현된 `다중 프로세서 시스템 multiprocessor system`과 시스템 수준에서 구현된 `다중 컴퓨터 시스템multi-computer system` 등이 있습니다. 다중 프로세서 시스템은 다수의 cpu를 가진 하나의 컴퓨터이지만, 다중 컴퓨터 시스템은 다수의 컴퓨터로 구성됩니다.
    
- SIMS 방식의 대표적인 예로 벡터 프로세서와 GPU가 있습니다. 벡터 프로세서는 호스트 컴퓨터로부터 행렬 연산과 같은 대규모 연산 작업을 의뢰받아 고속으로 처리하는 보조 프로세서로 사용됩니다. GPU는 그래픽 작업을 수행하는 데 특화된 프로세서입니다.

- 다중 프로세서 시스템은 다수의 프로세서가 시스템 메모리나 주변장치의 일부 혹은 전부를 공유합니다. 프로세서 상의 상호작용 정도가 높기 때문에 `강결합 시스템tightly coupled system`, `밀결합 시스템` 이라고 합니다.
  - 모든 프로세서에 단일 메모리 주소 공간을 제공하며 메모리를 공유하기 때문에 모든 프로세서가 적재 및 저장 명령을 통해 메모리의 어디에든 접근할 수 있습니다.
  - 또한 메모리 모듈을 공유하므로 `공유 메모리 다중 프로세서 shared memory multiprocessor` 라고도 합니다.
  - 프로세서 사이의 데이터 교환 매커니즘이 필요 없습니다.
  - 프로그램 실행 중에 프로세서에 작업을 균등하게 분배할 수 있으므로 프로세서의 이용률을 극대화할 수 있습니다.
  - 모든 프로세서가 단일 주소 공간을 사용하므로 기존 프로그램을 병렬 처리에 쉽게 활용할 수 있습니다.
  - 프로세서와 메모리 모듈 사이의 통신량이 많으면 프로세서 - 메모리 상호 연결망에 과도한 트래픽이 발생할 수 있습니다. 따라서 대역폭이 높은 상호 연결망이 아니라면 병목 현상이 나타날 수 있습니다.
  - 다수의 프로세서가 동일한 영역의 메모리에 동시에 접근할 경우 충돌이 발생할 수 있습니다. 특히 많은 프로세서가 연속적으로 접근해야 할 데이터가 있다면 성능이 크게 저하될 수 있습니다.

- 다중 컴퓨터 시스템은 `약결합 시스템loosely coupled system`, 소결합 시스템 이라고도 합니다.
  - 메모리 모듈을 공유하지 않고 별도로 가지고 있으므로 `분산 메모리 컴퓨터 distributed memory computer 시스템` 이라고도 합니다. 오늘날에는 다중 컴퓨터 시스템 방식으로 `클러스터cluster`가 널리 사용되고 있습니다.
  - 다중 컴퓨터 시스템은 지리적으로 분산될 수 있는 다수의 독립된autonomous 컴퓨터로 구성되며, 각 프로세서는 자신의 지역 메모리와 주변장치를 가지고 있습니다. 공유하는 메모리가 없어 다른 프로세서의 메모리에는 접근할 수 없습니다.
  - 다중 프로세서 시스템에 비해 아래의 장점을 가집니다.
    - 버스 경합이 거의 없습니다. 각 프로세서가 다른 프로세서의 간섭 없이 자신의 지역 메모리를 충분한 대역폭으로 사용할 수 있기 때문입니다.
    - 공유 버스가 없으므로 노드의 개수에 대한 제한이 없습니다. 따라서 시스템의 크기가 노드를 연결하는 상호 연결망에 좌우됩니다.
    - 다른 프로세서의 지역 메모리를 수정할 수 없으므로 캐시 일관성 문제에서 자유롭습니다.
  - 그러나 프로세서 사이의 통신이 매우 복잡할 경우 단점이 있습니다.
    - 다른 프로세서의 메모리에 있는 데이터가 필요하면 다른 프로세서와 메시지를 통해 교환해야 하므로 빈번한 메시지 교환이 발생할 경우 성능이 떨어질 수 있습니다.
    - 상호 메시지를 교환하는 독립적인 태스크의 집합으로 프로그램을 구성해야 하므로 프로그래밍에 대한 부담이 큽니다.

</details>
