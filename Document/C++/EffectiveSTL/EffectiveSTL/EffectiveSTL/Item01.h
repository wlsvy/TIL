#pragma once
#include <iostream>
#include <vector>
#include <string>
#include <array>

//적재적소에 알맞은 컨테이너를 사용하자

namespace Item01 {
	using namespace std;

	/*
		STL에는 많은 컨테이너들이 있습니다. 다양한 컨테이너의 종류를 정리해 보도록 합시다.

		표준 STL 시퀸스(sequence) 컨테이너: vector, string, deque, list.
		표준 STL 연관(associative) 컨테이너: set, multiset, map, multimap.
		비표준 시퀸스 컨테이너: slist(단일 연결 리스트), rope(대용량 string).
		비표준 연관 컨테이너: hash_set, hash_multiset, hash_map, hash_multimap.
		STL에 속하지 않은 표준 컨테이너: 배열(C++ 배열), bitset, valarray, stack, queue, priority_queue. 

		string 대신에 사용되는 vector<char>: 간혹 이렇게 쓰면 괜찮을 때가 있습니다 (항목13)
		표준 연관 컨테이너 대신 사용되는 vector: vector가 수행 속도나 크기 면에서 표준 연관 컨테이너보다 더 나은 경우가 있습니다 (항목23)
	*/


	/*
		STL 컨테이너는 연속 메모리(continuous-memory) 컨테이너와 노드 기반(node-based) 컨테이너로 나눌 수 있습니다.
		
		1. 연속 메모리 컨테이너(배열 기반 컨테이너(array-based container)라고도 합니다)
		동적 할당된 하나 이상(대개 하나)의 메모리 단위(chunk)에다가 데이터 요소를 저장해 두는 컨테이너입니다. 

		새 요소가 삽입되거나 이미 있던 요소가 지워지면(erase), 
		같은 메모리 단위에 있던 다른 요소들은 앞 혹은 뒤로 밀려나면서 새 요소가 삽입될 공간을 만들던지, 지워진 공간을 메웁니다. 
		이러한 "밀어내기" 때문에 수행 성능의 발목을 잡을 수 있고(항목 5와 14를 참고하세요), 예외 안전성(exception safety)에도 영향을 미칩니다.
		
		여기에 속하는 컨테이너는 vector, string, deque입니다. 비표준 컨테이너인 rope 역시 연속 메모리 컨테이너입니다.

		2. 노드 기반 컨테이너
		동적 할당된 하나의 메모리 단위에다가 하나의 요소만을 저장합니다. 
		컨테이너 요소를 삽입 혹은 삭제했을 때 노드의 포인터만이 영향을 받지, 노드의 내용은 그대로입니다. 
		따라서, 삭제나 삽입이 일어났다고 해도 나머지 요소들이 밀려난다든지 하는 일이 없습니다.
		
		연결 리스트를 나타내는 컨테이너, 즉 list와 slist가 노드 기반이고, 표준 연관 컨테이너 모두가 노드 기반 입니다
		(이것들은 전형적으로 균형 트리(balanced tree)로 구현되어 있습니다).
	*/
	/*
		1. 컨테이너의 아무 위치에 요소를 삽입할 수 있어야 하나요? 
		- 그렇다면, 시퀸스 컨테이너가 필요합니다. 연관 컨테이너는 이것이 불가능합니다.

		2. 컨테이너 내의 요소들의 순서 결정에 직접 관여하고 싶나요? 
		- 그렇지 않은 경우에는 해쉬 컨테이너가 가장 괜찮은 선택이고, 그렇다면 해쉬 컨테이너는 피해야 합니다.

		3. 표준 C++에 포함된 컨테이너를 사용해야 하나요? 
		- 그런 경우에는 해쉬 컨테이너, slist, rope는 쓸 수 없습니다.

		4. 어떤 타입의 반복자가 필요하십니까? 
		- 임의 접근 반복자이어야 한다면 여러분의 선택 폭은 vector, deque, string으로 좁아지고요, rope도 고려해 볼 수 있습니다. 양방향 반복자가 필요한 경우에는 slist(항목 50 참조)와 해쉬 컨테이너는 쓸 수 없습니다.
		
		5. 요소 삽입이나 삭제시 다른 컨테이너 요소들이 밀려나는 일이 없어야 한다면요? 
		- 그런 경우에는 연속 메모리 컨테이너에 손도 대지 마세요.

		6. 컨테이너 내의 데이터가 C의 데이터 타입과 메모리 배열 구조적으로 호환되어야 하나요? 
		- 이 때에는 vector 밖에 쓸 것이 없습니다.

		7. 탐색 속도가 가장 중요한 관심사인가요? 
		- 그렇다면 해쉬 컨테이너(항목 25 참조), 정렬된 vector(항목 23 참조), 그리고 표준 연관 컨테이너 중 하나를 택하세요.이 순서대로 고려하면 될 것입니다.
		
		8. 컨테이너의 참조 카운팅이 신경 쓰이나요? 
		- 그렇다면 string 가까이에는 가지 않는 것이 좋습니다. 많은 string 코드가 참조 카운팅이 되도록 구현되어 있습니다(항목 13 참조). 
		rope도 피하세요. rope는 확실히 참조 카운팅에 기반하여 구현되어 있기 때문이죠(항목 50 참조). 
		물론 어떻게든 문자열을 나타낼 필요가 있으므로, 이럴 때 vector<char>를 쓰는 것입니다.
		
		9. 삽입과 삭제가 트랜잭션적인 의미를 가지고 이루어졌으면 하나요? 
		- 즉, 삽입과 삭제 동작을 안정적으로 되돌릴(roll back) 수 있어야 하느냐란 뜻입니다. 그렇다면 노드 기반 컨테이너를 고려해 보시기 바랍니다. 
		트랜잭션적인 삽입이 여러 개의 요소(범위로 주어집니다)에 대해 이루어져야 할 경우에는 list를 선택합니다. 
		그 요구를 만족할 수 있는 유일한 STL 표준 컨테이너입니다. 
		트랜잭션적인 동작은 코드에 예외 안전성(exception safety)을 추가하고자 하는 경우에 대단히 중요한 특징입니다.
		(연속 메모리 컨테이너라고 해서 이것이 되지 않는다는 법은 없지만, 수행성능의 비용도 만만치 않고 코드가 간단하지 않습니다.항목 17)
		
		10. 반복자, 포인터, 참조자가 무효화(포인터가 가리키고 있던 메모리의 실제 내용이 없어지는 일)되는 일을 최소화해야 하나요? 
		- 이런 경우에는 노드 기반 컨테이너를 사용하기 바랍니다. 
		노드 기반 컨테이너는 노드 삽입과 삭제가 일어나도 기존의 반복자나 포인터 혹은 참조자가 무효화되지 않기 때문입니다(가리키고 있는 요소를 삭제하지 않는 한 말이죠). 
		반대로 연속 메모리 컨테이너는 전체적인 메모리 재할당이 빈번하게 일어나기 때문에 반복자나 포인터, 참조자가 무효화되기 쉽습니다.
		
		11. 임의 접근 반복자를 지원하는 시퀸스 컨테이너가 필요한데, 요소 삭제가 일어나지 않고 요소 삽입이 컨테이너의 끝에서만 일어나는 한, 포인터와 참조자가 무효화되지 않는 것이 필요한가요? 
		- 아주 특별한 경우이긴 하지만, 어쩌다 이런 경우를 만난다면 deque가 정답입니다. 
		deque는 요소 삽입이 끝에서 일어날 때 반복자만 무효화되는 재미있는 컨테이너입니다(STL 컨테이너 중 포인터와 참조자를 무효화시키지 않고 반복자만 무효화되는 것은 deque가 유일합니다).
	*/

	/*
		vector, list, deque는 각자의 계산 복잡도를 제공하기 때문에 이를 고려하여 사용해야 한다. 
		
		vector는 기본적으로 사용되는 시퀸스이다. 
		list는 시퀸스의 중간에 빈번한 삽입, 삭제가 수행될 필요가 있을 때 사용한다. 
		deque는 대부분의 삽입과 삭제가 시퀸스의 앞과 끝에서 일어나는 경우에 사용되는 자료 구조이다.
	*/
}