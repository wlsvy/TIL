Computer Architecture(우종정 저)
==========

#### 폰 노이만 아키텍쳐 (von neumann Architecture)
<details>
  <summary>접기/펼치기</summary>

ENIAC 개발 프로젝트의 고문 존 폰 노이만John von Neumann이 제안한 `프로그램 내장식 컴퓨터 stored program computer` 입니다. 컴퓨터 내부에 프로그램과 데이터를 저장하여 컴퓨터가 필요한 내용을 순서에 따라 인출하고 해독하도록 구성하였습니다.

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Von_Neumann_Architecture.svg/1920px-Von_Neumann_Architecture.svg.png" height = "300" width = "600">

[위키](https://ko.wikipedia.org/wiki/%ED%8F%B0_%EB%85%B8%EC%9D%B4%EB%A7%8C_%EA%B5%AC%EC%A1%B0)

</details>

## 3장 명령어 집합

<details>
  <summary>접기/펼치기</summary>
  
- 명령어는 CPU가 사용하는 언어이고, `명령어 집합 Instruction Set`은 특정 CPU를 위해 정의된 명령어 모음을 의미합니다. `명령어 집합 구조 Instruction Set Architecture`는 작성된 프로그램과 그 프로그램을 수행할 컴퓨터 하드웨어 사이의 인터페이스에 대한 정의 혹은 명세라고 볼 수 있습니다. 명령어 집합 구조는
  - 컴퓨터 하드웨어가 어떤 연산을 수행할 수 있고, 각 연산에 어떤 데이터가 필요한지를 명시합니다.
  - 사용할 수 있는 데이터의 표현 방식, 즉 `데이터 형식data type`을 명시합니다.
  - 데이터의 위치에 대한 정보를 알려주는 `주소 지정 방식addressing mode`을 명시합니다.

- 일반적으로 연산은 전송/처리/제어/입출력 연산으로 구분됩니다.
  - 전송 연산 : CPU 내의 레지스터와 메모리 사이에 데이터를 교환하는 적재 및 저장 연산입니다. `LDA`, `STA` 명령어가 이에 해당됩니다.
  - 처리 연산 : `산술 논리 장치 arithmetic logic unit(ALU)` 를 사용하여 데이터를 조작하는 연산입니다. 연산의 종류에 따라 일항/이항/삼항 연산자로 구분되며 `ADD`, `SUB`와 같은 명령어가 있습니다.
  - 제어 연산 : CPU의 제어장치가 프로그램의 실행 순서를 제어하는 연산입니다. 반복문/조건문/프로시저 등에서 명령을 비순차적으로 실행할 때 `무조건 분기 unconditional branch`, `조건 분기 conditional branch`, `프로시저 호출/복귀 cal proc/ret`, `인터럽트 interrupt` 을 활용하는 것을 예로 들 수 있습니다. `HLT`, `RET` 등의 명령어가 있습니다.
  - 입출력 연산 : CPU 내의 레지스터와 외부 장치 사이의 데이터 이동을 수행하는 연산입니다. 데이터를 전송하므로 전송 연산에 포함되기도 합니다.
  
- 대부분의 명령어는 3개의 피연산자 주소를 가지기 때문에 `3-주소 명령어`라고 합니다. `누산기 Accumulator(ACC)`를 사용하는 경우, 피연산자로 누산기를 명시할 필요가 없어서 근원지 피연산자 중의 하나만 명시하므로 `1-주소 명령어`가 됩니다. `스택stack`을 사용하는 명령어는 피연산자의 대한 위치를 명시할 필요가 없기 때문에 `0-주소 명령어`가 됩니다.
  - CPU 내부에 소규모 기억장치(누산기)를 포함한다면 폰노이만 병목에 발생하는 트래픽을 크게 감소시킬 수 있습니다. 반복적으로 사용되는 데이터를 위한 메모리 접근을 줄여주고, 명령어의 길이가 축소되어 명령어 인출을 위한 트래픽이 감소되기 때문입니다.

- CPU의 기본 구성은 다음과 같습니다.
  - 제어장치는 명령어를 해석하고 실행합니다. `프로그램 계수기 PC` 와 `명령어 레지스터 IR`가 여기 포함됩니다.
  - `산술 논리 장치 arithmetic logic unit(ALU)` 는 범용 연산을 수행합니다. `누산기 ACC`가 여기 포함됩니다. 
  - `프로그램 계수기 Program counter(PC)`는 다음에 실행할 명령어의 주소를 보관하는 레지스터입니다. 명령어를 인출한 후에 명령어 길이만큼 값을 장가시켜 다음 명령어를 가리킵니다. 조건/무조건 분기 명령어를 통해 프로그램의 흐름을 변경할 수 있습니다.
  - `명령어 레지스터 instruction register(IR)` 는 가장 최근에 인출한 명령어를 보관하는 레지스터입니다.
  - `누산기 Accumulator(ACC)` 는 데이터를 일시적으로 보관하는 레지스터입니다.
  - `메모리 주소 레지스터memory address register(MAR)` 은 CPU가 메모리에 접근하기 위해 참조하려는 데이터의 주소를 버퍼를 말합니다.
  - `메모리 버퍼 레지스터memory buffer register(MBR)` 은 프로세서가 메모리로부터 읽거나 메모리에 저장할 데이터 자체를 보관하기 위한 버퍼를 말합니다. `메모리 데이터 레지스터memory data register(MDR)` 이라고도 합니다.
  - cpu가 메모리의 데이터를 읽는 것을 `적재load`, 메모리에 데이터를 기록하는 것을 `저장store` 라고 합니다. cpu가 데이터를 적재하거나 저장할 때는 MAR 과 MBR을 사용합니다.

- `프로시저procedure` 는 프로그래밍 언어 또는 사용 방법에 따라 `서브루틴subroutine`, `함수function`, `메소드method`, `서브프로그램subprogram` 으로 불리기도 합니다. 프로시저는 특정 작업을 하나의 패키지처럼 수행하기 위한 일련의 명령어를 의미하며, 이때 명령어를 모듈화하여 사용합니다. 특정 작업이 필요한 곳이라면 어디에서든지 몇 번이라도 호출할 수 있습니다.
  - 프로그램의 중복된 코드를 줄이며, `코드 재사용률code reuse`을 높입니다.
  - 프로그램 구현의 상세 내역을 숨겨줍니다. 이를 통해 구현 내역을 추상화 시킬 수 있습니다.
  - 명령어 그룹을 프로시저의 이름으로 나타내기 때문에 프로그램의 의미를 쉽게 파악할 수 있습니다.
  - 프로시저를 호출할 때 `cal proc (proc : 프로시저 이름)` 과 같은 명령어를 사용하며 이때 `스택의 최상위Top of stack(TOS)`에 `복귀 주소 return address`를 저장합니다. 그 후 프로시저의 명령어를 전부 수행하면 `ret` 명령어를 통해 프로시저를 호출한 프로그램으로 복귀시킵니다.

</details>

## 4장 명령어 집합의 분류와 주소 지정 방식

<details>
  <summary>접기/펼치기</summary>
  
- 명령어 내부에 명시적으로 나타난 피연산자의 수에 따라 0-주소 명령어, 1-주소 명령어, 2-주소 명령어 등으로 분류합니다.
  - 0-주소 명령어는 스택 컴퓨터에서 사용됩니다. 연산자를 스택에 올려, 스택의 윗 부분의 값들을 피연산자로 활용합니다.
  - 1-주소 명령어는 누산기 컴퓨터에서 사용됩니다. 누산기의 값을 피연산자로 활용합니다.
  - 2-주소/ 3-주소 명령어는 범용 레지스터 컴퓨터에서 사용됩니다. 다수의 레지스터를 활용해 연산합니다.

- 범용 레지스터 컴퓨터 중에서 적재 명령어와 저장 명령어만 메모리에 접근할 수 있도록 제한하는 컴퓨터를 적재/저장 명령어 컴퓨터라고 합니다.
- 범용 레지스터 컴퓨터는 메모리 주소에 비해 짧은 레지스터 주소를 사용하므로 명령어의 길이가 축소되고, 또한 사용 빈도가 높은 데이터가 레지스터에 있기 때문에 메모리 트래픽이 줄어드는 효과가 큽니다.

- `워드word` 는 명령어와 데이터를 포함할 수 있는 메모리 구성 요소 중 하나이며 cpu에서 사용되는 고정 크기의 데이터 단위입니다.
- 주소 지정 단위는 아키텍처에 의해 직접 명시될 수 있는 정보의 최소 단위를 명시하며, 주소 해상도를 결정합니다. 메모리가 데이터를 담는 그릇의 집합이라고 한다면, 메모리 주소는 그릇에 붙이는 번호표이고, 주소지정 단위는 그릇의 크기를 뜻합니다.

- 메모리 정렬은 데이터와 명령어가 자신의 길이에 대한 배수의 주소에 위치하도록 강제하는 방식으로, 컴퓨터를 구현할 때 실행 속도를 높이기 위해 필요한 사항입니다.
  - 2바이트로 구성된 명령어와 데이터는 2의 배수로 시작되는 주소를 갖고
  - 4바이트로 구성된 명령어와 데이터는 4의 배수로 시작되는 주소를 갖도록 강제합니다.
- 엔디언은 하나의 워드에포함된 바이트를 배열하는 방법을 의미합니다. 빅 엔디언 방식은 큰 단위의 바이트가 앞자리에 위치하고, 리틀 엔디언 방식은 작은 단위의 바이트가 앞자리에 위치합니다.

- 주소 지정 방식은 명령어의 일부를 사용하여 데이터가 실제 위치한 유효 주소를 결정하는 방법입니다.
  - 즉치 주소 지정 방식/ 묵시 주소 지정 방식/ 레지스터 직접 주소 지정 방식/ 직접 주소 지정 방식 등으로 나뉘어 집니다.
  
- `RISC reduced instruction set computer` 구조는 자주 사용하는 소수의 명령어만을 명령어 집합에 포함하여 하나의 사이클에 실행시키는 방식의 아키텍쳐입니다.
  - RISC 구조의 명령어는 기계어에 가까운 구조로서 소프트웨어를 강조합니다.
  - 단순한 명령어는 하나의 사이클 내에서 실행할 수 있으며, 또한 짧은 사이클 시간도 허용하기 때문에 `파이프라인pipeline` 구현에 적합합니다.
  - 단순한 명령어는 `마이크로 명령어microinstruction`와 거의 일치하며 복잡한 명령어도 단순 명령어의 조합으로 구현합니다.
  - 짧은 사이클 시간을 가집니다. 단순 명령어를 실행하는 데이터 경로가 간단하므로 명령어 실행에 필요한 사이클 시간이 짧습니다.
  - 적재 저장 구조를 사용합니다.
  - 고정된 길이의 명령어/ 단순 명령어 형식은 명령어를 빠르게 해독할 수 있게 합니다.
  - 제한된 종류의 주소 지정 방식. 데이터의 유효 주소를 계산할 필요가 없거나 계산 속도를 향상시킵니다.
  - `하버드 아키텍쳐havard architecture`. 명령어와 데이터가 독립적인 경로를 사용하기 때문에 메모리 대역폭이 증가합니다.
    - 하버드 아키텍쳐는 명령어와 데이터가 사용하는 데이터 경로를 분리하는 구조입니다. 데이터와 명령어가 데이터 경로, 메모리를 공유하는 폰 노이만 아키텍쳐와는 대조되는 형식입니다.
      - 메모리를 2개로 분할하여 명령어와 별도의 메모리에 저장합니다.
      - cpu의 제어장치와 연산장치를 별도의 버스로 각각 연결하여 명령어와 데이터를 병렬로 인출합니다.
- `CISC complex instruction set computer` 구조는 강력하고 복잡한 명령어까지 명령어 집합에 포함하여 코드 밀도를 높이는 아키텍쳐입니다.
  - CISC 구조는 고급언어에 가까운 구조로서 하드웨어를 강조합니다.
  - 복잡한 명령어를 사용하기 위해 가변 명령어 형식을 활용할 수 밖에 없는 특징을 가집니다. 피연산자의 개수가 고정되지 않으며, 많은 종류의 주소 지정 방식을 동반하고, 명령어의 길이를 알 수 없습니다.
  - 복잡한 프로그램 제어는 제어장치의 구성과 `파이프라인pipeline` 구현에 영향을 끼쳐, CISC 같은 경우 복잡하고 강력한 명령어가 실행시간을 증가시킵니다.
  - 컴퓨터의 성능에 있어 최종적으로 고려해야 할 것은 `CPI cycle per instruction`나 사이클 시간이 아니라 애플리케이션 실행 시간입니다. 이에 대해서 CISC가 RISC에 대해 항상 비효율적이라고 볼 수 없으며 최근에는 RISC와 CISC을 범용적으로 사용하는 추세입니다.
  
| 구분 | RISC | CISC |
|:---: | :---: | :---: |
|명령어 형식 | 고정적 | 가변적 |
|명령어 종류 | 적음 | 많음|
|명령어 길이 | 고정적 | 가변적 |
|적재/저장 구조 | 사용 | 미사용 |
|주소 지정 방식 | 단순하고 소수 | 복잡하고 다수|
|회로 구성 | 단순함 | 복잡함|
|장점 | 구현 용이, 파이프라이닝에 효율적 적용 | 호환성 양호, 코드 밀도 양호|
|예 | MIPS, ARM, PowerPC | 인텔x86, DEC VAX 11/780 |

</details>

## 5장 명령어 집합의 분류와 주소 지정 방식

<details>
  <summary>접기/펼치기</summary>

- 유부호 정수의 표현 방법은 부호-크기 방식, 2의 보수 방식, 1의 보수 방식, 초과 코드 방식 등이 있습니다.
  - 부호-크기 방식은 가장 왼쪽 비트를 부호비트로 사용하고 나머지 비트는 크기로 사용합니다. 왼쪽 비트가 0일때 양수 1일때 음수를 나타냅니다.
    - 부호 비트만 바꾸면 음수를 양수로, 양수를 음수로 변환할 수 있습니다.
  - 1의 보수 방식은 음수를 표현하기 위해 각 비트를 0과 1 사이에 상호 반전하는 것입니다.
  - 부호-크기 방식과 1의 보수 방식은 양수와 음수 사이의 변환이 쉽지만 0이 2개 존재합니다.
  - 2의 보수 방식은 음수를 표현할 때 1의 보수값에서 +1을 합니다. 양수와 음수 사이의 변환이 복잡하지만 0은 하나입니다.
    - 그런데 0에 대한 표현의 유일성이 범위의 대칭성보다 더 중요하기 때문에 대부분의 아키텍처는 2의 보수 방식을 사용한다.
    - 2의 보수는 부호-크기 방식이나 1의 보수 방식과 달리 (int)의 경우 -2^31 부터 +2^31 - 1 을 표현할 수 있습니다. 

##### 4비트 유부호 정수 표현 방식
| 10진수 | 부호-크기 | 2의 보수 | 1의 보수 }
|:---: | :---: | :---: | :---: |
|+7| 0111 | 0111 | 0111 |
|+6| 0110 | 0110 | 0110 |
|+5| 0101 | 0101 | 0101 |
|+4| 0100 | 0100 | 0100 |
|+3| 0011 | 0011 | 0011 |
|+2| 0010 | 0010 | 0010 |
|+1| 0001 | 0001 | 0001 |
|+0| 0000 | 0000 | 0000 |
|-0| 1000 | - | 1111 |
|-1| 1001 | 1111 | 1110 |
|-2| 1010 | 1110 | 1101 |
|-3| 1011 | 1101 | 1100 |
|-4| 1100 | 1100 | 1011 |
|-5| 1101 | 1011 | 1010 |
|-6| 1110 | 1010 | 1001 |
|-7| 1111 | 1001 | 1000 |
|-8| - | 1000 | - |

- IEEE-754 표준에서 float은 1개의 부호비트, 8개의 지수 비트, 23개의 가수 비트를 가집니다. (double의 경우 부호 1, 지수 11, 가수 52)
  - 가수 부분을 표현할 때, 가장 왼쪽의 숫자는 반드시 1 이므로 이 부분은 따로 비트로 표현하지 않습니다. 이를 잠복 비트(hidden bit)라고 합니다.
  - 부호 S, 가수 M, 지수 E 에 대하여 실수 값 V 는 : V = (-1)^S * (1.M) * 2^(E - 127)
    - 예를 들어 float : C0C0000 에 대해 S = 1, E = 10000001, M = 10000000000000000000000 => V = (-1)^1 * (1.M) * 2 ^ (129 - 127) = -1 * 1.5 * 2^2 = -6.0 (여기서 1.M은 비트표현)
    
- BCD 코드는 2진화 10진 코드라고 불리며 숫자, 알파벳, 특수 기호를 나타내기 위해 6비트로 구성된 코드입니다.
- ASCII 코드는 미국 정보 교환 표준 부호(American Standard Code for Information Interchange)의 줄임말이며 미국 국립표준연구소(ANSI american national standards institute) 가 제정한, 알파벳을 사용하는 대표적인 문자코드입니다.
- 유니코드는 ASCII 코드와 같은 8비트 코드는 영문자를 부호화하기에는 문제가 없지만 한글, 한자, 일본어등 다양한 문자를 표현하는데 가지는 한계를 극복하고자 등장하였습니다.
  - 다국적 문자체계를 표현하기 위해 16비트 체계로 구성한 코드로서 만국 공통의 국제 문자 부호 체계(UCS universal Code System)을 의미합니다.

</details>

##### 파이프라인(Pipeline)
- 파이프라이닝은 명령어 처리 동작을 단계별로 나누고 이를 중첩적으로 수행함으로써 성능을 향상시키는 컴퓨터 기술입니다. 데이터 경로를 여러 단계로 분할하여 명령어가 수행할 작업을 병행 처리합니다.
- 해저드는 명령어나 데이터가 준비되지 않아서 파이프라인을 멈춰야 하거나 새로운 명령어를 파이프라인에 투입할 경우 잘못된 결과가 초래되는 모든 상황이나 조건을 뜻합니다.
- 파이프라이닝 기법에서는 다수의 명령어가 동시에 실행되기 때문에 임의의 단계에서 실행 중인 명령어가 다른 단계의 자원을 사용할 수 없습니다.
- 파이프라인이 이상적인 성능 향상을 도모하려면 무시할 수 있을 정도로 작은 래치 지연 시간, 충분한 데이터, 동일한 크기의 파이프라는 조건을 만족해야 하며, 명령어나 데이터 사이의 의존성에 의한 해저드가 없어야 합니다.

```diff
- 폰 노이만 아키텍쳐
- 3장
- 4장
- 5장
+ 7장(사이클)
+ 9장
+ 10장
+ 11장
+ 12장
+ 14장
+ 15장

```
