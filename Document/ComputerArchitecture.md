Computer Architecture(우종정 저)
==========

##### 폰 노이만 아키텍쳐 (von neumann Architecture)
ENIAC 개발 프로젝트의 고문 존 폰 노이만John von Neumann이 제안한 `프로그램 내장식 컴퓨터 stored program computer` 입니다. 컴퓨터 내부에 프로그램과 데이터를 저장하여 컴퓨터가 필요한 내용을 순서에 따라 인출하고 해독하도록 구성하였습니다.

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Von_Neumann_Architecture.svg/1920px-Von_Neumann_Architecture.svg.png" height = "300" width = "600">

[위키](https://ko.wikipedia.org/wiki/%ED%8F%B0_%EB%85%B8%EC%9D%B4%EB%A7%8C_%EA%B5%AC%EC%A1%B0)

## 명령어 집합
- 명령어는 CPU가 사용하는 언어이고, `명령어 집합 Instruction Set`은 특정 CPU를 위해 정의된 명령어 모음을 의미합니다. `명령어 집합 구조 Instruction Set Architecture`는 작성된 프로그램과 그 프로그램을 수행할 컴퓨터 하드웨어 사이의 인터페이스에 대한 정의 혹은 명세라고 볼 수 있습니다. 명령어 집합 구조는
  - 컴퓨터 하드웨어가 어떤 연산을 수행할 수 있고, 각 연산에 어떤 데이터가 필요한지를 명시합니다.
  - 사용할 수 있는 데이터의 표현 방식, 즉 `데이터 형식data type`을 명시합니다.
  - 데이터의 위치에 대한 정보를 알려주는 `주소 지정 방식addressing mode`을 명시합니다.

- 일반적으로 연산은 전송/처리/제어/입출력 연산으로 구분됩니다.
  - 전송 연산 : CPU 내의 레지스터와 메모리 사이에 데이터를 교환하는 적재 및 저장 연산입니다. `LDA`, `STA` 명령어가 이에 해당됩니다.
  - 처리 연산 : `산술 논리 장치 arithmetic logic unit(ALU)` 를 사용하여 데이터를 조작하는 연산입니다. 연산의 종류에 따라 일항/이항/삼항 연산자로 구분되며 `ADD`, `SUB`와 같은 명령어가 있습니다.
  - 제어 연산 : CPU의 제어장치가 프로그램의 실행 순서를 제어하는 연산입니다. 반복문/조건문/프로시저 등에서 명령을 비순차적으로 실행할 때 `무조건 분기 unconditional branch`, `조건 분기 conditional branch`, `프로시저 호출/복귀 cal proc/ret`, `인터럽트 interrupt` 을 활용하는 것을 예로 들 수 있습니다. `HLT`, `RET` 등의 명령어가 있습니다.
  - 입출력 연산 : CPU 내의 레지스터와 외부 장치 사이의 데이터 이동을 수행하는 연산입니다. 데이터를 전송하므로 전송 연산에 포함되기도 합니다.
  
- 대부분의 명령어는 3개의 피연산자 주소를 가지기 때문에 `3-주소 명령어`라고 합니다. `누산기 Accumulator(ACC)`를 사용하는 경우, 피연산자로 누산기를 명시할 필요가 없어서 근원지 피연산자 중의 하나만 명시하므로 `1-주소 명령어`가 됩니다. `스택stack`을 사용하는 명령어는 피연산자의 대한 위치를 명시할 필요가 없기 때문에 `0-주소 명령어`가 됩니다.
  - CPU 내부에 소규모 기억장치(누산기)를 포함한다면 폰노이만 병목에 발생하는 트래픽을 크게 감소시킬 수 있습니다. 반복적으로 사용되는 데이터를 위한 메모리 접근을 줄여주고, 명령어의 길이가 축소되어 명령어 인출을 위한 트래픽이 감소되기 때문입니다.

- CPU의 기본 구성은 다음과 같습니다.
  - `프로그램 계수기 Program counter(PC)`는 다음에 실행할 명령어의 주소를 보관하는 레지스터입니다. 명령어를 인출한 후에 명령어 길이만큼 값을 장가시켜 다음 명령어를 가리킵니다. 조건/무조건 분기 명령어를 통해 프로그램의 흐름을 변경할 수 있습니다.
  - `누산기 Accumulator(ACC)` 는 데이터를 일시적으로 보관하는 레지스터입니다.
  - `메모리 주소 레지스터memory address register(MAR)` 은 CPU가 메모리에 접근하기 위해 참조하려는 데이터의 주소를 버퍼를 말합니다.
  - `메모리 버퍼 레지스터memory buffer register(MBR)` 은 프로세서가 메모리로부터 읽거나 메모리에 저장할 데이터 자체를 보관하기 위한 버퍼를 말합니다. `메모리 데이터 레지스터memory data register(MDR)` 이라고도 합니다.
  - cpu가 메모리의 데이터를 읽는 것을 `적재load`, 메모리에 데이터를 기록하는 것을 `저장store` 라고 합니다. cpu가 데이터를 적재하거나 저장할 때는 MAR 과 MBR을 사용합니다.

- `프로시저procedure` 는 프로그래밍 언어 또는 사용 방법에 따라 `서브루틴subroutine`, `함수function`, `메소드method`, `서브프로그램subprogram` 으로 불리기도 합니다. 프로시저는 특정 작업을 하나의 패키지처럼 수행하기 위한 일련의 명령어를 의미하며, 이때 명령어를 모듈화하여 사용합니다. 특정 작업이 필요한 곳이라면 어디에서든지 몇 번이라도 호출할 수 있습니다.
  - 프로그램의 중복된 코드를 줄이며, `코드 재사용률code reuse`을 높입니다.
  - 프로그램 구현의 상세 내역을 숨겨줍니다. 이를 통해 구현 내역을 추상화 시킬 수 있습니다.
  - 명령어 그룹을 프로시저의 이름으로 나타내기 때문에 프로그램의 의미를 쉽게 파악할 수 있습니다.
  - 프로시저를 호출할 때 `cal proc (proc : 프로시저 이름)` 과 같은 명령어를 사용하며 이때 `스택의 최상위Top of stack(TOS)`에 `복귀 주소 return address`를 저장합니다. 그 후 프로시저의 명령어를 전부 수행하면 `ret` 명령어를 통해 프로시저를 호출한 프로그램으로 복귀시킵니다.


##### 파이프라인(Pipeline)
- 파이프라이닝은 명령어 처리 동작을 단계별로 나누고 이를 중첩적으로 수행함으로써 성능을 향상시키는 컴퓨터 기술입니다. 데이터 경로를 여러 단계로 분할하여 명령어가 수행할 작업을 병행 처리합니다.
- 해저드는 명령어나 데이터가 준비되지 않아서 파이프라인을 멈춰야 하거나 새로운 명령어를 파이프라인에 투입할 경우 잘못된 결과가 초래되는 모든 상황이나 조건을 뜻합니다.
- 파이프라이닝 기법에서는 다수의 명령어가 동시에 실행되기 때문에 임의의 단계에서 실행 중인 명령어가 다른 단계의 자원을 사용할 수 없습니다.
- 파이프라인이 이상적인 성능 향상을 도모하려면 무시할 수 있을 정도로 작은 래치 지연 시간, 충분한 데이터, 동일한 크기의 파이프라는 조건을 만족해야 하며, 명령어나 데이터 사이의 의존성에 의한 해저드가 없어야 합니다.

```diff
- 89p 명령어 집합

- 111p 프로시저의 호출과 복귀

+ 4장
+ 5장
+ 7장(사이클)
+ 9장
+ 10장
+ 11장
+ 12장
+ 14장
+ 15장

```
