# 데이터 중심 애플리케이션 설계

## 01장. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

<details>
<summary>fold/unfold</summary>

<img src="https://miro.medium.com/max/875/1*HdNA-aIwWx_5pI0ODo8nZA.png" width="40%" height="40%">

- 오늘날 많은 애플리케이션은 계산 중심(computer-intensive)과는 다르게 데이터 중심(data-intensive)적이다. 이러한 애플리케이션의 경우, CPU 성능은 애플리케이션을 제한하는 요소가 아니며, 더 큰 문제는 보통 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도다.
- 일반적으로 데이터 중심 애플리케이션은 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소(standard building block)로 만든다. 
  - 구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장(데이터베이스)
  - 읽기 속도 향상을 위해 값비싼 수행 결과를 기억(캐시)
  - 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공(검색 색인(search index))
  - 비동기 처리를 위해 다른 프로세스로 메세지 보내기(스트림 처리(stream processing))
  - 주기적으로 대량의 누적된 데이터를 분석(일괄 처리(batch processing))

<br>

이 책에서는 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사에 중점을 둔다.
- 신뢰성Reliability : 하드웨어나 소프트웨어 결함, 심지어 인적 오류(human error) 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야 한다.
- 확장성Scalability : 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 이쓴 적절한 방법이 있어야 한다.
- 유지보수성Maintainability : 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업(현재 작업을 유지보수하고 새로운 사용 사례를 시스템에 적용하는 엔지니어링과 운영)할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.

<br>

### 신뢰성
- 소프트웨어의 경우 일반적인 기대치는 다음과 같다.
  - 애플리케이션은 사용자가 기대한 기능을 수행한다.
  - 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.
  - 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
  - 시스템은 허가되지 않은 접근과 오남용을 방지한다.

<br>

- 잘못될 수 있는 일을 결함(fault)라 부른다. 그리고 결함을 예측하도 대처할 수 있는 시스템을 내결함성(fault-tolerant) 또는 탄력성(resilient)을 지녔다고 말한다.
- 결함은 장애(failure)와 동일하지 않다. 일반적으로 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의되지만, 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다.
  - 하드웨어 결함
  - 소프트웨어 오류
  - 인적 오류

### 확장성
- 시스템이 현재 안정적으로 동작한다고 해서 미래에도 안정적으로 동작한다는 보장은 없다. 성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가다. 어쩌면 시스템의 동시 사용자 수가 1만 명에서 10만 명 또는 100만 명에서, 1,000만 명으로 증가했을 수도 있다. 시스템은 전에 처리했던 양보다 더 많은 데이터를 처리하고 있을지도 모른다.
- 확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어지만 시스템에 부여하는 일차원적인 표식이 아님을 주의하자. "X는 확장 가능하다" 또는 "Y는 확장성이 없다" 같은 말은 의미가 없다. 오히려 확장성을 논한다는 것은 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?"와 "추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?" 같은 질문을 고려한다는 의미다.

<br>

부하 기술하기
- 시스템의 현재 부하를 간결하게 기술할 수 있어야 한다. 그래야 부하 성장 질문(부하가 두 배로 되면 어떻게 될까?)을 논의할 수 있다. 부하는 부하 매개변수(load parameter)라 부르는 몇 개의 숫자로 나타낼 수 있다. 가장 적합한 부하 매개변수 선택은 시스템 설계에 따라 달라진다. 부하 매개변수로 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자(active user), 캐시 적중률 등이 될 수 있다. 평균적인 경우가 중요할 수도 있고 소수의 극단적인 경우가 병목 현상의 원인일 수도 있다.
- ex) 트위터

<br>

성능 기술하기
- 일단 시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다. 다음 두 가지 방법으로 살펴볼 수 있다.
  - 부하 매개변수를 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
  - 부하 매개변수를 증가시켰을 대 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?

<br>

- 하둡(Hadoop)과 같은 일괄 처리 시스테은 보통 처리량(throughput)(초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간)에 관심을 가진다. 온라인 시스템에서 더 중요한 사항은 서비스 응답 시간(response time), 즉 클라이언트가 요청을 보내고 응답을 받는 사이의 시간이다.
- 지연 시간(latency)과 응답 시간(response time) : 지연 시간과 응답 시간을 종종 같은 뜻으로 사용하지만 동일하지는 않다. 응답 시간은 클라이언트 관점에서 본 시간으로, 요청을 처리하는 실제 시간(서비스 시간) 외에도 네트워크 지연과 큐 지연도 포함한다. 지연 시간은 요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 휴지(latent) 상태인 시간을 말한다.

<br>

실전 백분위
- 상위 백분위는 단일 최종 사용자 요청의 일부로서 여러 번 호출되는 백엔드 서비스에서 특히 중요하다. 병렬로 호출해도 최종 사용자 요청은 여전히 병렬 호출 중 가장 느린 호출이 완료되길 기다려야 한다. 작은 비율의 백엔드 호출만 느려도 최종 사용자 요청이 여러 번 백엔드를 호출하면 느린 호출이 발생할 가능성이 증가한다. 그래서 최종 사용자 요청 중 많은 비율의 응답 시간이 결국 느려진다. 이 효과를 꼬리 지연 증폭(tail latency amplification) 이라 한다.
- 서비스의 모니터링 대시보드에 응답 시간 백분위를 추가하려면 지속적으로 백분위를 효율적으로 계산할 필요가 있다. 예를 들어, 지난 10분간 요청의 응답 시간을 롤링 윈도(rolling window)로 유지하고 싶다면 1분마다 구간 내 중앙값과 다양한 백분위를 계산해 각 지표를 그래프에 그리면 된다.
- 단순한 구현으로 시간 구간 내 모든 요청의 응답 시간 목록을 유지하고 1분마다 목록을 정렬하는 방법이 있다. 이 구현이 너무 비효율적이라면 상황에 따라 포워드 디케이(forward decay), T 다이제스트(t-digest), Hdr히스토그램(HdrHistogram) 같은 CPU와 메모리 비용을 최소로 하면서 좋은 백분위 근사치를 계산할 수 있는 알고리즘이 있다. 백분위 평균(예를 들어, 시간 해상도를 줄이거나 여러 장비의 데이터를 결합하기)은 수학적으로 의미가 없으니 주의하자. 응답 시간 데이털르 집계하는 올바른 방법은 히스토그램을 추가하는 것이다.

</details>
