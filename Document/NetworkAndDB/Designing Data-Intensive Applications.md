# 데이터 중심 애플리케이션 설계

## 01장. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

<details>
<summary>fold/unfold</summary>

<img src="https://miro.medium.com/max/875/1*HdNA-aIwWx_5pI0ODo8nZA.png" width="40%" height="40%">

- 오늘날 많은 애플리케이션은 계산 중심(computer-intensive)과는 다르게 데이터 중심(data-intensive)적이다. 이러한 애플리케이션의 경우, CPU 성능은 애플리케이션을 제한하는 요소가 아니며, 더 큰 문제는 보통 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도다.
- 일반적으로 데이터 중심 애플리케이션은 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소(standard building block)로 만든다. 
  - 구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장(데이터베이스)
  - 읽기 속도 향상을 위해 값비싼 수행 결과를 기억(캐시)
  - 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공(검색 색인(search index))
  - 비동기 처리를 위해 다른 프로세스로 메세지 보내기(스트림 처리(stream processing))
  - 주기적으로 대량의 누적된 데이터를 분석(일괄 처리(batch processing))

<br>

이 책에서는 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사에 중점을 둔다.
- 신뢰성Reliability : 하드웨어나 소프트웨어 결함, 심지어 인적 오류(human error) 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야 한다.
- 확장성Scalability : 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 이쓴 적절한 방법이 있어야 한다.
- 유지보수성Maintainability : 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업(현재 작업을 유지보수하고 새로운 사용 사례를 시스템에 적용하는 엔지니어링과 운영)할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.

<br>

### 신뢰성
- 소프트웨어의 경우 일반적인 기대치는 다음과 같다.
  - 애플리케이션은 사용자가 기대한 기능을 수행한다.
  - 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.
  - 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
  - 시스템은 허가되지 않은 접근과 오남용을 방지한다.

<br>

- 잘못될 수 있는 일을 결함(fault)라 부른다. 그리고 결함을 예측하도 대처할 수 있는 시스템을 내결함성(fault-tolerant) 또는 탄력성(resilient)을 지녔다고 말한다.
- 결함은 장애(failure)와 동일하지 않다. 일반적으로 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의되지만, 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다.
  - 하드웨어 결함
  - 소프트웨어 오류
  - 인적 오류

### 확장성
- 시스템이 현재 안정적으로 동작한다고 해서 미래에도 안정적으로 동작한다는 보장은 없다. 성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가다. 어쩌면 시스템의 동시 사용자 수가 1만 명에서 10만 명 또는 100만 명에서, 1,000만 명으로 증가했을 수도 있다. 시스템은 전에 처리했던 양보다 더 많은 데이터를 처리하고 있을지도 모른다.
- 확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어지만 시스템에 부여하는 일차원적인 표식이 아님을 주의하자. "X는 확장 가능하다" 또는 "Y는 확장성이 없다" 같은 말은 의미가 없다. 오히려 확장성을 논한다는 것은 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?"와 "추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?" 같은 질문을 고려한다는 의미다.

<br>

부하 기술하기
- 시스템의 현재 부하를 간결하게 기술할 수 있어야 한다. 그래야 부하 성장 질문(부하가 두 배로 되면 어떻게 될까?)을 논의할 수 있다. 부하는 부하 매개변수(load parameter)라 부르는 몇 개의 숫자로 나타낼 수 있다. 가장 적합한 부하 매개변수 선택은 시스템 설계에 따라 달라진다. 부하 매개변수로 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자(active user), 캐시 적중률 등이 될 수 있다. 평균적인 경우가 중요할 수도 있고 소수의 극단적인 경우가 병목 현상의 원인일 수도 있다.
- ex) 트위터

<br>

성능 기술하기
- 일단 시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다. 다음 두 가지 방법으로 살펴볼 수 있다.
  - 부하 매개변수를 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
  - 부하 매개변수를 증가시켰을 대 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?

<br>

- 하둡(Hadoop)과 같은 일괄 처리 시스테은 보통 처리량(throughput)(초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간)에 관심을 가진다. 온라인 시스템에서 더 중요한 사항은 서비스 응답 시간(response time), 즉 클라이언트가 요청을 보내고 응답을 받는 사이의 시간이다.
- 지연 시간(latency)과 응답 시간(response time) : 지연 시간과 응답 시간을 종종 같은 뜻으로 사용하지만 동일하지는 않다. 응답 시간은 클라이언트 관점에서 본 시간으로, 요청을 처리하는 실제 시간(서비스 시간) 외에도 네트워크 지연과 큐 지연도 포함한다. 지연 시간은 요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 휴지(latent) 상태인 시간을 말한다.

<br>

실전 백분위
- 상위 백분위는 단일 최종 사용자 요청의 일부로서 여러 번 호출되는 백엔드 서비스에서 특히 중요하다. 병렬로 호출해도 최종 사용자 요청은 여전히 병렬 호출 중 가장 느린 호출이 완료되길 기다려야 한다. 작은 비율의 백엔드 호출만 느려도 최종 사용자 요청이 여러 번 백엔드를 호출하면 느린 호출이 발생할 가능성이 증가한다. 그래서 최종 사용자 요청 중 많은 비율의 응답 시간이 결국 느려진다. 이 효과를 꼬리 지연 증폭(tail latency amplification) 이라 한다.
- 서비스의 모니터링 대시보드에 응답 시간 백분위를 추가하려면 지속적으로 백분위를 효율적으로 계산할 필요가 있다. 예를 들어, 지난 10분간 요청의 응답 시간을 롤링 윈도(rolling window)로 유지하고 싶다면 1분마다 구간 내 중앙값과 다양한 백분위를 계산해 각 지표를 그래프에 그리면 된다.
- 단순한 구현으로 시간 구간 내 모든 요청의 응답 시간 목록을 유지하고 1분마다 목록을 정렬하는 방법이 있다. 이 구현이 너무 비효율적이라면 상황에 따라 포워드 디케이(forward decay), T 다이제스트(t-digest), Hdr히스토그램(HdrHistogram) 같은 CPU와 메모리 비용을 최소로 하면서 좋은 백분위 근사치를 계산할 수 있는 알고리즘이 있다. 백분위 평균(예를 들어, 시간 해상도를 줄이거나 여러 장비의 데이터를 결합하기)은 수학적으로 의미가 없으니 주의하자. 응답 시간 데이털르 집계하는 올바른 방법은 히스토그램을 추가하는 것이다.


<br>

부하 대응 접근 방식
- 사람들은 확장성과 관련해 용량 확장(scaling up)(수직 확장(vertical scaling), 좀 더 강력한 장비로 이동)과 규모 확장(scaling out)(수평 확장(horizontal scaling), 다수의 낮은 사양 장비에 부하를 분산)으로 구분해서 말하곤한다. 다수의 장비에 부하를 분산하는 아키텍처를 비공유(shared-nothing) 아키텍처라 부른다.
- 대개 대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 애플리케이션에 특화돼 있다. 범용적이고 모든 상황에 맞는(one-size-fits-all) 확장 아키텍처(비공식적으로 마법의 확장 소스(magic scaling source)라 부른다)는 없다. 아키텍처를 결정하는 요소는 읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴 등이 있다. 혹은 (대개) 이 요소 중 일부 조합에 더 많은 문제가 추가된 경우도 있다.
- 예를 들어 각 크기가 1KB 인 chekd 100,000 건의 요청을 처리하도록 설계한 시스템과 각 크기가 2GB인 분당 3건의 요청을 처리하기 위해 설계한 시스템은 서로 같은 데이터 처리량이라 해도 매우 다르다.

<br>

유지보수성
- 소프트웨어 비용의 대부분은 초기 개발이 아니라 지속해서 이어지는 유지보수에 들어간다는 사실은 잘 알려져 있다.
- 이런 유지보수에는 버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적응, 새 사용 사례를 위한 변경, 기술 채무(technical debt) 상환, 새로운 기능 추가 등이 있다.

<br>

- 레거시 시스템 유지보수를 피하기 위한 소프트웨어 설계 원칙은 다음 세 가지가 있다.
  - 운용성(operability) : 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라.
  - 단순성(simplicity) : 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라(사용자 인터페이스의 단순성과는 다르다는 점에 유의하라)
  - 발전성(evolvability) : 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라. 그래야 요구사항 변경 같은 예기치 않은 사용 사례를 적용하기가 쉽다. 이 속성은 유연성(extensibility), 수정 가능성(modifiability), 적응성(plasticity)으로 알려져 있다.

<br>

운용성 : 운영의 편리함 만들기
- 시스템이 지속해서 원활하게 작동하려면 운영팀이 필수다. 좋은 운영팀은 일반적으로 다음과 같은 작업 등을 책임진다.
  - 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원
  - 시스템 장애, 성능 저하 등의 문제의 원인을 추적
  - 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
  - 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
  - 미래에 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결(예를 들어 용량 계획)
  - 배포, 설정 관리 등을 위한 모범 사례와 도구를 마련
  - 애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복잡한 유지보수 태스클르 수행
  - 설정 변경으로 생기는 시스템 보안 유지보수
  - 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의
  - 개인 인사 이동에도 시스템에 대한 조직의 지식을 보존함
- 좋은 운영성이란 동일하게 반복된느 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미다. 데이터 시스템은 동일 반복 태스크를 쉽게 하기 위해 아래 항목 등을 포함해 다양한 일을 할 수 있다.
  - 좋은 모니터링으로 런타임(runtime) 동작과 시스템의 내부에 대한 가시성 제공
  - 표준 도구를 이요해 자동화와 통합을 위한 우수한 자원을 제공
  - 개별 장비 의존성을 회피, 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고, 계속해서 운영 가능해야 함
  - 좋은 문서와 이해하기 쉬운 운영 모델(예를 들어 "X를 하면 Y가 발생한다") 제공
  - 만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여
  - 적절하게 자기 회복(self-healing)이 가능할 뿐 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함
  - 예측 가능하게 동작하고 예기치 않은 상황을 최소화함

<br>

단순성 : 복잡도 관리
- 복잡도는 같은 시스템에서 작업해야 하는 모든 사람의 진행을 느리게 하고 나아가 유지보수 비용이 증가한다. 복잡도는 다양한 증상으로 나타난다. 상태 공간의 급증, 모듈 간 강한 커플링(tight coupling), 복잡한 의존성, 일관성 없는 명명(naming)과 용어, 성능 문제 해결을 목표로 한 해킹, 임시방편으로 문제를 해결한 특수 사례(special-casing) 등이 이런 증상이다.
- 우발적 복잡도를 제거하기 위한 최상의 도구는 추상화다. 좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다. 예를 들어, 고수준 프로그래밍 언어는 기계 언어, CPU 레지스터, 시스템 호출을 숨긴 추상화다. 

<br>

발전성 : 변화를 쉽게 만들기
- 조직 프로세스 측면에서 애자일(agile) 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공한다. 또하 애자일 커뮤니티는 테스트 주도 개발(test-driven development(TDD)) 과 리팩토링(refactoring) 같이 자주 변화하는 환경에서 소프트웨어를 개발할 때 도움이 되는 기술 도구와 패턴을 개발하고 있다.

</details>

## 02장. 데이터 모델과 질의 언어

<details>
<summary>fold/unfold</summary>

대부분의 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위의 계층을 둬서 만든다. 각 계층의 핵심적인 문제는 다음 하위 계층 관점에서 데이터 모델을 표현하는 방법이다.
- 애플리케이션 개발자는 현실(사람, 조직, 상품, 행동, 자금 흐름, 센서 등)을 보고 객체나 데이터 구조, 그리고 이러한 데이터 구조를 다루는 API를 모델링한다. 이런 구조는 보통 애플리케이션에 특화돼 있다.
- 데이터 구조를 저장할 때는 JSON 이나 XML 문서, 관계형 데이터베이스 테이블이나 그래프 모델 같은 범용 데이터 모델로 표현한다.
- 데이터베이스 소프트웨어를 개발하는 엔지니어는 JSON/XML/관계형/그래프 데이터를 메모리나 디스크 또는 네트워크 상의 바이트 단위로 표현하는 방법을 결정한다. 이 표현은 다양한 방법으로 데이터의 질의, 탐색, 조작, 처리할 수 있게 된다.
- 더 낮은 수준에서 하드웨어 엔지니어는 전류, 빛의 파동, 자기장 등의 관점에서 바이트를 표현하는 방법을 알아냈다.

<br>

### 관계형 모델과 문서 모델
- 오늘날 잘 알려진 데이터 모델은 1970년 에드가 코드(Edgar Codd)가 제안한 관계형 모델을 기반으로 한 SQL이다. 데이터는 (SQL에서는 테이블이라 불리는) 관계(relation)로 구성되고 각 관계는 순서 없는 튜플(tuple) (SQL에서 로우(row)) 모음이다.

<br>

### NoSQL의 탄생
- 현재 2010년대의 NoSQL은 관계형 모델의 우위를 뒤집으려는 가장 최신 시도다. "NoSQL"이라는 이름은 실제 어떤 특정 기술을 참고한 것이 이나기에 적절하지 않다. 원래 NoSQL 은 2009년에 오픈소스, 분산환경, 비관계형 데이터베이스 밋업(meetup)용 인기 트위터 해시태그였다. NoSQL은 거슬러 올라가 Not Only SQL로 재해석됐다.
- NoSQL 데이터베이스를 채택한 데는 다음과 같은 원동력이 있다.
  - 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요
  - 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
  - 관계형 모델에서 지원하지 않는 특수 질의 동작
  - 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람

<br>

### 객체 관계형 불일치
- 오늘날 대부분의 애플리케이션은 객체지향 프로그래밍 언어로 개발한다. 이는 SQL 데이터 모델을 향한 공통된 비판을 불러온다. 데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터 베이스 모델 객체(테이블, 로우, 칼럼) 사이에 거추장스러운 전환 계층이 필요하다. 이런 모델 사이의 분리를 종종 임피던스 불일치(impedance mismatch)라고 부른다.
  - 임피던스란 전자공학에서 빌려온 용어이다. 모든 저기 회로는 입력과 출력에 일정한 임피던스(교류에 대한 저항)를 갖고 있다. 한 회로의 출력을 또 다른 회로의 입력으로 연결했을 때 두 회로의 출력과 입력 임피던스가 일치하면 연결을 통한 전력 전달은 최대가 된다. 임피던스가 불일치하면 신호 반사 및 여러 문제를 겪을 수 있다.
- 관계형 스키마에서 이력서를 어떻게 표현하는지 예를 들어볼 때, 대부분의 사람들은 경력에 입력할 수 있는 값이 하나 이상일 것이다. 이때 사용자와 이들 항목은 일대다(one-to-many) 관계다. 이 관계를 나타낼 때는
  - 전통적인 SQL 모델(SQL:1999 이전)에서 가장 일반적인 정규화 표현은 직위, 학력, 연락처 정보를 개별 테이블에 넣고 외래 키롤 지원자 테이블을 참조하는 방식이다.
  - SQL 표준의 마지막 버전에서 구조화된 데이터 타입(datatype) 과 XML 데이터에 대한 지원을 추가했다. 이 지원으로 단일 로우에 다중 값을 저장할 수 있고 문서 내 질의와 색인이 가능해졌다. 이런 기능은 오라클, IBM DB2, 마이크로소프트 SQL 서버, 포스트 그레스큐엘(PostgreSQL) 같은 데이터베이스마다 제각각 다양한 형태로 지원한다. 
    - JSON은 XML 보다 훨씬 더 간단해 매력적이다. 몽고DB(MongoDB), 리싱크DB(RethinkDB), 카우치DB(CouchDB)와 에스프레소(Espresso) 같은 문서 지향(document-oriented) 데이터베이스는 JSON 데이터 모델을 지원한다.
  - 세 번째 방법으로 직업, 학력, 연락처 정보를 JSON이나 XML 문서로 부호화해 데이터베이스의 텍스트 칼럼에 저장한 다음 애플리케이션이 구조와 내용을 해석하게 하는 방식이다. 이 방식을 쓰면 일반적으로 부호화된 칼럼의 값을 질의하는 데 데이터베이스를 사용할 수 없다.

<br>

- JSON 표현은 다중 테이블(multi-table) 스키마보다 더 나은 지역성(locality)을 갖는다. 관계형 예제에서 프로필을 가져오려면 다중 질의(각 테이블에 user_id로 질의)를 수행하거나 users 테이블과 그 하위 테이블 간에 난잡한 다중 조인을 수행해야 한다. JSON 표현에서는 모든 관련 정보가 한 곳에 있어 질의 하나로 충분하다.

<br>

### 다대일과 다대다 관계

</details>
