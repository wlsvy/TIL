# Refactoring

마틴 파울러 지음

![](RefactoringImage/2022-03-10-21-24-54.png)

## 서문

이 책은 전문 프로그래머를 대상으로 쓴 리팩터링 지침서다. 절제되고 효율적인 방식으로 리팩터링하는 법을 알려주는 것이 목표다. 코드에 버그가 생기지 않게 하면서 구조를 더 체계적으로 바꾸는 식으로 리팩터링하는 방법을 설명한다.

## 1장 리팩터링 : 첫번째 예시

**Before**

![](RefactoringImage/2022-03-10-22-43-58.png)
![](RefactoringImage/2022-03-10-22-45-02.png)

아래의 과정을 거쳐서

- statement() 함수 쪼개기
  - 적립 포인트 계산 코드 추출하기
  - format 변수 제거하기
- 계산 단계와 포맷팅 단계 분리하기


**중간점검**

처음보다 코드량이 부쩍 늘었다. 원래 44줄짜리 코드가 지금은 htmlStatement() 를 빼고도 70줄이나 된다. 늘어난 주된 원인은 함수로 추출하면서 함수 본문을 열고 닫는 괄호가 덧붙었기 때문이다. 그 외에 달라진 점이 없다면 안 좋은 징조지만, 다행히 그렇지는 않다. 추가된 코드 덕분에 전체 로직을 구성하는 요소 각각이 더 뚜렷이 부각되고, 계산하는 부분과 출력 형식을 다루는 부분이 분리됐다. 이렇게 무듈화하면 각 부분이 하는 일과 그 부분들이 맞물려 돌아가는 과정을 파악하기 쉬워진다. 모듈화된 덕분에 계산 코드를 중복하지 않고도 HTML 버전을 만들 수 있었다.

![](RefactoringImage/2022-03-10-22-46-05.png)
![](RefactoringImage/2022-03-10-22-46-21.png)
![](RefactoringImage/2022-03-10-22-46-31.png)


다시 아래의 과정을 거쳐서

- 다형성을 활용해 계산 코드 재구성하기
  - 조건부 로직을 다형성으로 바꾸기
  - 공연료 계산기 만들기
  - 함수들을 계산기로 옮기기
  - 공연료 계산기를 다형성 버전으로 만들기

![](RefactoringImage/2022-03-12-14-34-57.png)
![](RefactoringImage/2022-03-12-14-35-30.png)
![](RefactoringImage/2022-03-12-14-36-04.png)

앞에서 함수를 추출했을 때처럼, 이번에도 구조를 보강하면서 코드가 늘어났다. 이번 수정으로 나아진 점은 연극 장르별 계산 코드들을 함께 묶어뒀다는 것이다. 앞으로의 수정 대부분이 이 코드에서 이뤄질 것 같다면 이렇게 명확하게 분리해두면 좋다. 이제 새로운 장르를 추가하려면 해당 장르의 서브클래스를 작성하고 생성 함수인 createPerformanceCalculator()에 추가하기만 하면 된다.

이번 예를 보면 서브클래스를 언제 사용하면 좋은지 감이 잡힐 것이다. 여기서는 두 개의 함수 amountFor()와 volumeCreditsFor()의 조건부 로직을 생성 함수 하나로 옮겼다. 같은 타입의 다형성을 기반으로 실행되는 함수가 많을수록 이렇게 구성하는 쪽이 유리히다.

계산기가 중간 데이터 구조를 채우게 한 지금의 코드와 달리 createStatementData()가 계산기 자체를 변환하게 구현해도 된다. 이때 자바스크립트 클래스 시스템의 멋진 점 하나가 효과를 발휘하는데, 바로 게터getter 메서드를 호출하는 코드와 일반적인 데이터 접근 코드의 모양이 똑같다는 것이다.(앞의 예제에 calculator.amount 코드는 계산기 클래스의 게텅니 amount()를 호출한 것이다). 한편 계산기 인스턴스를 반환하는 방식과 각각의 출력 값으로 직접 계산하는 방식 중 하나를 선택할 때 나는 결과로 나온 데이터 구조를 누가 사용하는가를 기준으로 결정한다. 이번 예에서는 다형성 계산시를 사용한다는 사실을 숨기기보다는 중간 데이터 구조를 이용하는 방법을 보여주는 편이 낫다고 생각해서 이렇게 작성했다.

**1장 끝**

- 이번 장에서는 리팩터링을 크게 세 단계로 진행했다. 먼저 원본 함수를 중첩 함수 여러 개로 나눴다. 다음으로 단계 쪼개기를 적용해서 계산 코드와 출력 코드를 분리했다. 마지막으로 계산로직을 다형성으로 표현했다. 각 단계에서 코드 구조를 보강했고, 그럴 때마다 코드가 수행하는 일이 더욱 분명하게 드러났다.
- 리팩터링을 대부분 코드가 하는 일을 파악하는 데서 시작한다. 그래서 코드를 읽고, 개선점을 찾고, 리팩터링 작업을 통해 개선점을 코드에 반영하는 식으로 진행한다. 그 결과 코드가 명확해지고 이해하기 더 쉬워진다. 그러면 또 다른 개선점이 떠오르며 선순환이 형성된다. 지금까지 수정한 코드에도 개선할 게 몇 가지 더 있지만, 이 정도면 원본 코드를 크게 개선한다는 목표는 충분히 달성했다고 생각한다.
- **좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.**

## 2장 : 리팩터링 원칙

수많은 다른 소프트웨어 개발 용어와 마찬가지로 '리팩터링refactoring'도 엔지니어들 사이에서 다소 두리뭉실한 의미로 통용된다. 하지만 나는 이 용어를 더 구체적인 의미로 사용하며, 그렇게 엄격하게 정의해야 더 유용하다고 생각한다.(참고로 이 책 초판에서의 정의 그대로다). '리팩터링'이란 용어는 명사로도 쓸 수 있고, 동사로도 쓸 수 있다. 먼저 명사로 쓸 때는 다음과 같이 정의한다.

- 리팩터링 : '[명사]' 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

앞 장에서 본 '함수 추출하기'와 '조건부 로직을 다형성으로 바꾸기'처럼 이름 붙은 리팩터링 기법들이 이 정의에 해당한다.

동사 버전의 정의는 다음과 같다

- 리팩터링(하다) : '[동사]' 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

예를 들어 두 버전의 용어를 한 문장에 담으면 '앞으로 몇 시간은 리팩터링할 것 같은데 그 사이 적용하는 리팩터링은 수십 가지나 될 것 같다'처럼 표현할 수 있다.

지금껏 수많은 사람이 코드를 정리하는 작업을 모조리 '리팩터링'이라고 표현하고 있는데, 앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다. 리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 아리한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계 여러 개가 합쳐진 모습일 수도 있다. 따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

- 누군가 '리팩터링하다가 코드가 깨져서 며칠이나 고생했다'라고 한다면, 십중팔구 리팩터링한 것이 아니다.

나는 코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 '재구성restructuring'이라는 포괄적인 용어로 표현하고, 리팩터링은 재구성 중 특수한 한 형태로 본다. 한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하면 리팩터링하는 것이 오히려 비효율적이라고 생각하기 쉽다. 하지만 이렇게 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다. 단계들이 체계적으로 구성되어 있기도 하고, 무엇보다 디버깅하는 데 시간을 뺏기지 않기 때문이다.

### 두 개의 모자

나는 소프트웨어를 개발할 때 목적이 '기능 추가'냐, 아니면 '리팩터링'이냐를 명확히 구분해 작업한다. 켄트 백은 이를 두 개의 모자two hats에 비유했다. 기능을 추가할 때는 '기능 추가' 모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 반면 '리팩터링' 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다. (앞 과정에서 놓친 테스트 케이스를 발견하지 않는 한) 테스트도 새로 만들지 않는다. 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다.

### 리팩터링하는 이유

**리팩터링하면 소프트웨어 설계가 좋아진다.**

- 리팩터링하지 않으면 소프트웨어 내부 설계(아키텍처)가 썩기 쉽다. 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 그러면 코드만 봐서는 설계를 파악하기 어려워진다. 코드 구조가 무너지기 시작하면 악효과가 누적된다. 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다. 반면 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.

**리팩터링하면 버그를 쉽게 찾을 수 있다.**

**리팩터링하면 프로그래밍 속도를 높일 수 있다.**

### 언제 리팩터링해야 할까?

3의 법칙

- 이건 돈 로버츠Don Roberts가 내게 제시한 가이드다.

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽지만), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

야구를 좋아하는 사람은 '스트라이크 세 번이면 리팩터링하라(삼진 리팩터링)'로 기억하자.

**준비를 위한 리팩터링 : 기능을 쉽게 추가하게 만들기**

- 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.

**이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**

- 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다. 그 코드를 작성한 사람은 자신일 수도 있고 다른 사람일 수도 있다. 나는 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다. 조건부 로직의 구조가 이상하지 않은지 살펴보기도 하고, 함수 이름을 잘못 정해서 하는 일을 파악하는 데 시간이 오래 걸리지는 않는지도 살펴본다.

**쓰레기 줍기 리팩터링**

- 코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다. 로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다. 이때 약간 절충을 해야 한다. 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗기긴 싫을 것이다. 그렇다고 쓰레기가 나뒹굴게 방치해서 나중에 일을 방해하도록 내버려두는 것도 좋지 않다. 나라면 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다. 이것이 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링litter-pickup refactoring 이다.

**계획된 리팩터링과 수시로 하는 리팩터링**

- ...
- 버전 관리 시스템에서 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 조언을 들은 적이 있다. 이렇게 할 때의 큰 장점은 두 가지 활동을 구분해서 별개로 검토하고 승인할 수 있다는 것이다. 하지만 나는 이 견해에 완전히 동의하지는 않는다. 리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있다. 또한 해당 리팩터링을 하게 된 맥락 정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워진다. 리팩터링 커밋을 분리한다고 해서 무조건 좋은 게 아님을 명시하고, 여러분의 팀에 적합한 방식을 실험을 통해 찾아내야 한다.

**오래 걸리는 리팩터링**

- 리팩터링은 대부분 몇 분 안에 끝난다. 길어야 몇 시간 정도다. 하지만 팀 전체가 달려들어도 몇 주가 걸리는 대규모 리팩터링도 있다. 라이브러리를 새 것으로 교체하는 작업일 수도 있고, 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼내는 작업일 수도 있다. 또는 그동안 작업 하면서 쌓여온 골치 아픈 의존성을 정리하는 작업일 수도 있다.
- 나는 이런 상황에 처하더라도 팀 전체가 리팩터링에 매달리는 데는 회의적이다. 그보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다. 누구든지 리팩터링해야 할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식이다. 리팩터링이 코드를 깨뜨리지 않는다는 장점을 활용하는 것이다. 일부를 변경해도 모든 기능이 항상 올바르게 동작한다. 예컨대 라이브러리를 교체할 때는 기존 것과 새 것 모두 포용하는 추상 인터페이스부터 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다.(이 전략을 추상화로 갈아타기Branch By Abstraction라 한다.)