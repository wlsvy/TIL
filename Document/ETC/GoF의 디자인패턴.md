# GoF의 디자인 패턴

![](Image/2022-02-03-10-29-05.png)

## 요약

**생성 패턴(Creational Patterns)**

- 추상 팩토리(Abstract Factory) : 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴입니다.
- 빌더(Builder) : 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴입니다.
- 팩토리 메서드(Factory Method) : 객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브클래스 쪽에서 내리는 패턴입니다. 팩토리 메서드 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브클래스로 미룹니다.
- 원형(Prototype) : 생성할 객체의 종류를 명세하는 데에 원형이 되는 예시물을 이용하고, 그 원형을 복사함으로써 새로운 객체를 생성하는 패턴입니다.
- 단일체(Singleton) : 어떤 클래스의 인스턴스는 오직 하나임을 보장하며, 이 인스턴스에 접근할 수 있는 전역적인 접촉점을 제공하는 패턴입니다.

**구조 패턴(Structural Patterns)**

- 적응자(Adapter) : 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해 줍니다.
- 가교(Bridge) : 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴입니다.
- 복합체(Composite) : 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 합니다.
- 장식자(Decorator) : 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있습니다.
- 파사드(Facade) : 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴으로, 서브시스템을 좀더 사용하기 편하게 만드는 상위 수준의 인터페이스를 정의합니다.
- 플라이급(Flyweight) : 크기가 작은 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴입니다.
- 프록시(Proxy) : 어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자(surrogate) 또는 자리 채움자(placeholder)를 제공하는 패턴입니다.

**행동 패턴(Behavioral Patterns)**

- 책임 연쇄(Chain of Responsibility) : 요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여하여 요청을 보내는 객체와 그 요청을 받는 객체 사이의 결합을 피하는 패턴입니다. 요청을 받을 수 있는 객체를 연쇄적으로 묶고, 실제 요청을 처리할 객체를 만날 때까지 객체 고리를 따라서 요청을 전달합니다.
- 명령(Command) : 요청을 객체의 형태로 캡슐화하여 서로 요청이 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 그리고 연산의 취소를 지원하게 만드는 패터입니다.
- 해석자(Interpreter) : 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 이와 아울러 그 표현 수단을 사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴입니다.
- 반복자(Iterator) : 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴입니다.
- 중재자(Mediator) : 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체를 정하는 패턴입니다. 객체들이 직접 서로를 참조하지 않도록 함으로써 객체들 사이의 소결합(loose coupling)을 촉진시키며, 개발자가 객체들의 상호작용을 독립적으로 다양화시킬 수 있게 만듭니다.
- 메멘토(Memento) : 캡슐화를 위배하지 않은 채로 어떤 객체의 내부 상태를 잡아내고 실체화시켜, 이후에 해당 객체가 그 상태로 되돌아올 수 있도록 하는 패턴입니다.
- 감시자(Observer) : 객체들 사이에 일 대 다의 의존관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그  객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴입니다.
- 상태(State) : 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼 보입니다.
- 전략(Strategy) : 동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하며, 이들을 상호 교환이 가능하도록 만드는 패턴입니다. 알고리즘을 사용하는 사용자와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 합니다.
- 템플릿 메서드(Template Method) : 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미루는 패턴입니다. 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단게의 처리를 서브클래스에서 재정의할 수 있게 합니다.
- 방문자(Visitor) : 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 합니다.

## Chapter 1 서론

- 이 책에서 이야기하는 디자인 패턴은 "**특정한 전후 관계에서 일반적 설계 문제를 해결하기 위해 상호교류하는 수정 가능한 객체와 클래스들에 대한 설명**" 입니다.
  - 하나의 디자인 패턴은 재사용 가능한 객체지향 설계를 만들기 위해 유용한 공통의 설계 구조에서 주요 요소들을 식별하여 이들에게 적당한 이름을 주고 추상화합니다. 그리고 패턴에 참여하는 클래스와 그들의 인스턴스를 식별하여 역할과 그들 간의 협력 관계를 정의하고 책임을 할당합니다. 각 디자인 패턴은 각자 맡은 객체지향 설계 문제에 집중합니다. 언제 패턴을 적용할지, 다른 설계 제약을 고려하여 패턴을 적용할 수 있는지, 패턴을 사용하면 어떤 결과가 발생하는지도 친절히 설명합니다.

<br>

- 초보자들은 너무 많은 개념과 이를 실행할 수 있는 다양한 방법론에 당황해서, 자신들이 전에 사용했던 객체지향 기술이 아닌 쪽으로 다시 되돌아갈 수 있습니다. 초보자들은 "좋은 객체지향 설계란 무엇일까요?"를 이해하는 데만도 꽤 오랜 시간이 걸립니다.
- 전문가들은 초보자들처럼 모든 문제를 처음 기초 단계에서부터 해결하려고 하지 않습니다. 대신, 전에 사용했던 해결책을 다시 사용해 봅니다. 그리고 좋은 방법을 찾아냈다면 그 방법을 반복해서 계속 사용하게 됩니다. 이런 경험을 통해 전문가가 만들어지고, 결국에는 많은 객체지향 시슽메에서 클래스 패턴이나 객체들 간의 상호작용 방식이 반복됨을 알게 됩니다. 이런 반복된 패턴들은 특정 설계의 문제점들을 해결해 주고, 좀더 근사하며, 재사용 가능한 객체지향 소프트웨어를 만들어 줍니다.
- 디자인 패턴을 이용하면 좋은 설계나 아키텍처를 재사용하기 쉬워집니다. 입증된 기술을 디자인 패턴으로 표현해 두면 새로운 시스템 개발자들은 디자인 패턴을 더 자주 유용하게 사용할 수 있습니다. 디자인 패턴은 설계자로 하여금 재사용이 가능한 설계는 선택하고, 재사용을 방해하는 설계는 배제하도록 도와줍니다. 또한 패턴을 쓰면 이미 만든 시스템의 유지보수나 문서화도 개선할 수 있고, 클래스의 명세도 정확하게 할 수 있으며, 객체 간의 상호작용 또는 설계의 의도 등까지 명확하게 정의할 수 있습니다. 간단하게 말해서, 디자인 패턴은 설계자들이 "올바른" 설계를 빨리 만들 수 있도록 도와줍니다.

- 일반적으로 하나의 패턴에는 다음의 네 가지 요소가 반드시 들어 있습니다.
  - 패턴 이름(pattern name)
  - 문제(problem)
  - 해법(solution)
  - 결과(consequence)

**런타임 및 컵파일 타임의 구조를 관계짓기**

- 객체 관계 중에는 집합(aggregation)과 인지(acquaintance)라는 것이 있습니다. 집합은 한 객체가 다른 객체를 소유하거나 그것에 책임을 진다는 뜻입니다. 보통 우리는 한 객체가 다른 객체를 포함(having)한다거나 다른 객체의 부분(part of)이라고 말합니다. 객체 통합에는 통합된 객체 및 그 객체를 소유한 객체의 생존주기가 똑같다는 의미도 들어 있습니다.
- 객체 인지는 한 객체가 다른 객체에 대해 알고 있음(knows of)을 의미합니다. 이를 "연관(association)" 관계 또는 "사용(using)" 관계라고도 합니다. 인지를 받는 객체는 서로의 연산을 요청할 수도 있지만 서로에 대해 책임은 지지 않습니다. 인지 통합 관계보다 관련성이 약해서 객체들 사이의 결합도가 약합니다.
  - 인지 관계와 집합 관계는 언어의 처리 방식이 아닌 사용 목적에 따라 결정해야 합니다. 이러한 차이를 컴파일 시점에 발견하기는 함들지만 중요한 의미를 갖습니다. 집합 관계는 인지 관계보다 강력한 영속성의 개념을 갖습니다. 즉, 자전거에 바퀴가 있어야 한다는 것은 불변의 영속적 사실입니다. 이에 반해, 인지 관계는 자주 바뀌게 됩니다. 즉, 사람과 회사 관계는 근무한다는 관련성이 있을 수도 있고 없어질 수도 있습니다. 인지 관계가 더 동적이라는 의미입니다. 소스 코드에서 그것을 쉽게 식별하기 어려운 것도 이 때문입니다.

**변화에 대비한 설계**

- 재사용을 최대화하기 위해서는 새로운 요구 사항과 기존 요구 사항에 발생한 변경을 예측하여 앞으로의 시스템 설계가 진화할 수 있도록 해야 합니다. 변화를 수용하지 못하는 설계는 앞으로 재설계가 필요하게 됩니다. 이런 변경들은 클래스의 재설계와 재구현, 사용자의 수정, 새로운 테스팅을 유발하는데, 재설계의 영향은 소프트웨어의 여러 부분에서 나타날 수 있으며 예측하지 못한 변경에 대해서는 엄청나게 비싼 대가를 지불할 수밖에 없습니다.

디자인 패턴은 어떤 구체적인 원인으로 앞으로 시스템을 변경해야 한다는 것을 미리 보여줌으로써 이런 위험을 줄여줍니다. 디자인 패턴은 다른 부분에 독립적으로 시스템 구조를 변경할 수 있게 해주어, 시스템이 어떤 특정 변화에 순응할 수 있도록 합니다.

1. 특정 클래스에서 객체 생성 : 객체를 생성할 때 클래스 이름을 명시하면 어떤 특정 인터페이스가 아닌 어떤 특정 구현에 종속됩니다. 이런 종속은 앞으로의 변화를 수용하지 못합니다. 이를 방지하려면 객체를 직접 생성해서는 안 됩니다.(디자인 패턴 : 추상 팩토리, 팩토리 메서드, 원형)
2. 특정 연산에 대한 의존성 : 특정한 연산을 사용하면, 요청을 만족하는 한 가지 방법에만 매이게 됩니다. 요청의 처리 방법을 직접 코딩하는 방식을 피하면, 컴파일 시점가 런타임 모두를 만족하면서 요청 처리 방법을 쉽게 변경할 수 있습니다.(디자인 패턴 : 책임 연쇄, 명령)
3. 하드웨어와 소프트웨어 플랫폼에 대한 의존성 : 기존에 존재하는 시스템 인터페이스와 응용프로그램 프로그래밍 인터페이스는 소프트웨어 및 하드웨어 플랫폼마다 모두 다릅니다. 특정 플랫폼에 종속된 소프트웨어는 다른 플랫폼에 이식하기도 어렵고요. 또한 플랫폼에서도 버전의 변경을 따라가기 어려울 수도 있습니다. 이런 플랫폼 종속성을 제거하는 것은 시스템 설계에 있어 매우 중요합니다. (디자인 패턴 : 추상 팩토리, 가교)
4. 객체의 표현이나 구현에 대한 의존성 : 사용자가 객체의 표현 방법, 저장 방법, 구현 방법, 존재의 위치에 대한 모든 방법을 알고 있다면 객체를 변경할 때 사용자도 함께 변경해야 합니다. 이런 정보를 사용자에게 감춤으로써 변화의 파급을 막을 수 있습니다. (디장니 패턴 : 추상 팩토리, 가교, 메멘토, 프록시)
5. 알고리즘 의존성 : 알고리즘 자체를 확장할 수도, 최적화할 수도, 다른 것으로 대체할 수도 있는데, 알고리즘에 종속된 객체라면 알고리즘이 변할 대마다 객체도 변경해야 합니다. 그러므로 변경이 가능한 알고리즘은 분리해 내는 것이 바람직합니다. (디장니 패턴 : 빌더, 반복자, 전략, 템플릿 메서드, 방문자)
6. 높은 결합도 : 높은 결합도를 갖는 클래스들은 독립적으로 재사용하기 어렵습니다. 높은 결합도를 갖게 되면 하나의 커다란 시스템이 되어 버립니다. 이렇게 되면 클래스 하나를 수정하기 위해선 전체를 이해해야 하고 다른 많은 클래스도 변경해야 합니다. 또한 시스템은 배우기도 힘들고, 이식은 커녕 유지보수하기조차도 어려운 공룡이 되어 버립니다. 약한 결합도는 클래스 자체의 재사용을 가능하게 하고 시스템의 이해와 수정, 확장이 용이해서 이식성을 증대시킵니다. 추상 클래스 수준에서 결합도를 정의한다거나 계층화시키는 방법으로 디자인 패턴은 낮은 결합도의 시스템을 만들도록 합니다. (디자인 패턴 : 추상 팩토리, 가교, 책임 연쇄, 명령, 파사드, 중재자, 감시자)
7. 서브클래싱을 통한 기능 확장 : 서브클래싱으로 객체를 재정의하는 것은 쉬운 일이 아닙니다. 새로운 클래스마다 매번 반드시 해야 하는 초기화, 소멸 등에 대한 구현 오버헤드를 늘 지게 됩니다. 서브클래스를 정의하려면, 최상위 클래스부터 자신의 직속 부모 클래스까지 모든 것을 이해하고 있어야 합니다. 예를 들어, 하나의 연산을 재정의하려면 상속받은 연산을 호출해야 할 때가 있기 때문에, 모든 부모 클래스를 다 이해하고 어떤 클래스에 정의된 연산을 호출할지 결정할 수 있어야 합니다. 또한, 단순히 확장만을 이유로 새로운 서브클래스를 만든다면 서브클래싱은 클래스의 수를 엄청나게 증가시킬 수도 있습니다. 일반적으로 객체 합성과 위임은 행동 조합을 위한 상속보다 훨씬 유연한 방법입니다. 기존 객체들을 새로운 방식으로 조합함으로써 새로운 서브클래스를 정의하지 않고도 응용프로그램에 새롱누 기능성을 추가할 수 있습니다. 한편, 객체 합성을 많이 사용한 시스템은 이해하기가 어려워집니다. 많은 디자인 패턴에서는 그냥 서브클래스를 정의하고 다른 인스턴스와 새로 정의한 클래스의 인스턴스를 합성해서 기능을 재정의한는 방법을 도입합니다. (디자인 패턴 : 가교, 책임 연쇄, 장식자, 감시자, 전략)
8. 클래스 변경이 편하지 못한 점 : 가끔 클래스를 변경하는 작업이 그렇게 단순하지 않을 때가 많습니다. 소스 코드가 필요한데 없다고 가정해 봅시다. 또한 어떤 변경을 하면 기존 서브클래스의 다수를 수정해야 한다고 가정합시다. 디자인 패턴은 이런 환경에서 클래스를 수정하는 방법을 제시합니다. (디자인 패턴 : 적응자, 장식자, 방문자)

## Chapter2 : 사례 연구 : 문서 편집기 설계

- 패스

## Chapter3 : 생성 패턴

- 생성 패턴(Creational pattern)은 인스턴스를 만드는 절차를 추상화하는 패턴입니다. 이 범주에 해당하는 패턴은 객체를 생성/ 합성하는 방법이나 객체의 표현 방법과 (소프트웨어) 시스템을 분리해 줍니다. 클래스 생성 패턴이 인스턴스로 만들 클래스를 다양하게 만들기 위한 용도로 상속을 사용하는 반면, 객체 생성 패턴은 인스턴스화 작업을 다른 객체에게 떠넘길 수도 있습니다.
- 생성 패턴이 나오면 항상 따라다니는 이야기가 두 개 있습니다. 첫째, 생성 패턴은 시스템이 어떤 구체 클래스를 사용하는지에 대한 정보를 캡슐화합니다. 둘째, 생성 패턴은 이들 클래스의 인스턴스들이 어떻게 만들고 어떻게 서로 맞붙는지에 대한 부분을 완전히 가려줍니다. 결론적으로, 생성 패턴을 이용하여 무엇이 생성되고, 누가 이것을 생성하며, 이것이 어떻게 생성되는지, 언제 생성할 것인지 결정하는 데 유연성을 확보할 수 있게 됩니다.

**추상 팩토리 패턴**

- 상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공합니다.

추상 팩토리 패턴을 쓰면서 얻는 이익과 부담은 다음과 같습니다.

1. 구체적인 클래스를 분리합니다. : 추상 팩토리 패턴을 쓰면 응용프로그램이 생성할 객체의 클래스를 제어할 수 있습니다. 팩토리는 제품 객체를 생성하는 과정과 책임을 캡슐화한 것이기 때문에, 구체적인 구현 클래스가 사용자에게서 분리됩니다. 일반 프로그램은 추상 인터페이스를 통해서만 인스턴스를 조작합니다. 제품 클래스 이름이 구체 팩토리의 구현에서 분리되므로, 사용자 코드에는 나타나지 않는 것입니다.
2. 제품군을 쉽게 대체할 수 있도록 합니다. : 구체 팩토리의 클래스는 응용프로그램에서 한 번만 나타나기 때문에 응용프로그램이 사용할 구체 팩토리를 변경하기는 쉽습니다. 또한, 구체 팩토리를 변경함으로써 응용프로그램은 서로 다른 제품을 사용할 수 있게 변경됩니다. 추상 팩토리는 필요한 모든 것을 생성하기 때문에 전체 제품군은 한번에 변경이 가능합니다.
3. 제품 사이의 일관성을 증진시킵니다. : 하나의 군 안에 속한 제품 객체들이 함께 동작하도록 설계되어 있을 때, 응용프로그램은 한 번에 오직 한 군에서 만든 객체를 사용하도록 함으로써 프로그램의 일관성을 갖도록 해야 합니다. 추상 팩토리를 쓰면 이 점을 아주 쉽게 부장할 수 있습니다.
4. 새로운 종류의 제품을 제공하기 어렵습니다. : 새로운 종류의 제품을 만들기 위해 기존 추상 팩토리를 확장하기가 쉽지 않습니다. 생성되는 제품은 추상 팩토리가 생성할 수 있는 제품 집합에만 고정되어 있기 때문입니다. 만약 새로운 종류의 제품이 등장하면 팩토리의 구현을 변경해야 합니다. 이는 추상 팩토리와 모든 서브클래스의 변경을 가져옵니다. 즉, 인터페이스가 변경되는 새로운 제품을 생성하는 연산이 추가되거나, 기존 연산의 반환 객체 타입이 변경되었으므로, 이를 상속받는 서브클래스 모두 변경되어야 합니다.

**빌더 패턴**

- 복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공할 수 있도록 합니다.
- 빌더 패턴은 다음의 경우에 사용합니다.
  - 복합 객체의 생성 알고리즘이 이를 합성하는 요소 객체들이 무엇인지 이들의 조립 방법에 독립적일 때
  - 합성할 객체들의 표현이 서로 다르더라도 생성 절차에서 이를 지원해야 할 때
  
빌더 패턴을 쓰면서 얻는 이익과 부담은 다음과 같습니다.

1. 제품에 대한 내부 표현을 다양하게 변화할 수 있습니다. : Builder 객체는 디렉터를 제공하는 제품을 복합하기 위해 필요한 추상 인터페이스를 정의합니다. 빌더를 사용하면 제품이 어떤 요소에서 복합되는지, 그리고 각 요소들의 표현 방법이 무엇인지 가릴 수 있게 됩니다. 즉, 요소로 전체 제품을 복합하고 그 요소들이 어떤 타입들로 구현되는지 알고 있는 쪽은 빌더뿐입니다. 제품을 복합할 때는 빌더에 정의된 추상 인터페이스를 통해 사용자가 동작하기 때문에, 새로운 제품의 표현 방법이나 제품의 복합 방법이 바뀔 때 추상 인터페이스를 정의한 Builder 클래스에서 상속을 통해 새로운 서브클래스를 정의하면 됩니다.
2. 생성과 표현에 필요한 코드를 분리합니다. : 빌더 패턴을 사용하면, 복합 객체를 생성하고 복합 객체의 내부 표현 방법을 별도의 모듈로 정의할 수 있게 됩니다. 사용자는 제품의 내부 구조를 정의한 클래스는 전혀 모른 채, 빌더와 상호작용을 통해서 필요한 복합 객체를 생성하게 됩니다. 왜냐하면, 이러한 제품 구조에 대한 상세한 정의를 담은 클래스는 클래스에 정의된 어떤 연산의 매개변수로도 정의되지 않기 때문입니다. 각 ConcreteBuilder는 특정 종류의 제품을 생성하고 조립하는 데 필요한 모든 코드를 포함합니다. 코드는 한 번만 작성됩니다. 이후에 Director 객체들이 이것을 재사용해서 똑같은 부품에서 여러 가지 Product를 구축할 수 있는 것입니다.
3. 복합 객체를 생성하는 절차를 좀더 세밀하게 나눌 수 있습니다. : 한번에 복합 객체를 생성하는 것처럼, 빌더 패턴은 디렉터의 통제 아래 하나씩 내부 구성요소들을 만들어 나갑니다. 디렉터가 빌더에서 만든 전체 복합 객체를 되돌려받을 때까지 제품 복합의 과정은 계속됩니다. 그렇기 때문에 Builder 클래스의 인터페이스에는 이 제품을 생성하는 과정 자체가 반영되어 있습니다.

- 복잡한 객체를 생성해야 할 때 추상 팩토리 패턴은 빌더 패턴과 비슷한 모습을 보입니다. 근본적인 차이가 있다면 빌더 패턴은 복잡한 객체의 단계별 생성에 중점을 둔 반면, 추상 팩토리 패턴은 제품의 유사군들이 존재할 때 유연한 설계에 중점을 둔다는 것입니다. 빌더 패턴은 생성의 마지막 단계에서 생성한 제품을 반환하는 반면, 추상 팩토리 패턴에서는 만드는 즉시 제품을 반환합니다. 추상 팩토리 패턴에서 만드는 제품은 꼭 모여야만 의미 있는 것이 아니라 하나만으로도 의미가 있기 때문입니다.

**팩토리 메서드**

- 객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 합니다.
- 팩토리 메서드는 다음과 같은 상황에 사용합니다.
  - 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때
  - 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때
  - 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떹 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때
- 팩토리 메서드 패턴은 응용프로그램에 국한된 클래스가 여러분의 코드에 종속되지 않도록 해 줍니다. 응용프로그램은 Product 클래스에 정의된 인터페이스와만 동작하도록 코드가 만들어지기 때문에, 사용자가 정의한 어떤 ConcreteProduct 클래스와도 동작할 수 있게 됩니다.
- 팩토리 메서드의 잠재적인 단점은 사용자가 ConcreteProduct 객체 하나만 만들려 할 때도 Creator 클래스를 서브클래싱해야 할지 모른다는 점입니다. 서브클래싱 기법은 사용자 Creator 클래스를 상속해서 서브클래스를 만드러야 할 때는 거럭저럭 훌륭한 방법이지만, 그렇지 않은 때라면 다른 방식으로 클래스의 진화 과정을 처리해야 합니다.

팩토리 메서드 패턴을 쓰면서 얻는 결과는 다음과 같이 두 가지가 더 있습니다.

1. 서브클래스에 대한 훅(hook) 메서드를 제공합니다. : 팩토리 메서드로 클래스 내부에서 객체를 생성하는 것이 객체를 직접 생성하는 것보다 훨씬 응용성이 높아집니다. 팩토리 메서드 패턴에서는 객체별로 서로 다른 버전을 제공하는 훅 기능을 서브클래스에 정의합니다. 
2. 병렬적인 클래스 게통을 연결하는 역할을 담당합니다. : 팩토리 메서드는 병렬적인 클래스 계통이 만들어질 때 더욱 쓸모가 있습니다. 병렬적 클래스 계통은 클래스가 자신의 책임을 분리된 다른 클래스에 위임할 때 발생합니다. 사용자와 대화식으로 처리되는 그래픽 객체를 생각해봅시다. 그래픽 객체는 마우스를 통해 크기를 조정하고, 뒤집고, 이동시킬 수 있습니다. 이러한 상호작용을 구현하는 것은 항상 쉬운 일만은 아닙니다. 이런 구현의 어떤 시점에서는 조작의 상태를 저장하고, 조작에 필요한 정보를 저장/수정하는 구현이 필요하게 됩니다. 이 상태는 조작 과정 중에서만 필요한 정보입니다만, 그림 객체 자체에 저장될 필요는 없습니다. 서로 다른 그림은 서로 다르게 동작해야 합니다. 즉, 선의 길이를 늘이는 것과 글자의 크기를 크게 하는 것은 다른 방식으로 구현해야 한다는 말입니다. 이들 제약 사항을 고려하면, 사용자와의 상호작용을 구현하고 특정한 조작에 관련된 상태를 추적/저장하는 별도의 Manipulator 객체를 사용하는 것이 더 바람직합니다.

- 추상 팩토리 패턴은 이 팩토리 메서드를 이용해서 구현할 때가 많습니다. 추상 팩토리 패턴의 '동기' 절에서도 팩토리 메서드의 모습을 볼 수 있습니다.
- 팩토리 메서드는 템플릿 메서드 패턴에서도 사용될 때가 많습니다.
- 원형 패턴은 Creator클래스의 상속이 필요하지는 않습니다. 그러나 Product 클래스의 정의된 초기화 연산은 필요합니다. Creator 클래스는 객체의 초기화를 위해 초기화 연산을 사용하지만, 팩토리 메서드는 이런 연산이 필요하지 않습니다.

**원형(Prototype)**

- 원형이 되는(prototypical) 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체를 생성합니다.
- 원형 패턴은 제품의 생성, 복합, 표현 방법에 독립적인 제품을 만들고자 할 때 씁니다. 그리고
  - 인스턴스화할 클래스를 런타임에 지정할 때(이를테면, 동적 로딩), 또는
  - 제품 클래스 계통과 병렬적으로 만든느 팩토리 클래스를 피하고 싶을 대, 또는
  - 클래스의 인스턴스들이 서로 다른 상태 조합 중에 어느 하나일 때 원형 패턴을 씁니다. 이들을 미리 원형으로 초기화해 두고, 나중이 이를 복제해서 사용하는 것이 매번 필요한 상태 조합의 값들을 수동적으로 초기화하는 것보다 더 편리할 수도 있습니다.

- 원형 패턴은 추상 팩토리 및 빌더와 비슷한 결과를 낳습니다. 사용자 쪽에는 어떤 구체적인 제품이 있는지 알리지 않아도 되기 때문에 사용자 쪽에서 상대해야 하는 클래스의 수가 적습니다. 게다가, 수정하지 않고도 응용프로그램에 따라 필요한 클래스들과 동작할 수 있게 됩니다.

- 원형 패턴의 추가적 특성은 다음과 같습니다.
  1. 런타임에 새로운 제품을 추가하고 삭제할 수 있습니다. : 원형 패턴을 이용하면 사용자에게 원형으로 생성되는 인스턴스를 등록하는 것만으로도 시스템에 새로운 제품 클래스를 추가할 수 있게 됩니다. 런타임에 새로운 원형을 넣고 빼기가 쉽다는 점에서 다른 생성 패턴에 비해 유연성을 지니고 있습니다.
  2. 값들을 다양화함으로써 새로운 객체를 명세합니다. : 고도로 동적화된 시스템에서는 새로운 클래스를 생성할 필요 없이 객체 합성 - 이를 테면, 객체에 변수의 값을 지정한다든지 해서-으로 새로운 행동을 정의할 수 있습니다. 이 의미는 객체의 변수가 다른 클래스에 대한 참조자를 정의하고 있다면, 이 참조자가 합성한 새로운 클래스만 정의하고, 그 클래스의 인스턴스에 대한 참조자만을 넘겨주면, 새로운 행동이 정의되는 것처럼 보인다는 것입니다. 마찬가지로 원형 패턴에서도 사용자와 동작할 원형에 해당하는 기존 클래스의 인스턴스를 만들어서 그 인스턴스를 등록하면, 사용자는 이 원형에 정의된 행동이 수행되어 마치 새로운 행동이 정의된 듯한 결과를 얻게 됩니다. 이런 식으로 설계된다면 추가 프로그램 없이도 새로운 "클래스"를 정의할 수 있습니다. 사실 원형을 복제하는 것은 클래스의 인스턴스를 만드는 것과 동일합니다. 원형 패턴은 시스템에 필요한 객체를 생성하기 위해 정의할 클래스의 수를 대폭 줄여주는 효과가 있습니다.
  3. 구조를 다양화함으로써 새로운 객체를 명세할 수 있습니다. : 많은 응용프로그램은 구성요소와 부분 구성요소의 복합을 통해 객체를 구축합니다. 예를 들어, 회로 설계를 위한 편집기는 세부 회로를 모아서 큰 회로를 만듭니다. 이런 응용프로그램에서는 편의를 위해 복잡한 사용자 정의 구조를 사용자가 인스턴스화 하여 그 상황에 맞는 세부 회로를 계속 이용할 수 있도록 배려해 줄 때가 많습니다. 이때도 원형 패턴은 매우 좋은 해결책이 될 수 있습니다. 그냥 이 세부 회로를 원형으로 만들어, 이것을 현재 사용 가능한 회로 요소 관리 팔레트에 등록하기만 하면 됩니다. 그러고 나면 이 복합 회로 객체가 Clone() 연산을 구현함으로써 다른 구조를 갖는 회로의 기본 골격을 만듭니다.
  4. 서브클래스의 수를 줄입니다. : 팩토리 메서드를 보면 Creator 클래스의 계통이 처리할 제품 관련 클래스의 계통과 병렬로 복합되는 것을 알 수 있습니다. 원형 패턴에서는 팩토리 메서드에 새로운 객체를 만들어 달라고 요청하는 것이 아니라 원형을 복제하는 것이므로, Creator 클래스에 따른 새로운 상속 계층은 필요 없습니다. 이 장점의 혜택을 우선적으로 받는 언어는 C++와 같은 1급 객체(first-class object)를 처리하지 않는 언어입니다.
  5. 동적으로 클래스에 따라 응용프로그램을 설정할 수 있습니다. : 몇몇 런타임 환경에서는 동적으로 클래스들을 응용프로그램으로 등록할 수 있도록 해 줍니다. 원형 패턴은 c++ 같은 언어의 특징을 잘 살릴 수 있습니다. 동적으로 로드된 클래스의 인스턴스를 생성하고 싶은 응용프로그램은 정적으로 그 클래스의 생성자를 참조할 수 없습니다. 그 대신 런타임 환경이 그 클래스의 인스턴스를 자동으로 생성하고 원형 관리자에게 등록합니다. 그러면 응용프로그램은 이 원형 관리자에게서 필요한 클래스의 인스턴스를 얻게 됩니다. 원래 이 클래슨느 프로그램과 연결되어 있지 않았던 것들이죠.
- 원형 패턴을 쓸 때 여러분이 신경 써야 하는 가장 큰 걸림돌은 원형의 서브클래스가 Clone() 연산을 구현해야 한다는 것입니다. 매운 어려울 수도 있는 일이죠. 예를 들어, 점찍어 놓은 클래스가 이미 만들어졌거나 한 상태에서는 Clone() 연산을 추가하기가 어렵습니다. 또한 복사를 지원하지 않거나 환형 참조(circular reference)가 없는 객체를 포함한다면 Clone() 연산의 구현을 어려울 수 있습니다. 이런 때는 원형 패턴의 적용이 힘듭니다.

**단일체(Singleton)**

- 오직 한 개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공합니다.

- 단일체 패턴은 다음 상황에서 사용합니다.
  - 클래스의 인스턴스가 오직 하나여야 함을 보장하고, 잘 정의된 접근점(access point)으로 모든 사용자가 접근할 수 있도록 해야 할 때
  - 유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드의 수정 없이 확장된 섭클래스의 인스턴스를 사용할 수 있어야 할 때

단일체 패턴이 갖는 장점들을 보면 다음과 같습니다.

1. 유일하게 존재하는 인스턴스로의 접근을 통제합니다. : Singleton 클래스 자체가 인스턴스를 캡슐화하기 때문에, 이 클래스에서 사용자가 언제, 어떻게 이 인스턴스에 접근할 수 있는지 제어할 수 있습니다.
2. 이름 공간(name space)을 좁힙니다. : 단일체 패턴은 전역 변수보다 더 좋습니다. 전역 변수를 사용해서 이름 공간을 망치는 일을 없애주기 때문입니다. 즉, 전역 변수를 정의하여 발생하는 디버깅의 어려움 등 문제를 없앱니다.
3. 연산 및 표현의 정제를 허용합니다. : Singleton 클래스는 상속될 수 있기 때문에, 이 상속된 서브클래스를 통해서 새로운 인스턴스를 만들 수 있습니다. 또한 이 패턴을 사용하면, 런타임에 필요한 클래스의 인스턴스를 써서 응용프로그램을 구성할 수도 있습니다.
4. 인스턴스의 개수를 변경하기가 자유롭습니다. : 마음이 바뀌어서 Singleton 클래스의 인스턴스가 하나 이상 존재할 수 있도록 변경해야 할 때도 있는데, 이 작업도 어렵지 않습니다. 게다가, 응용프로그램이 사용하는 인스턴스가 다수여야 할 때도 똑같은 방법을 쓸 수 있습니다. 즉, Singleton 클래스의 인스턴스에 접근할 수 있는 허용 범위를 결정하는 연산만 변경하면 됩니다. 왜냐하면 기존에는 하나의 인스턴스로만 접근을 허용했다면, 이제는 여러 개의 인스턴스를 생성해서 그 각각의 인스턴스로 접근할 수 있도록 연산의 구현을 바꾸면 되기 때문입니다.
5. 클래스 연산을 사용하는 것보다 훨씬 유연한 방법입니다. : 단일체 패턴과 동일한 기능을 발휘하는 방법이 클래스 연산을 사용하는 것입니다. 그러나 이 두 언어에서 클래스의 인스턴스가 하나 이상 존재할 수 있도록 설계를 변경하는 것은 어렵습니다. 게다가, C++의 정적 멤버 함수는 가상 함수가 아니므로, 서블클래스들이 이 연산을 오버라이딩 할 수 없습니다.

## Chapter4 구조 패턴

구조 패턴(structural pattern)은 더 큰 구조를 형성하기 위해 어떻게 클래스와 객체를 합성하는가와 관련된 패턴입니다. 구조 클래스 패턴은 상속 기법을 이용하여 인터페이스나 구현을 복합합니다.

구조 객체 패턴은 인터페이스나 구현을 복합하는 것이 아니라 새로운 기능을 실현하기 위해 객체를 합성하는 방법을 제공합니다. 객체 합성이 갖는 추가된 유연성은 런타임에 복합 벙법이나 대상을 변경할 수 있다는 점에서 나옵니다. 이는 정적인 클래스 복합을 사용해서는 불가능한 일입니다.

**적응자(Adapter)**

클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응(변환)시킵니다. 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킵니다.

적응자 패턴은 다음 상황에서 사용합니다.

- 기존 클래스를 사용하고 싶은데 인터페이스가 맞지 않을 때
- 아직 예측하지 못한 클래스나 실제 관련되지 않는 클래스들이 기존 클래스를 재사용하고자 하지만, 이미 정의된 재사용 가능한 클래스가 지금 요청하는 인터페이스를 꼭 정의하고 있지 않을 때. 다시 말해, 이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때
- [객체 적응자(object adapter)만 해당됨] 이미 존재하는 여러 개의 서브클래스를 사용해야 하는데, 이 서브클래스들의 상속을 통해서 이들의 인터페이스를 다 개조한다는 것이 현실성이 없을 때. 객체 적응자를 써서 부모 클래스의 인터페이스를 변형하는 것이 더 바람직함.

클래스 적응자와 객체 적응자는 각각 장단점이 있습니다. 먼저 클래스 적응자를 살펴봅시다.

- Adapter 클래스는 Adaptee 클래스를 Target 클래스로 변형하는데, 이를 위해서 Adaptee 클래스를 상속받아야 하기 때문에, 하나의 클래스와 이 클래스의 모든 서브클래스들을 개조할 때라면 클래스 적응자 방식을 사용할 수 없습니다. 즉, Adapter는 명시적으로 Adaptee 를 상속받고 있을 뿐 Adaptee의 서브클래스들을 상속받는 것은 아니므로, Adaptee의 서브클래스에 정의된 기능들을 사용할 수 없습니다.
- Adapter 클래스는 Adaptee 클래스를 상속하기 때문에 Adaptee 에 정의된 행동을 재정의할 수도 있습니다.
- 한 개의 객체(Adapter) 만 사용하며, Adaptee로 가기 위한 추가적인 포인터 간접화는 필요하지 않습니다.

객체 적응자를 사용하면 다음과 같은 특징을 경험할 수 있습니다.

- Adapter클래스는 하나만 존재해도 수많은 Adaptee 클래스들과 동작할 수 있습니다. 왜냐하면 Adapter 객체가 포함하는 Adaptee에 대한 참조자는 Adaptee의 인스턴스를 관리할 수도 있고, Adaptee 클래스를 상속받는 다른 서브클래스들의 인스턴스도 관리할 수 있기 때문입니다. 그러므로 하나의 Adapter 클래스로 모든 Adaptee 클래스와 이를 상속받는 서브클래스 모두를 이용할 수 있게 됩니다.
- Adaptee 클래스의 행동을 재정의하기가 매우 어렵습니다. 이것을 위해서는 Adaptee 클래스를 상속받아서 새로운 서브클래스를 만들고, Adapter 클래스는 Adaptee 클래스가 아닌 Adaptee 클래스의 해당 서브클래스를 참조하도록 해야 합니다.

Adapter 패턴을 사용하면서 고려해야 할 추가적인 사항들을 알아봅시다.

1. Adapter 클래스가 실제 적응 작업을 위해 들어가는 품이 얼마나 되나?
2. 대체 가능(Pluggable) 적응자
3. 양방향 적응자를 통한 투명성 제공

관련패턴 : 가교 패턴은 객체 적응자와 클래스 구조가 유사하나 그 사용 목적이 다릅니다. 가교 패턴은 구현과 이 구현이 만족할 추상 개념을 분리하여 서로에게 영향을 주지 않고 각각 확장할 수 있도록 하려는 것이고, 적응자 패턴은 존재하는 객체의 인터페이스를 변경하려는 것입니다.

장식자 패턴은 다른 인터페이스의 변경 없이도 객체에 새로운 행동을 추가할 수 있도록 합니다. 이것은 적응자보다는 응용프로그램을 위해 훨씬 좋은 방법이고, 순수한 적응자로는 불가능한 재귀적 합성을 가능하게 합니다.

프록시 패턴은 다른 객체에 대한 대표자 또는 대리인의 역할을 수행하지만 인터페이스를 변경하는 책임은 없습니다.

**가교(Bridge)**

구현에서 추상을 분리하여, 이들이 독립적으로 다양성을 가질 수 있도록 합니다.

가교 패턴은 다음과 같은 경우에 사용합니다.

- 추상적 개념과 이에 대한 구현 사이의 지속적인 종속 관계를 피하고 싶을 때. 이를테면, 런타임에 구현 방법을 선택하거나 구현 내용을 변경하고 싶을 때가 여기 해당합니다.
- 추상적 개념과 구현 모두가 독립적으로 서브클래싱을 통해 확장되어야 할 때. 이때, 가교 패턴은 개발자가 구현을 또 다른 추상적 개념과 연결할 수 있게 할 뿐 아니라, 각각을 독립적으로 확장 가능하게 합니다.
- 추상적 개념에 대한 구현 내용을 변경하는 것이 다른 관련 프로그램에 아무런 영향을 주지 않아야 할 때. 즉, 추상적 개념에 해당하는 클래스를 사용하는 코드들은 구현 클래스가 변경되었다고 해서 다시 컴파일되지 않아야 합니다.
- (C++) 사용자들은 사용자에게 구현을 완벽하게 은닉하길 원할 때. C++에서는 클래스를 구현하는 방식이 인터페이스에 모두 노출됩니다. 이 의미는 컴파일러 입장에서는 클래스에 정의된 속성이 private로 정의되어 있을 때 다른 부분에서는 클래스의 private 영역으로의 접근이 불가능합니다. 그러나 코드를 살펴보면 어떤 속성이 정의되어 있고, 어떤 구현 방식에 의해 연산을 구현하였는지를 다 파악할 수 있습니다. 그러나 이러한 가교 패턴을 사용하면 이런 속성의 정의나 구현 메서드가 별도의 클래스에 정의되고 사용자와 개발자가 보게 되는 클래스 소스 코드에는 구현 클래스에 대한 참조자만이 정의되어 있으므로, 클래스의 구현과 속성에 대한 모든 표현 방식이 완전하게 은닉됩니다.
- 클래스 계통에서 클래스 수가 급증하는 것을 방지하고자 할 때, 이러한 클래스는 클래스 상속 계통에서 하나의 이유로 여러 개 클래스가 갑자기 정의되어야 하는 상황이라면 객체를 두 부분으로 분리할 필요가 있음을 보여줍니다. 럼버(Rumbaugh)는 이를 "중첩된 일반화(nested generalization)"로 정의하였습니다.
- 여러 객체들에 걸쳐 구현을 공유하고자 하며(아마도 참조 카운팅 등의 방법을 써서), 또 이런 사실을 사용자 쪽에 공개하고 싶지 않을 때. 간단한 예는 코플리엔(Coplien)의 String 클래스인데, 이 클래스를 써서 인스턴스화된 객체들은 하나의 동일한 문자열 표현부를 공유할 수 있습니다.

가교 패턴을 쓰면 다음 결과가 나타납니다.

1. 인터페이스와 구현 분리 : 구현이 인터페이스에 얽매이지 않게 됩니다. 추상적 개념에 대한 어떤 방식의 구현을 택할지가 런타임에 결정될 수 있습니다. 이는 런타임에 어떤 객체가 자신의 구현을 수시로 변경할 수 있음을 의미합니다. Abstraction과 Implementor의 분리는 컴파일 타임 의존성을 제거할 수 있습니다. 구현을 변경하더라도 추상적 개념에 대한 클래스를 다시 컴파일할 필요가 없고, 추상적 개념 클래스와 관련된 다른 코드 역시도 다시 컴파일할 필요가 없습니다. 그뿐만 아니라, 더 잘 구조화된 시스템을 이끄는 계층화(layering) 도 가능해집니다. 이런 시스템의 상위 수준 영역에서는 Abstraction과 Implementor 만 알면 됩니다.
2. 확장성 제고 : Abstraction과 Implementor를 독립적으로 확장할 수 있습니다.
3. 구현 세부 사항을 사용자에게서 숨기기 : 상세한 구현 내용을 사용자에게서 은닉할 수 있습니다.

관련 패턴

- 추상 팩토리 패턴을 이용해서 특정 가교를 생성하고 복합할 수 있도록 합니다.
- 적응자 패턴은 서로 관련이 없는 클래스들이 함께 동작하게 만드는 쪽에 특화시켜 만든 패턴입니다. 이 패턴은 대개 각 클래스의 설계가 끝난 후에 적용됩니다. 한편, 가교 패턴은 설계 단계 초기에 투입되어 추상화 및 구현이 독립적으로 다양화되도록 만드는 데 쓰입니다.

**복합체(Composite)**

부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성합니다. 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴입니다.

복합체 패턴은 다음과 같은 경우에 사용합니다.

- 부분 - 전체의 객체 계통을 표현하고 싶을 때
- 사용자가 객체의 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때. 사용자는 복합 구조(Composite structure)의 모든 객체를 똑같이 취급하게 됩니다.

복합체 패턴으로 발생하는 결과는 다음과 같습니다.

- 기본 객체와 복합 객체로 구성된 하나의 일관된 클래스 계통을 정의합니다. 기본 객체는 더 복합적인 객체들에 속해있을 수 있습니다. 물론 이 복합 객체 역시 다른 것에 속해있는 것일 수 있습니다. 그러나 사용자 코드는 일반화된 상위 개념의 객체를 조작하는 방식으로 프로그래밍하면, 런타임 기본 객체와 복합 객체를 구분하지 않고 일관되게 프로그래밍 할 수 있게 됩니다.
- 사용자의 코드가 단순해집니다. 사용자 코드는 복합 구조이나 단일 객체와 동일하게 다루는 코드로 작성되기 때문입니다. 즉, 사용자와 객체의 특성이 복합 구조인지 단일 구조인지조차 모르고 개발할 수 있습니다. 이런 구분이 필요치 않으므로 개발자의 코드에 "꼬리표-case-문장" 스타일의 함수를 쓸 필요가 없으지므로 코드가 단순해집니다.
- 새로운 종류의 구성요소를 쉽게 추가할 수 있습니다. 새롭게 정의된 Composite나 Leaf의 서브클래스들은 기존에 존재하는 구조들과 독립적으로 동작이 가능하게 됩니다. 그러므로 새로운 요소가 추가되었다고 해서 사용자의 프로그램이 변경될 필요는 전혀 없습니다.
- 설계가 지나치게 범용성을 많이 가집니다. 새로운 요소를 쉽게 추가할 때의 단점은 복합체의 구성요소에 제약을 가하기 힘들다는 것입니다. 가끔 복합체가 오직 한 개의 구성요소만 가졌으면 할 때가 있습니다. Composite 클래스만으로 타입 시스템을 통해 이런 제약을 가할 수 없습니다. 런타임 점검이 들어가야 합니다.

관련 패턴

- 구성요소-부모 간의 연결은 책임 연쇄 패턴에서 많이 사용되는 예입니다.
- 장식자 패턴은 자주 복합체 패턴과 함께 사용됩니다. 이 두 패턴이 함께 사용될 때는 둘 다 동일한 하나의 부모 클래스를 상속받게 됩니다. 따라서 장식자는 Add(), Remove(), GetChild()와 같은 연산을 통해서 Component의 인터페이스를 지원해야 합니다.
- 플라이급 패턴으로 구성요소의 공유 방법을 얻을 수 있습니다. 단, 공유되는 구성요소의 부모는 참조할 수 없습니다.
- 반복자 패턴을 이용하면, 구성요소를 순회하는 방법을 얻을 수 있습니다.
- 방문자 패턴을 이용하면, 이 패턴을 사용하지 않을 때 Composite와 Leaf 클래스에 걸쳐 분산될 수 있는 행동을 국소화시킬 수 있습니다.

**장식자(Decorator)**

- 객체에 동적으로 새로운 책임을 추가할 수 있게 합니다. 기능을 추가하려면, 서브클래스를 생성하는 것보다 융통성 있는 방법을 제공합니다.

장식자 패턴은 다음의 경우에 사용합니다.

- 동적으로 또한 투명하게(transparent), 다시 말해 다른 객체에 영향을 주지 않고 개개의 객체에 새로운 책임을 추가하기 위해 사용합니다.
- 제거될 수 있는 책임에 대해 사용합니다.
- 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못할 때 사용합니다. 너무 많은 수의 독립된 확장이 가능할 때 모든 조합을 지원하기 위해 이를 상속으로 해결하면 클래스 수가 폭발적으로 많아지게 됩니다. 아니면 클래스 정의가 숨겨지든가, 그렇지 않더라도 서브클래싱을 할 수 없게 됩니다.

장식자 패턴을 쓰면서 얻는 이익과 부담은 각각 두 가지입니다.

1. 단순한 상속보다 설계의 융통성을 더 많이 증대시킬 수 있습니다. : 장식자 패턴은 객체에 새로운 행동을 추가할 수 있는 가장 효과적인 방법입니다. 장식자를 사용하면 장식자를 객체와 연결하거나 분리하는 작업을 통해 새로운 책임을 추가하거나 삭제하는 일이 런타임에 가능해집니다. 그러나 상속은 코드에서, 즉 정적으로 새로운 클래스를 추가해야만 추가적인 행동을 정의할 수 있는 방법입니다. 이는 새로운 기능이 추가될 때마다 클래스의 수가 증가하는 결과를 낳게 됩니다. 그러나 장식자 패턴을 사용하면, 장식자의 조합을 통해서 새로운 책임도 조합할 수 있습니다. 이는 구조에 나타나는 바와 같이 Decorator 클래스와 Component 클래스 사이에 집합 관계가 정의되어 있어 Decorator는 Component 클래스의 인스턴스를 포함할 수 있는데, 이는 Component의 서브클래스인 Concrete-DecoratorA 클래스나 Concret-DecoratorB 클래스의 인스턴스를 포함할 수 있다는 의미가 됩니다. 이렇게 Decorator의 서브클래스를 아무런 노드의 수정 없이 포함할 수 있으므로, Decorator 클래스의 서브클래스 여러 개를 포함하면 여러 책임을 조합하는 결과가 됩니다.
2. 클래스 계통의 상부측 클래스에 많은 기능이 누적되는 상황을 피할 수 있습니다. : 장식자 패턴은 책임 추가 작업에서 "필요한 비용만 그때 지불하는" 방법을 제공합니다. 지금 예상하지 못한 특성들을 한꺼번에 다 개발하기 위해 고민하고 노력하기보다는 발견하지 못하고 누락된 서비스들을 Decorator 객체를 통해 지속적으로 추가할 수 있습니다. 기능은 단순한 구성요소들의 조합으로 얻어질 수도 있습니다. 그러므로 응용프로그램 개발 시 현재 사용되지 않은 기능까지 개발하기 위해 시간과 노력을 투자할 필요는 없습니다. 이는 나중에 실제 그 기능이 필요할 때 새로운 종류의 Decorator를 개발함으로서 가능합니다.
3. 장식자와 해당 그 장식자의 구성요소가 동일한 것은 아닙니다. : 장식자는 사용자에게 일관된 인터페이스를 제공하는 껍데기입니다. 그러므로 객체 식별자 관점에서 구성요소와 이를 둘러싼 Decorator 객체가 동일한 식별자를 가질 필요는 없습니다.
4. 장식자를 사용함으로써 작은 규모의 객체들이 많이 생깁니다. : 장식자 패턴을 사용하는 설계에서는 규모가 작은 객체들의 수가 많아지는데, 이 객체들이 서로 다른 점은 상호작용하는 방법에 있지, 클래스가 다르거나 변수에 정의된 값이 다른 것은 아닙니다. 즉, 클래스들이 어떻게 조합하여 새로운 모습과 기능을 만들어 내는가에 따라서 새로운 객체가 계속 만들어지기 때문입니다. 이때 이 객체들을 잘 이해하고 있다면 시스템의 재정의가 쉽겠지만, 그렇지 않다면 객체들을 모두 이해하고 수정하는 과정이 복잡해집니다.

장식자 패턴은 적응자 패턴과 관련되어 있습니다. 장식자는 어쩌면 일종의 적응자입니다. 즉, 원래의 적응자는 인터페이스를 변경시켜주는 것이었지만, 장식자는 객체의 책임, 행동을 변화시킵니다. 복합체 패턴과도 관련됩니다. 장식자는 한 구성요소만을 갖는 복합체로 볼 수 있습니다. 그러나 이 목적은 객체의 합성이 아니라 객체에 새로운 행동을 추가하기 위한 것입니다. 전략 패턴과도 관련됩니다. 장식자는 객체의 겉모양을 변경하고, 전략은 객체의 내부를 변화시킵니다. 객체를 변경하는 두 가지 다른 대안인 셈입니다.

**퍼사드(Facade)**

한 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공하는 패턴으로, 서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의합니다.

퍼사드 패턴은 다음의 경우에 사용합니다.

- 복잡한 서브시스템에 대한 단순한 인터페이스 제공이 필요할 때, 시스템 범위가 확장되면, 또한 구체적으로 설계되면 서브시스템은 계속 복잡해집니다. 또한 패턴을 적용하면 확장성을 고려하여 설계하기 때문에, 작은 클래스가 만들어지게 됩니다. 이런 과정은 서브시스템을 재사용 가능한 것으로 만들어주고, 재정의할 수 있는 단위가 되도록 해 주기도 하지만, 실제 이런 상세한 재설계나 정제의 내용까지 파악할 필요가 없는 개발자들에게는 복잡해진 각각의 클래스들을 다 이해하면서 서브시스템을 사용하기란 어려운 일입니다. 이럴 때 퍼사드 패턴은 서브시스템에 대한 단순하면서도 기본적인 인터페이스를 제공함으로써 대부분의 개발자들에게 적합한 클래스 형태를 제공합니다.
- 추상 개념에 대한 구현 클래스와 사용자 사이에 너무 많은 종속성이 존재할 때. 퍼사드의 사용을 통해 사용자와 다른 서브시스템 간의 결합도를 줄일 수 있습니다. 즉, 서브시스템에 정의된 모든 인터페이스가 공개되면 빈번한 메서드 호출이 있을 수 있으나, 이런 호출은 단순한 형태로 통합하여 제공하고 나머지 부분은 내부적으로 처리함으로써 사용자와 서브시스템 사이의 호출 횟수는 실질적으로 감소하게 되는 효과를 갖습니다.
- 서브시스템을 계층화시킬 때. 퍼사드 패턴을 사용하여 각 서브시스템의 계층에 대한 접근점을 제공합니다. 서브시스템이 다른 서브시스템에 종속적이라 하더라도, 각자가 제공하는 퍼사드를 통해서만 대화를 진행하게 함으로써 서브시스템 간의 종속성을 줄일 수 있습니다. 이로써 서브시스템 내부 설계의 변경이 다른 서브시스템에 독립적으로 자유롭게 될 수 있는 것입니다.

퍼사드 패턴을 사용하면 얻는 이익은 다음과 같습니다.

1. 서브시스템의 구성요소를 보호할 수 있습니다. 이로서 사용자가 다루어야할 객체의 수가 줄어들며, 서브시스템을 쉽게 사용할 수 있습니다.
2. 서브시스템과 사용자 코드 간의 결합도를 더욱 약하게 합니다. 서브시스템 내 정의된 요소들은 강하게 결합될 수 있습니다. 서브시스템과 사용자 간의 결합이 약하면, 서브시스템 내의 요소를 다양화하는 작업을 원활하게 할 수 있습니다. 대규모 소프트웨어 시스템에서는 컴파일 의존성을 줄이는 것도 매우 중요합니다. 서브시스템 클래스가 바뀔 때 재컴파일을 최소화함으로써 어떻게든 시간을 절약하고 싶을 것입니다. 퍼사드를 사용해서 컴파일 의존성을 최소화하면 주요 서브시스템에서 작은 변경으로 들어가는 재컴파일을 제한할 수 있습니다. 퍼사드를 쓰면 다른 플랫폼으로도 이식이 단순해집니다. 하나의 서브시스템을 빌드하면서 다른 모든 서브시스템까지 끌고 들어갈 때가 적어지기 때문입니다.
3. 응용프로그램 쪽에서 서브시스템 클래스를 사용하는 것을 완전히 막지는 않습니다. 그러므로 퍼사드를 사용할지 서브시스템 클래스를 직접 사용할지 결정할 수 있습니다.

관련 패턴

- 추상 팩토리 패턴은 서브시스템에 독립적인 방법으로, 서브시스템 객체를 생성하는 인터페이스를 제공하기 위해 퍼사드와 함께 사용할 수 있습니다. 추상 팩토리는 퍼사드에 대한 대안으로서, 플랫폼에 종속적인 클래스를 감추는 데 씁니다.
- 중재자 패턴도 기존에 존재하는 클래스의 기능성을 추상화한다는 점에서 퍼사드 패턴과 비슷합니다. 중재자 패턴의 목적은 여러 객체들 사이의 협력 관계를 추상화하여 기능성의 집중화를 막자는 것입니다. 중재자 패턴에 참여하는 객체는 서로를 직접 알지 못하고 단지 중재자를 통해서만 상호작용이 됩니다. 이에 비해 퍼사드는 서브시스템 인터페이스 자체를 추상화하여 사용을 용이하게 하려는 목적을 갖습니다. 즉, 새로운 기능성을 추가할 수도 없고, 이런 새로운 추가 기능에 대해서는 알 수 없습니다.
- 퍼사드 객체가 하나만 있어도 된다면, 단일체로 구현합니다.

**플라이급(Flyweight)**

공유(Sharing)를 통해 많은 수의 소립(fine-grained) 객체들을 효과적으로 지원합니다.

플라이급 패턴은 언제 사용하는가에 따라서 그 효과가 달라집니다. 다음의 경우에 사용할 수 있습니다.

- 응용프로그램이 대량의 객체를 사용해야 할 때
- 객체의 수가 너무 많아져 저장 비용이 너무 높아질 때
- 대부분의 객체 상태를 부가적인 것으로 만들 수 있을 때
- 부가적인 속성들을 제거한 후 객체들을 조사해 보니 객체의 많은 묶음이 비교적 적은 수의 공유된 객체로 대체될 수 있을 때, 현재 서로 다른 객체로 간주한 이유는 이들 부가적인 속성 때문이었지 본질이 달랐던 것은 아닐 때
- 응용프로그램이 객체의 정체성에 의존하지 않을 때. 플라이급 객체들은 공유될 수 있음을 의미하는데, 식별자가 있다는 것은 서로 다른 객체로 구별해야 한다는 의미이므로 플라이급 객체를 사용할 수 있습니다.

플라이급 패턴은 예전에는 모두 본질적인 상태로 저장되어 있던 것을 부가적인 상태로 만들어, 부가적인 상태의 연산과 전송에 드는 런타임 비용을 새로 들여올 수 있습니다. 하지만 이런 비용은 플라이급 객체의 공유를 통해 저장소 절약이라는 반대급부를 가질 수도 있습니다. 저장소 절약은 여러 면에서 기능적입니다.

- 공유해야 하는 인스턴스의 전체 수를 줄일 수 있습니다.
- 객체별 본질적 상태의 양을 줄일 수 있습니다.
- 부가적인 상태는 연산되거나 저장될 수 있습니다.

더 많은 Flyweight가 공유될수록 저장소는 절약됩니다. 또 공유할 상태가 많아질수록 절약됩니다. 대부분의 본질적인 상태가 저장되고 부가적인 상태는 연산될 때라면 절약의 효과는 가장 큽니다. 이때는 본질적 상태를 저장하는 비용이 줄어드는 대신, 부가적 상태를 만들기 위한 연산의 시간을 투자해야 합니다.

플라이급 패턴은 복합체 패턴과 조합하여 그래프와 같이 계층적 구조를 모델링하는데 사용합니다. 이렇게 하면, 플라이급 단말 노드들은 자신의 부모에 대한 포인터를 저장할 수 없기 때문에, 부모 포인터를 부가적 상태의 일부로서 플라이급 객체에다가 매개변수로 전달해야 합니다.

플라이급은 복합체 패턴과 함께 사용되는데, 공유되는 단말 노드를 갖는 방향성 비순환 그래프 형태를 써서 논리적으로 계층 구조를 구현하는 것이 여기에 해당됩니다. 상태 패턴 또는 전략 패턴을 플라이급 객체로 구현할 수 있습니다.

**프록시**

다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리채움자 역할을 하는 객체를 둡니다.

프록시 패턴은 단순한 포인터보다는 조금 더 다방면에 활용할 수 있거나 정교한 객체 참조자가 필요한 때 적용할 수 있습니다. 어떤 때인지 살펴봅시다.

1. 원격지 프록시(remote proxy) 는 서로 다른 주소 공간에 존재하는 객체를 가리키는 대표 객체로, 로컬 환경에 위치합니다. NEXTSTEP[Add94]은 이런 목적의 NXProxy 클래스를 사용합니다.
2. 가상 프록시(virtual proxy)는 요청이 있을 때만 필요한 고비용 객체를 생성합니다. 앞에서 예로 들었던 ImageProxy가 여기에 해당합니다.
3. 보호용 프록시(protection proxy)는 원래 객체에 대한 실제 접근을 제어합니다. 이는 객체별로 접근 제어 권한이 다를 때 유용하게 사용할 수 있습니다.
4. 스마트 참조자(smart reference)는 원시 포인터의 대체용 객체로, 실제 객체에 접근이 일어날 때 추가적인 행동을 수행합니다.

- 실제 객체에 대한 참조 횟수를 저장하다가 더는 참조가 없을 때 해당 객체를 자동으로 없앱니다.(스마트 포인터(Smart Pointer)라고도 합니다.)
- 맨 처음 참조되는 시점에 영속적 저장소의 객체를 메모리로 옮깁니다.
- 실제 객체에 접근하기 전에, 다른 객체가 그것을 변경하지 못하도록 실제 객체에 대해 잠금을 겁니다.

프록시 패턴은 어떤 객체에 접근할 때 추가적인 간접화 통로를 제공합니다. 이렇게 추가된 간접화 통로는 프록시의 종류에 따라서 여러 가지 쓰임새가 있습니다.

1. 원격지 프록시는 객체가 다른 주소 공간에 존재한다는 사실을 숨길 수 있습니다.
2. 가상 프록시는 오구에 따라 객체를 생성하는 등 처리를 최적화할 수 있습니다.
3. 보호용 프록시 및 스마트 참조자는 객체가 접근할 때마다 추가 관리를 책임집니다. 객체를 생성할 것인지 삭제할 것인지를 관리합니다.

Proxy 패턴이 사용자에게 숨길 수 있는 또 다른 최적화가 있습니다. 기록 시점 복사(copy-on-write)가 그것인데, 이 최적화는 요구가 들어올 땜나 객체를 생성하는 개념과 관련이 있습니다. 사실 덩치가 크고 복잡한 객체를 복사하려면 비용이 만만치 않습니다. 만약, 사본이 변경되지 않고 원본과 똑같다면, 굳이 이 비용을 물 필요가 없습니다. 프록시를 사용해서 복사 절차를 미룸으로써, 사본이 수정될 때만 실제 복사 비용을 물게 만드는 것입니다.

이 기록 시점 복사 기능을 가능하게 하려면 원본의 참조 카운트를 관리해야 합니다. 프록시를 복사하는 연산은 이 원본에 대한 참조 카운트를 증가시킨느 일 외에 다른 일을 하지 않습니다. 사용자가 이 원본을 수정하는 연산을 요청할 때 프록시가 실제로 복사를 진행하여 사본이 별도의 값을 가지게 합니다. 이렇게 되면 원본에 대한 참조자 수는 줄어듭니다. 이런 과정의 반복 속에 참조 카운트가 0이 되면 대상을 삭제합니다.

기록 시점 복사는 중량급 객체에 대한 복사 비용을 현격하게 줄여줍니다.

- 관련 패턴 : 적응자는 자신이 개조할 객체가 정의된 인터페이스와 다른 인터페이스를 제공합니다. 이에 반해, 프록시는 자신이 상대하는 대상과 동일한 인터페이스를 제공합니다. 프록시는 대상이 수행할 연산의 수행을 거부할 수도 있기 때문에, 처리 대상이 제공하는 인터페이스의 부분 집합일 수도 있습니다.

**구조 패턴에 대한 논의**

적응자 패턴 대 가교 패턴

- 적응자 패턴과 가교 패턴은 공통점이 많습니다. 둘 다 다른 객체에 대한 직접 접근 대신에 다른 우회적 방법으로 접근하여 유연성을 증대시킵니다.
- 이 두 패턴 간의 가장 큰 차이는 목적이 무엇인가 하는 것입니다. 적응자의 목적은 이미 존재하는 두 인터페이스 간의 불일치를 해결하려는 것입니다. 그러나 적응자 패턴은 어떤 인터페이스를 어떻게 구현하게 할 것인가, 인터페이스와 구현을 독립적으로 발전시키는 방법은 무엇일까 등 사항은 전혀 고려치 않습니다. 이에 반해, 가교 패턴은 추상적 개념과 구현을 따로 만들고, 이를 연결시키려는 것이 주목적입니다. 이로써 시스템이 진화함에 따라서 새로운 구현을 추가할 수 있게 하려는 것입니다.
- 이런 차이로 적응자 패턴과 가교 패턴이 사용되는 소프트웨어 개발 주기 시점이 달라집니다. 적응자는 주로 이미 개발이 완료되어 운영 중인 두 클래스 사이에서 호환되지 않은 부분을 찾았을 때 적용하는 패턴입니다. 이런 두 클래스 간의 종속성을 미리 예측하지 못하고 개발했을 때 필요한 패턴인 것입니다. 그러나 가교 패턴은 이미 사용자가 추상적 개념을 구현하는 방법이 여러 가지이고, 이를 각각 독립적으로 진화할 수 있음을 파악한 상태에서 적용하는 패턴입니다.

복합체 패턴 대 장식자 패턴 대 프록시 패턴

- 복합체 패턴 및 장식자 패턴은 구조가 비슷한데, 이 두 패턴 모두 여러 객체를 조직화하기 위해 재귀적 합성 기법을 사용하기 때문입니다. 이런 구조적 유사성으로 장식자 객체를 약화된 복합 객체로 간주할 수도 있겠지만, 이는 장식자의 중요한 특성을 놓치는 것입니다. 이 두 패턴의 공통성은 구조에서만 나타날 뿐 그 목적은 전혀 다릅니다.
- 장식자 패턴은 상속 없이 객체에 새로운 서비스를 추가하려는 것이 목적입니다. 그러므로 이미 만든 서비스 클래스의 조합이 필요할 때마다 클래스를 생성해야 하는 문제를 해결해야 합니다. 복합체 패턴은 클래스 구조화에 초점을 맞춘 것으로, 어떻게 관련된 객체들을 하나의 인터페이스로 다룰 수 있도록 일관성을 부여할 것인가가 중요한 관건입니다. 즉, 여러 객체들을 하나의 객체로 통일시키고 싶은 것입니다.
- 장식자 패턴과 구조가 비슷한 것이 하나 더 있는데, 바로 프록시 패턴입니다. 두 패턴 모두 다른 객체에 간접적으로 접근할 수 있고, 프록시와 장식자를 구현할 대 메시지를 전달할 상대 객체에 대한 참조자를 관리하는 공통점이 있지만, 두 패턴의 목적은 다릅니다.
- 장식자와 같이 프록시도 객체들을 합성하여 사용자에게는 동일한 인터페이스를 제공합니다. 그러나 프록시는 장식자와 달리 동적으로 어떤 기능성을 추가/제거했다 하지는 않습니다. 프록시의 목적은 서비스를 제공하는 대상에 대한 참조자를 직접 관리하는 불편함을 해결하려는 것입니다.
- 프록시 패턴에서는 프록시가 대리한 주체(subject)가 중요한 실제 기능을 제공합니다. 프록시는 단지 이 기능 제공 주체에 접근할 수 있을 뿐이지만 장식자는 기능적인 일을 담당하기도 합니다. 즉, 구성요소가 일부 기능을 제공하고, 나머지는 하나 이상의 장식자에서 담당하는 것입니다. 장식자를 사용하는 목적은 컴파일 시 모든 서비스 객체를 다 결정할 수 없는 상황에 적절하게 대응하기 위해서입니다. 그렇기 때문에 무한한 객체의 재귀적 합성은 매우 중요한 요소입니다. 그러나 프록시에서는 단순히 메시지를 전달하는 것이므로 재귀적 합성은 전혀 의미가 없습니다.
- 이런 차이는 매우 중요합니다. 구조가 비슷해 보여도 이 패턴은 각기 서로 다른 객체지향 설계의 특정 문제를 해결하려는 목적이 있기 때문입니다. 그렇다고 이들 패턴을 서로 합쳐서 사용할 수 없다는 것은 아닙니다. 프록시 - 장식자 쌍은 프록시에 추가적인 기능을 제공할 수 있고, 장식자 - 프록시 쌍은 원격지에 떨어진 객체에도 새로운 기능을 추가할 수 있게 합니다. 이처럼 패턴의 조합은 매우 유용합니다.

## Chapter5 행동 패턴

- 행동 패턴(behavioral pattern) 은 어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은지, 알고리즘을 어느 객체에 정의하는 것이 좋은지 등을 다룹니다. 응용프로그램에 따라서 행동이 다른 객체로 옮겨가거나 알고리즘이 대체되리 때가 생기기 마련입니다. 이러한 변화의 개념은 만족할 수 있는 것이 행동 패턴입니다. 행동 패턴은 객체나 클래스에 대한 패턴을 정의하는 것이 아니고, 그들 간의 교류 방법에 대하여 정의하는 것입니다. 이러한 패턴은 런타임에 수행하기 어려운 복잡한 제어 구조를 패턴화한 것입니다. 이 행동 패턴을 사용하면 우리는 객체 간의 제어 구조보다는 객체들을 어떻게 연결시킬 것인가에 좀더 중점을 둘 수 있습니다.

- 행동 객체 패턴(behavioral object pattern)은 상속보다는 복합을 통해서 객체 사이에 행동 처리의 책임을 분산합니다. 즉, 하나의 객체가 스스로 모든 처리를 하는 것이 아니라, 관련된 객체들이 하나의 처리를 책임지는 방법입니다. 여기서 중요한 것은 이렇게 관련된 객체들이 서로를 어떻게 알 수 있도록 할 것인가입니다. 만약 이런 객체들의 그룹이 각각 객체에 대한 참조자를 관리해야 한다면, 객체 간의 의존성이 높아집니다. 최악의 상황에서는 각 객체가 관련된 다른 모든 객체를 다 알아야 할 때도 있을 수 있습니다.

**책임 연쇄(Chain of Responsibility)**

메시지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴입니다. 하나의 요청에 대한 처리가 반드시 한 객체에서만 되지 않고, 여러 객체에게 그 처리 기회를 주려는 것입니다.

책임 연쇄 패턴은 다음의 경우에 사용합니다.

- 하나 이상의 객체가 요청을 처리해야 하고, 그 요청 처리자 중 어떤 것이 선행자(priori)인지 모를 때, 처리자가 자동으로 확정되어야 합니다.
- 메시지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶을 때
- 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때

책임 연쇄 패턴은 다음과 같은 장점과 단점이 있습니다.

1. 객체 간의 행동적 결합도가 적어집니다. : 다른 객체가 어떻게 요청을 처리하는지 몰라도 됩니다. 단지 요청을 보내는 객체는 이 메시지가 적절하게 처리될 것이라는 것만 확신하면 됩니다. 메시지를 보내는 측이나 받는 측 모두 서로를 모르고, 또 연결된 객체들조차도 그 연결 구조가 어떻게 되는지 모릅니다. 결과적으로, 이 패턴은 객체들 간의 상호작용 과정을 단순화시킵니다. 객체가 관련된 모든 후보 객체들을 다 알 필요 없이 자신ㅇ느 단순하게 자신과 연결된 단 하나의 후보 객체만 알면 되는 것입니다.
2. 객체에게 책임을 할당하는 데 유연성을 높일 수 있습니다. : 객체의 책임을 여러 객체에게 분산시킬 수 있으므로 런타임에 객체 연결 고리를 변경하거나 추가 하여 책임을 변경하거나 확장할 수 있습니다.
3. 메시지 수신이 보장되지는 않습니다. : 어떤 객체가 이 처리에 대한 수신을 담당한다는 것을 명시하지 않으므로 요청이 처리된다는 보장은 없습니다. 만약 객체들 간의 연결 고리가 잘 정의되지 않았다면, 요청은 처리되지 못한 채로 버려질 수 있습니다.

**명령(Command)**

요청 자체를 캡슐화하는 것입니다. 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기시키거나 로깅하며, 되돌릴 수 있는 연산을 지원합니다.

명령 패턴은 다음과 같은 일을 하고 싶을 때 사용합니다.

- 수행할 동작을 객체로 매개변수화하고자 할 때. 절차지향 프로그램에서는 이를 콜백(callback) 함수, 즉 어딘가 등록되었다가 나중에 호출되는 함수를 사용해서 이러한 매개변수화를 표현할 수 있습니다. 명령 패턴은 콜백을 객체지향 방식으로 나타낸 것입니다.
- 서로 다른 시간에 요청을 명시하고, 저장하며, 실행하고 싶을 때. Command 객체는 원래의 요청과 다른 생명주기(lifetime)가 있습니다. 요청을 받아 처리하는 객체가 주소 지정 방식과는 독립적으로 표현될 수 있다면, Command 객체를 다른 프로세스에게 넘겨주고 거기서 해당 처리를 진행하게 할 수 있습니다.
- 실행 취소 기능을 지원하고 싶을 때. Command와 Execute() 연산은 상태를 저장할 수 있는데, 이를 이용해서 지금까지 얻은 결과를 바꿀 수 있습니다. 이를 위해 Unexecute() 연산을 Command 클래스의 인터페이스에 추가합니다. 실행된 명령어를 모두 기록해 두었다가 이 리스트를 역으로 탐색해서 다시 Unexecute()를 수행하게 합니다. Execute()와 Unexecute() 연산의 반복 사용을 통해 수행과 취소를 무한 반복할 수 있습니다.
- 시스템이 고장 났을 때 재적용이 가능하도록 변경 과정에 대한 로깅을 지원하고 싶을 때. Command 인터페이스를 확장해서 load()와 store() 연산을 정의하면 상태의 변화를 지속적(persistent) 저장소에 저장해 둘 수 있습니다. 시스템 장애가 발생했을 때 해당 저장소에서 저장된 명령어를 읽어 다시 Execute() 연산을 통해 재실행하면 됩니다.
- 기본적인 연산의 조합으로 만든 상위 수준 연산을 써서 시스템을 구조화하고 싶을 때. 정보 시스템의 일반적인 특성은 트랜잭션(transaction)을 처리해야 한다는 것입니다. 트랜잭션은 일련의 관리를 통해 데이털르 변경하는 것인데, Command 패턴은 이런 트랜잭션의 모델링을 가능하게 합니다. Command 클래스는 일관된 인터페이스를 정의하는데, 이로써 모든 트랜잭션이 동일한 방식으로 호출됩니다. 새로운 트랜잭션을 만들면 상속으로 Command 클래스를 확장하면 되므로 시스템 확장도 어렵지 않습니다.

명령 패턴을 사용하여 생기는 결과는 다음과 같습니다.

1. Command는 연산을 호출하는 객체와 연산 수행 방법을 구현하는 객체를 분리합니다.
2. Command는 일급 클래스입니다. 다른 객체와 같은 방식으로 조작되고 확장할 수 있습니다.
3. 명령을 여러 개를 복합해서 복합 명령을 만들 수 있습니다.
4. 새로운 Command 객체를 추가하기가 쉽습니다. 기존 클래스를 변경할 필요 없이 단지 새로운 명령어에 대응하는 클래스만 정의하면 됩니다.


그 외, MacroCommand를 구현하는 데에 복합체 패턴을 사용할 수 있습니다. 취소를 처리할 때 객체의 상태를 관리하는 데에는 메멘토 패턴을 사용할 수 있습니다. 또 명령어가 처리되어 처리된 이력 목록에 저장되기 전에 명령어를 복사해야 한다면 원형 패턴을 사용하면 됩니다.

**해석자(Interpreter)**

어떤 언어에 대해, 그 언어의 문법에 대한 표현을 정의하면서 그것(표현)을 사용하여 해당 언어로 기술된 문장을 해석하는 해석자를 함께 정의합니다.

해석이 필요한 언어가 존재하거나 추상 구문 트리로서 그 언어의 문장을 표현하고자 한다면 해석자 패턴을 사용할 때입니다. 해석자 패턴이 가장 잘 먹힐 때를 정리하면 다음과 같습니다.

- 정의할 언어의 문법이 간단합니다. 문법이 복잡하다면 문법을 정의하는 클래스 계통이 복잡해지고 관리할 수 없게 됩니다. 이는 해석자 패턴을 사용하는 것보다는 파서 생성기와 같은 도구를 이용하는 것이 더 나은 방법입니다. 파서 생성기는 추상 구문 트리를 생성하지 않고도 문장을 해석할 수 있기 때문에, 시간과 공간을 절약할 수 있습니다.
- 효율성은 별로 고려할 사항이 아닙니다. 사실 가장 효율적인 해석자를 구현하는 방법은 파스 트리를 직접 해석하도록 만드는 것이 아니라, 일차적으로 파스 트리를 다른 형태로 번역(translate)시키는 것입니다. 예를 들어, 정규 표현식은 일반적으로 유한 상태 기계(finite state machine) 개념으로 번역합니다. 이때에도 정규 표현식을 유한 상태 기계로 번역하는 번역기를 구현해야 하는데, 역시 해석자 패턴을 사용할 수 있습니다.

해석자 패턴의 장점과 단점을 정리하면 다음과 같습니다.

1. 문법의 변경과 확장이 쉽습니다. : 패턴에서 문법에 정의된 규칙을 클래스로 표현하였기 때문에 문법을 변경하거나 확장하고자 할 때는 상속을 이용하면 됩니다. 확장을 통해 기존의 표현식을 지속적으로 수정하거나 새로운 서브클래스 정의를 통해 새로운 표현식을 정의할 수 있습니다.
2. 문법의 구현이 용이합니다. : 추상 구문 트리의 노드에 해당하는 클래스들은 비슷한 구현 방법을 갖습니다. 이들 클래스를 작성하는 것은 쉬운 일이며, 컴파일러나 파서 생성기를 이용해서 자동 생성할 수도 있습니다.
3. 복잡한 문법은 관리하기 어렵습니다. : 해석자 패턴은 문법에 정의된 각 규칙별로 적어도 하나의 클래스를 정의합니다. BNF로 정의된 문법을 정의하면 훨씬 많은 클래스들을 정의해야 합니다. 그러므로 많은 규칙을 포함하는 문법은 관리/유지하기가 어렵습니다. 이 문제를 해결하기 위해서는 구현 방법에 정의한 다른 패턴을 적용해야 합니다. 문법이 복잡해지면, 컴파일러 생성기나 파서 생성기를 사용하는 것이 바람직합니다.
4. 표현식을 해석하는 새로운 방법을 추가할 수 있습니다. : 해석자 패턴은 새로운 방식으로 정의된 표현식을 쉽게 해석할 수 있게 해 줍니다. 예를 들어, 줄을 잘 맞춘 출력 방식이나 타입 점검을 지원하려면 새로운 연산만 정의하면 됩니다. 이렇게 새로운 방식으로 해석하는 방법을 계속 추가해야 한다면 문법 클래스 변경을 피하기 위해 방문자 패턴을 이용하는 것이 좋습니다.

추상 구문 트리는 복합체 패턴의 한 인스턴스로 볼 수 있습니다. 하나의 구문 트리 내에 터미널 기호를 여러 개 공유하기 위해서는 플라이급 패턴을 적용할 수 있습니다. 해석자는 반복자 패턴을 이용해서 자신의 구조를 순회합니다. 방문자 패턴을 이용하면 하나의 클래스에 정의된 구문 트리 각 노드에 대한 상태를 관리할 수 있습니다.

**반복자(Iterator)**

내부 표현부를 노출하지 않고 어떤 집합 객체에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공합니다.

반복자 패턴은 이런 목적에 사용합니다.

- 객체 내부 표현 방식을 모르고도 집합 객체의 각 원소들에 접근하고 싶을 때
- 집합 객체를 순회하는 다양한 방법을 지원하고 싶을 때
- 서로 다른 집합 객체 구조에 대해서도 동일한 방법으로 순회하고 싶을 때

반복자 패턴의 주요 특징을 세 가지로 정리할 수 있습니다.

1. 집합 객체의 다양한 순회 방법을 제공합니다. : 구조가 복잡한 집합 객체는 다양한 방법으로 순회할 수 있습니다. 이를테면, 컴파일러에서 코드 생성 및 의미 점검(semantic checking)을 진행하려면 파스 트리를 순회해야 합니다. 코드를 생성하기 위해 트리를 순회할 때 중위 순회 방식이나 전위 순회 방식을 사용할 수 있습니다. 이때, Iterator는 순회 알고리즘을 바꿀 수 있도록 합니다. 즉, 새로운 순회 방법을 Iterator 서브클래스로 정의하여 기존 순회 방법을 다른 순회 알고리즘 인스턴스로 완전히 교체하는 것입니다.
2. 반복자는 Aggregate 클래스의 인터페이스를 단순화합니다. : 반복자의 순회 인터페이스는 Aggregate 클래스에 정의한 자신과 비슷한 인터페이스들을 없애서 Aggregate 인터페이스를 단순화할 수 있습니다.
3. 집합 객체에 따라 하나 이상의 순회 방법이 제공될 수 있습니다. : 각 반복자마다 자신의 순회 상태가 있으므로 하나의 집합 객체를 한번에 여러 번 순회시킬 수 있습니다.

반복자 패턴은 복합체 패턴과 같이 재귀적 구조가 있을 때 자주 사용합니다. 다양한 반복자를 사용해서 적당한 Iterator 서브클래스를 얻으려면 팩토리 메서드 패턴을 사용할 수 있습니다. 메멘토 패턴도 반복자 패턴과 함께 자주 사용하는데, 이때 반복자 자신이 반복한 결과를 저장하기 위해서 메멘토를 사용합니다.

**중재자(Mediator)**

한 집합에 속해있는 객체의 상호작용을 캡슐화하는 객체를 정의합니다. 객체들이 직접 서로를 참조하지 않도록 하여 객체 사이의 소결합(loose coupling)을 촉진시키며, 개발자가 객체의 상호작용을 독립적으로 다양화시킬 수 있게 만듭니다.


중재자 패턴은 다음의 경우에 사용합니다.

- 여러 객체가 잘 정의된 형태이기는 하지만 복잡한 상호작용을 가질 때 객체 간의 의존성이 잘 구조화되지 않으며, 잘 이해하기 어려울 때
- 한 객체가 다른 객체를 너무 많이 참조하고, 너무 많은 의사소통을 수행해서 그 객체를 재사용하기 힘들 때
- 여러 클래스에 분산된 행동들이 상속 없이 상황에 맞게 수정되어야 할 때

중재자 패턴에는 다음과 같은 장단점이 있습니다.

1. 서브클래싱을 제한합니다. : 중재자는 다른 객체 사이에 분산된 객체의 행동들을 하나의 객체로 국한합니다. 이 행동을 변경하고자 한다면 Mediator 클래스를 상속하는 서브클래스를 만들면 됩니다. Colleague 클래스는 여전히 재사용 가능합니다.
2. Colleague 객체 사이의 종속성을 줄입니다. : 중재자는 행동에 참여하는 객체간의 소결합을 증진시킵니다. 이로써 Mediator 클래스와 Colleague 클래스 각각을 독립적으로 다양화시킬 수 있고 재사용할 수 있습니다.
3. 객체 프로토콜을 단순화합니다. : 중재자는 다 대 다의 관계를 일 대 다의 관계로 축소시킵니다. 일 대 다의 관계가 훨씬 이해하기 쉬울 뿐만 아니라 유지하거나 확장하기 쉽습니다.
4. 객체 간의 협력 방법을 추상화합니다. : 객체 사이의 중재를 독립적인 개념으로 만들고 이것을 캡슐화함으로써, 사용자는 각 객체의 행동과 상관없이 객체간 연결 방법에만 집중할 수 있습니다. 결과적으로, 시스템에서 객체가 어떻게 동작하는지를 좀더 명확히 하는 데 도움이 됩니다.
5. 통제가 집중화됩니다. : 중재자 패턴은 상호작용의 복잡한 모든 것들이 자신 내부에서만 오가게 합니다. 중재자 객체는 동료 객체 간의 상호작용에 관련된 프로토콜을 모두 캡슐화하기 대문에 어느 동료 객체보다도 훨씬 복잡해질 수 있습니다. 이 때문에 Mediator 클래스 자체의 유지보수가 어려워지게 될 때도 있습니다.

관련 패턴

- 퍼사드 패턴은 객체들로 구성된 서브시스템을 추상화하여 좀더 편한 인터페이스를 제공하려는 것으로 중재자 패턴과는 좀 다릅니다. Facade 객체는 서브시스템을 구성하는 객체로만 메시지가 전달되고 그 반대로-서브시스템을 구성하는 객체가 퍼사드 객체에 메시지 전달-는 메시지 처리가 되지 않습니다. 그러나 중재자 객체는 양방향입니다.
- 상호 관련된 객체들은 감시자 패턴을 이용해서 중재자 객체들과 교류합니다.

**메멘토(Memento)**

캡슐화를 위배하지 않은 채 어떤 객체의 내부 상태를 잡아내고 실체화시켜 둠으로써, 이후 해당 객체가 그 상태로 되돌아올 수 있도록 합니다.

메멘토 패턴은 다음의 경우에 사용합니다.

- 어떤 객체의 상태에 대한 스냅샷(몇 개의 일부)을 저장한 후 나중에 이 상태를 복구해야 할 때
- 상태를 얻는 데 필요한 직접적인 인터페이스를 두면 그 객체의 구현 세부사항이 드러날 수밖에 없고, 이것으로 객체의 캡슐화가 깨질 때

메멘토 패턴을 사용했을 때의 결과는 다음과 같습니다.

1. 캡슐화된 경계를 유지할 수 있습니다. : 원조본만 메멘토를 다룰 수 있기 때문에 메멘토가 외부에 노출되지 않습니다. 이 패턴은 복잡한 Originator 클래스의 내부 상태를 다른 객체로 분리하는 방법으로 상태에 대한 정보의 캡슐화를 보장합니다.
2. Originator 클래스를 단순화할 수 있습니다. : 다른 방법으로 캡슐화를 유지하는 설계 방법에서는 Originator가 다양한 버전의 내부 상태를 모두 저장해야 사용자의 요청에 대응할 수 있었습니다. 사용자가 자신들이 필요한 상태를 별도로 관리하게 하면 Originator 클래스는 간단해지고, 상태를 변경할 때마다 사용자가 이를 원조본에 알려줄 필요도 없습니다.
3. 메멘토의 사용으로 더 많은 비용이 들어갈 수도 있습니다. : Originator 클래스가 많은 양의 정보를 저장해야 할 때나 상당히 자주 메멘토를 반환해야 할 때라면 메멘토가 상당한 오버헤드를 가져올 수 있습니다. Originator 클래스의 상태를 보호하는 비용과 상태 복구의 비용이 싸지 않으면, 메멘토 패턴은 적합하지 않습니다.
4. 제한 범위 인터페이스와 광범위 인터페이스를 정의해야 합니다. : 어떤 프로그래밍 언어에서는 원조본 객체만 메멘토의 상태에 접근할 수 있도록 보장하기가 힘들 수도 있습니다.
5. 메멘토를 관리하는 데 필요한 비용이 숨어있습니다. : 보관자 객체는 자신이 보관하는 메멘토를 삭제할 책임이 있습니다. 그러나 보관자 쪽에서는 얼마나 많은 상태가 메멘토에 저장되었는지 알 방법이 없습니다. 그러므로 보관자 객체가 아무리 가볍다 해도 메멘토를 저장할 때 적지 않은 비용을 유발할 수도 있습니다.

관련 패턴

- 명령 패턴은 실행 취소가 가능한 연산의 상태를 저장할 때 메멘토 패턴을 사용할 수 있습니다. 메멘토 패턴은 반복자 패턴에서의 반복 과정 상태를 관리할 수 있습니다.