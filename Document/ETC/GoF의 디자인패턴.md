# GoF의 디자인 패턴

![](Image/2022-02-03-10-29-05.png)

## 요약

**생성 패턴(Creational Patterns)**

- 추상 팩토리(Abstract Factory) : 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴입니다.
- 빌더(Builder) : 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴입니다.
- 팩토리 메서드(Factory Method) : 객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브클래스 쪽에서 내리는 패턴입니다. 팩토리 메서드 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브클래스로 미룹니다.
- 원형(Prototype) : 생성할 객체의 종류를 명세하는 데에 원형이 되는 예시물을 이용하고, 그 원형을 복사함으로써 새로운 객체를 생성하는 패턴입니다.
- 단일체(Singleton) : 어떤 클래스의 인스턴스는 오직 하나임을 보장하며, 이 인스턴스에 접근할 수 있는 전역적인 접촉점을 제공하는 패턴입니다.

**구조 패턴(Structural Patterns)**

- 적응자(Adapter) : 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해 줍니다.
- 가교(Bridge) : 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴입니다.
- 복합체(Composite) : 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 합니다.
- 장식자(Decorator) : 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있습니다.
- 파사드(Facade) : 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴으로, 서브시스템을 좀더 사용하기 편하게 만드는 상위 수준의 인터페이스를 정의합니다.
- 플라이급(Flyweight) : 크기가 작은 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴입니다.
- 프록시(Proxy) : 어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자(surrogate) 또는 자리 채움자(placeholder)를 제공하는 패턴입니다.

**행동 패턴(Behavioral Patterns)**

- 책임 연쇄(Chain of Responsibility) : 요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여하여 요청을 보내는 객체와 그 요청을 받는 객체 사이의 결합을 피하는 패턴입니다. 요청을 받을 수 있는 객체를 연쇄적으로 묶고, 실제 요청을 처리할 객체를 만날 때까지 객체 고리를 따라서 요청을 전달합니다.
- 명령(Command) : 요청을 객체의 형태로 캡슐화하여 서로 요청이 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 그리고 연산의 취소를 지원하게 만드는 패터입니다.
- 해석자(Interpreter) : 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 이와 아울러 그 표현 수단을 사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴입니다.
- 반복자(Iterator) : 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴입니다.
- 중재자(Mediator) : 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체를 정하는 패턴입니다. 객체들이 직접 서로를 참조하지 않도록 함으로써 객체들 사이의 소결합(loose coupling)을 촉진시키며, 개발자가 객체들의 상호작용을 독립적으로 다양화시킬 수 있게 만듭니다.
- 메멘토(Memento) : 캡슐화를 위배하지 않은 채로 어떤 객체의 내부 상태를 잡아내고 실체화시켜, 이후에 해당 객체가 그 상태로 되돌아올 수 있도록 하는 패턴입니다.
- 감시자(Observer) : 객체들 사이에 일 대 다의 의존관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그  객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴입니다.
- 상태(State) : 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼 보입니다.
- 전략(Strategy) : 동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하며, 이들을 상호 교환이 가능하도록 만드는 패턴입니다. 알고리즘을 사용하는 사용자와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 합니다.
- 템플릿 메서드(Template Method) : 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미루는 패턴입니다. 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단게의 처리를 서브클래스에서 재정의할 수 있게 합니다.
- 방문자(Visitor) : 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 합니다.

## Chapter 1 서론

- 이 책에서 이야기하는 디자인 패턴은 "**특정한 전후 관계에서 일반적 설계 문제를 해결하기 위해 상호교류하는 수정 가능한 객체와 클래스들에 대한 설명**" 입니다.
  - 하나의 디자인 패턴은 재사용 가능한 객체지향 설계를 만들기 위해 유용한 공통의 설계 구조에서 주요 요소들을 식별하여 이들에게 적당한 이름을 주고 추상화합니다. 그리고 패턴에 참여하는 클래스와 그들의 인스턴스를 식별하여 역할과 그들 간의 협력 관계를 정의하고 책임을 할당합니다. 각 디자인 패턴은 각자 맡은 객체지향 설계 문제에 집중합니다. 언제 패턴을 적용할지, 다른 설계 제약을 고려하여 패턴을 적용할 수 있는지, 패턴을 사용하면 어떤 결과가 발생하는지도 친절히 설명합니다.

<br>

- 초보자들은 너무 많은 개념과 이를 실행할 수 있는 다양한 방법론에 당황해서, 자신들이 전에 사용했던 객체지향 기술이 아닌 쪽으로 다시 되돌아갈 수 있습니다. 초보자들은 "좋은 객체지향 설계란 무엇일까요?"를 이해하는 데만도 꽤 오랜 시간이 걸립니다.
- 전문가들은 초보자들처럼 모든 문제를 처음 기초 단계에서부터 해결하려고 하지 않습니다. 대신, 전에 사용했던 해결책을 다시 사용해 봅니다. 그리고 좋은 방법을 찾아냈다면 그 방법을 반복해서 계속 사용하게 됩니다. 이런 경험을 통해 전문가가 만들어지고, 결국에는 많은 객체지향 시슽메에서 클래스 패턴이나 객체들 간의 상호작용 방식이 반복됨을 알게 됩니다. 이런 반복된 패턴들은 특정 설계의 문제점들을 해결해 주고, 좀더 근사하며, 재사용 가능한 객체지향 소프트웨어를 만들어 줍니다.
- 디자인 패턴을 이용하면 좋은 설계나 아키텍처를 재사용하기 쉬워집니다. 입증된 기술을 디자인 패턴으로 표현해 두면 새로운 시스템 개발자들은 디자인 패턴을 더 자주 유용하게 사용할 수 있습니다. 디자인 패턴은 설계자로 하여금 재사용이 가능한 설계는 선택하고, 재사용을 방해하는 설계는 배제하도록 도와줍니다. 또한 패턴을 쓰면 이미 만든 시스템의 유지보수나 문서화도 개선할 수 있고, 클래스의 명세도 정확하게 할 수 있으며, 객체 간의 상호작용 또는 설계의 의도 등까지 명확하게 정의할 수 있습니다. 간단하게 말해서, 디자인 패턴은 설계자들이 "올바른" 설계를 빨리 만들 수 있도록 도와줍니다.

- 일반적으로 하나의 패턴에는 다음의 네 가지 요소가 반드시 들어 있습니다.
  - 패턴 이름(pattern name)
  - 문제(problem)
  - 해법(solution)
  - 결과(consequence)