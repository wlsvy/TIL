# AtDevcat

## 22/08/31

처음으로 업무 일지 기록 시작합니다.

최근 서버 측 GameServer의 Channel Update가 aws ec2 인스턴스에서 실행 시 공회전 하는 현상이 있었다. 너무 상식 밖의 현상이거니와 팀장님이 체크해봤을 때 발생 원인도 구체화하지 못했다.

게임서버의 다수의 채널 업데이트는 병렬 처리된다. C# Task 에 할당되게 되는데, 어찌 된 일인지 실행되어야 할 태스크 중 일부가 놀고 있다. 게임 서버의 프레임 배리어는 모든 채널이 업데이트 되기 전에는 해당 프레임을 유지하고 다음 프레임으로 넘어가지 못하도록 막는다. 몇 개 태스크가 먹통이 되니 다른 정상적인 채널들이 배리어에 걸려 다음 프레임으로 넘어가지 못하고 있었다.

어느 때와 같은 환경이었을 텐데 갑자기 왜 이런 일이 벌어진 걸까... 결국 채널 업데이트 시에는 Task 대신 Thread를 직접 조작하는 방식으로 수정되었다. (C# ThreadPool의 Task 할당/처리 지원을 포기하고 Thread를 직접 조작하게 되면 어느 정도 성능상의 이점을 포기하는 셈이지만, 프로그래머가 직접 관리하는 수행흐름은 상태 추적이 쉽고 디버깅이 유리하다.)

## 22/09/01

프레임 배리어... 프레임 동작을 처리하는 수행 흐름이 중간에 오류가 발생해서 스택이 되감긴다. 예외를 catch한 쪽에서는 수행 흐름이 끊긴 시점이 어딘지, 프레임 배리어 안인지 밖인지 알 수 없다. 이 경우에는 어떻게 처리해야 할까??

당연히 프레임 배리어 안에서 발생할 수 있는 예외는 가능한 한 막아두었다. 그 외에 코드에서는 언뜻 보기에 예외가 발생할 수 있는 상황이 있을까 싶을 정도로 꼼꼼히 짜두었다. 정말 RAM이 꽉 차지 않는 이상 뭐가 터질 수 있나 싶을 정도로. 그렇지만 C# 을 사용하다 보면 절대 안심할 수 없다더라.

## 22/09/02

MM 서버 모니터링 도구로는 [Grafana](https://grafana.com/) 를 사용합니다.

에러 리포트 용 서버를 따로 올리고, 주기적으로 수집한 오류를 요약해서 팀즈로 보고합니다. 팀즈로 보고할 때는 [Incoming WebHook](https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/add-incoming-webhook)을 사용합니다.

- [MessageCard PlayGround](https://messagecardplayground.azurewebsites.net/)

## 22/09/14

게임 실행 전에 패치 데이터 다운로드 속도가 150Mbps 를 넘지 못해서 기술실에서 잠시 소동이 있었는데, 알고보니 사내 wifi 의 최대 속도가 150Mbps로 제한되어 있었다. 인터넷 기사 아저씨가 사기 친 것이었다....

서버 프로그래밍 상에서 두려운 일 몇 가지 중에 하나는 아마 서버 프로세스의 어딘가가 잘못 되어서 디바이스의 메모리나 cpu 자원을 쥐도 새도 모르게 잠식해버리는 것이다... 그래서 디바이스 모니터링이 필수고 만약에 사태에 대비해 서버 머신을 분리하는 것이 아닐까
(사실 오늘 무한 루프가 발생하자 서버가 머신 cpu를 다 먹어버리고 드러누워버리는 현상이 있었다)

간헐적으로 실패하는 테스트. 중요한 빌드 파이프라인에서 테스트가 실패하면 노티 메세지가 개발실로 전달된다. 간헐적으로 실패하는 테스트들 그 중에서도 당장 해결하기는 까다로운 것들이 여기서 문제가 됬는데, 이런 실패 메세지를 자꾸 보게 되는 사람들이 경각심을 잃어버린다는 것이다. 신뢰를 잃어버리는 것이 가장 큰 문제다.

- 이런 테스트들은 분류를 따로 해야 하는 걸까?? '가끔 고장나는 골칫덩이들' 묶음을 만들고선 실패 횟수를 카운트해서 주기적으로 노티하는 방식은 어떨까?

## 22/09/16

밤새고 난 다음날은 업무를 거의 못했다. 커피나 에너지 드링크 좀 마시면 기운 낼 수 있지 않을까 싶은데 역부족이었다. 정말 잠이 쏟아진다.

서버 내 몬스터 생성 시스템이 고장 나서 수만 마리가 서버에 스폰되었는데, 서버 프로세스가 머신 cpu 를 100% 먹어버려서 문제가 되었다. cpu가 잠식되버려서 원격에서 서버를 강제 종료 시키는 것도 까다롭다.

## 22/09/19

오늘은 깃랩GitLab 이 느려서 많은 사람들이 불편을 느낀 날. 음... 인프라 이슈일 수 있고, 트래픽 이슈일 수 있고 ( 그날 따라 신규 입사자가 많아서 프로젝트 전체 풀 받는다던가), 프로젝트 사이즈 이슈도 고려해봄 직 하다. 아니다. 프로젝트 사이즈가 문제라면 특정한 날에 갑자기 문제가 발견되는 게 아니라 점진적으로 증상이 관측되었어야 한다. 또 뭐가 있을까? 갑자기 프로젝트에 큰 파일이 올라온다?? 이것도 아닐테지.

## 22/09/20

큰 규모의 마일스톤 작업이 마감되는 날이다. 우리 프로젝트는 메인 트렁크에 모든 작업자의 작업물이 올라오는데, 트렁크를 동결시키고 작업자 여러분들의 메인 브랜치 머지를 막고 싶지만 그게 잘 안되고 있다. ㅎ하하하. 형상 관리 작업을 지원하는 서버(merge Cat)에서 따로 동결 시기에 머지 요청을 막는 기능은 없다. (사실 있어야 할 정도로 중요한 기능이 아니긴 하다.)

## 22/09/21

MySql 에 쌓인 게임 에러리포트 1억개를 지우자. 그냥 Delete 명령어를 사용하니 너무 느리더라. 문제의 1억개 데이터 중에는 stacktrace 컬럼이 있고 가변 문자열이다. 아마 파편화가 상당히 진행됬을터다.

MySql 에서는 대량의 데이터를 갱신할 때, 데이터 사본을 먼저 만든 뒤 사본에다가 쿼리를 수행하는 방식이라 한다. 그렇다면 원본 데이터에다가 사본을 덮어씌우도록 동작할 것이다. 그러니 delete 를 사용하기는 까다로운 조건이었다. 에러리포터 서버는 상시 리포트를 받아서 DB 에 추가하기 때문에 라이트 락 경합을 피할 수 없다.

테이블 통째로 truncate 하기로 했다. drop table 과 마찬가진데 mysql 내부에서는 테이블 포인터를 비어있는 테이블로 바꿔치기 하고는 실 데이터는 나중에 차근차근 지워가는지 명령이 즉각 수행되더라. (만약에 남겨야 할 데이터가 있다면, 해당 데이터만 복사 -> 기존 테이블 truncate -> 복사한 데이터를 다시 insert 하는 방식이라면 해결됬을 것이다.)

## 22/09/22

프로젝트 용량이 200GB 에 육박한다. 빌드 대역을 여러 개 관리한다면 1TB 는 금방이다. 오늘은 빌드 머신이 용량 부족으로 드러누웠다 ㅠㅠ 매번 대역 늘릴 때마다 겪게 될 일인데 이럴 때는 해결책이 뭐가 있을까??

1. 머신 용량을 추가 확보
2. git partial clone : 과거 깃 히스토리 중 필요한 것만 선택적으로 내려받는다. 이를 테면 과거의 큰 용량의 파일이 추가되었다가 과거에 제거되었다면 해당 파일의 정보까지 현재 작업환경에서 내려받을 필요는 없을 것이다.

## 22/09/23

매일 쓸 생각은 없었는데 이슈가 하루가 멀다하고 생겨나고 있다.

aws 관련 테라폼 설정을 잘못 만졌다가 AMI(Amazon Machine Image)가 변경되었고 테라폼 코드가 관리하고 있던 전체 인스턴스에 영향이 가버렸다.

일부 인스턴스는 AMI 변경 무시 설정이 있어서 다행히 별 이상이 없었지만은 다른 일부 인스턴스는 완전히 교체되어버렸다. 내부 보관하던 데이터가 전부 날아가버린 셈.

인프라는 변경 내역을 항상 꼼꼼히 살펴야 하는 게 맞다... 사람의 손을 떠나 자동화가 처음 시작되는 곳이니 이곳에서 발생하는 휴먼에러까지 막기는 어렵겠지??

## 22/09/27

프로젝트 형상 관리 툴로 Gitlab을 사용하는데 속도가 느리다. 데브캣만 사용하는게 아니라 넥슨 포함 다른 계열사에서도 사용하는 서비스이기 때문에,

참다 못해서 gitLab 서버를 독립하기로 결정. 프로젝트 저장소를 이주한다.

![](GitlabServerExodus.png)

## 22/10/07

갤럭시의 GOS(Game Optimizing Service) 덕분에 기기들이 성능 제한 당하고 있다. 게임 플레이가 어려울 정도로 프레임이 나오지 않고 있다. 해상도/cpu 클럭/gpu 클럭/ 소리/ 밝기 까지 전부 제한된다고 하니 소비자 입장에서는 좋은 기기를 구매했어도 쾌적한 경험을 누릴 수가 없다.

[유니티에서 Samsung AdaptivePerformance를 적용하면 GOS를 해제할 수 있다는 말이 있다.](https://docs.unity3d.com/Packages/com.unity.adaptiveperformance@4.0/manual/user-guide.html)

[삼성 FAQs](https://developer.samsung.com/galaxy-gamedev/ap-userguide/faq_kor.html#:~:text=Adaptive%20Performance%20%EC%A7%80%EC%9B%90%20%EB%8B%A8%EB%A7%90%EC%9D%B4,%EB%8B%A8%EB%A7%90%EC%97%90%EC%84%9C%EB%8A%94%20%EB%8C%80%EB%B6%80%EB%B6%84%20%EC%A7%80%EC%9B%90%ED%95%A9%EB%8B%88%EB%8B%A4)

## 22/10/11

.NET이 제공하는 API로 만든 Windows Service 프로젝트에서 빌드된 프로젝트를 참조하여 진입점(main)을 직접 호출한다. 그런데 프로세스의 stdout, stderr 등이 그대로 유실되는데 이것이 문제

- 프로젝트를 WindowService 형태로 구동하면서 stdout/stderr를 유실하지 않게끔 하는 방법을 찾아야 하는데 [nssm](https://nssm.cc/) 이라는 도구가 있다. 프로세스 우아한 종료, 표준출력 로그 및 로그 파일 로테이션, 자동 재시작 등 다양한 기능을 제공한다.

## 22/10/12

유니티의 IL2CPP(Intermediate Launguage to C++)

IL은 코드를 컴파일해서 기계어에 가깝지만 특정 CPU에 의존적이지 않은 중간단계의 언어를 생성합니다만은, 이 IL은 IOS 애플리케이션에서 막혀있는 상태다. (JIT를 지원하지 않는다)

C#으로 만든 프로그램을 IOS에서 돌리려면 인터프리팅 해야해서 느리니까 유니티는 모바일 빌드를 뽑을 때 IL을 C++ 로 번역한답니다.

문제는 IL2CPP는 C# 동작을 과도하게 기계적으로 해석했다는 것이고요. 예를 들어 static 필드 초기화가 있는 클래스의 static 메서드에는 첫머리마다 '이 클래스가 초기화되어있지 않으면 초기화하자' 라는 코드가 적혀있다고 합니다.
- 쓸데없는 명령을 거치기 때문에 인스트럭션 캐시 손해를 보고
- 전역변수 포인터, 그리고 그것이 가리키는 객체의 has_ctor와 is_ctor_finished를 건드려서 캐시 미스가 납니다.

프로그램을 시작할 때 static 필드 초기화를 미리 진행한다면, 그런 코드는 필요가 없겠죠.

+ `Dictionary<int, *>` 보다 `Dictionary<string, *>` 가 20배 느리다고 하더라. 클라이언트 최적화 과정에서 지적되는 병목점
+ IL2CPP 환경을 매번 체크해야 해서 골치가 아프다.

## 22/10/13

에러리포터에는 하루 수십만 건의 리포트가 제보된다. 과거 프로젝트에서 비슷하게 센트리를 활용하던 시절에는, 들어오는 데이터 양이 많아지면 그대로 서버 유지 비용에 반영된다는데... 과거에는 이를 대비한 구현이 따로 있었던 듯 하다.

## 22/10/14

네트워크 레이턴시 대응.

크게 볼 때 두 가지 대응 방향이 있다.

1. 동기화 값 보간 (Interpolation) : 패킷은 네트워크 상황에 따라 뚝뚝 끊어져 날아올 수 있다. 비연속적인 상태를 보간해서 클라아언트 상에서는 연속적인 값 변화 상태를 보여준다.
2. 예측 (Extrapolation) : 어떤 물체가 한 방향으로 움직이고 있을 때, 클라이언트는 앞으로 짧은 시간동안 그 물체가 가던 방향 그대로 이동하고 있을 것이라고 예상할 수 있다. 클라이언트는 통계에 근거해 서버의 다음 업데이트 틱에 예상치를 사용한다.

## 22/10/17

주말에 판교 sk 데이터 센터에서 불이 나서 카카오 계열 서비스가 완전히 먹통이 되버리는 대사건이 있었다. 같은 데이터 센터를 사용하고 있다는 네이버는 화재 이후 얼마 지나지 않아 서비스가 복구 됐지만 카카오는 장장 8시간이 지나서야 일부 서비스를 겨우 복구 시켰을 뿐이고 완전 복구까지는 하루가 넘게 걸렸다.

그리고 오늘, 카카오는 지옥같은 월요일을 맛보고 있다. 개장과 함께 카카오 주식은 10% 가까이 추락했고, 몸값 비싼 개발자들을 데려다가 서비스 안전성 관리는 어떻게 하고 있냐는 비아냥에, 카카오 그룹 전 의장인 김범수가 국정감사에 출석요구를 받게되질 않나 경쟁사들은 이때다 싶어 자사 메신저를 광고하고 있다.

우리 프로젝트에서도 메신저 서버 안전성 관련 토론장이 열렸다.

## 22/10/19

- [액체괴물 ASMR #38 - 편안한 슬라임 영상 모음](https://youtu.be/wYZBKu1C6yI)

대표님이 게임 사운드 이펙트 디렉션 하시는 중 참고자료로 링크 걸어둔 영상이다.

게임 디렉션 하는 것을 보다 보면 조금 무섭기도 하다. 백엔드 로직, 보상 심리, 비쥬얼 적인 텍스쳐, 사운드의 질감 어디까지 봐야 되는 걸까. 너무 방대해서 자기 생활을 잃어버리는 건 아닐지 걱정이 들 정도다.


## 22/10/21

레이턴시 테스트 중 발생한 문제들. 네트워크 환경은 서버에서 중요하게 다뤄야 할 변수다. 최근에서야 레이턴스 테스트를 해보면서 클라이언트 측에 부작용이 발생하는 것을 파악했는데, 레이턴시 테스트는 좀 더 이르게 확인했어야 했나 싶다.

그렇지만 테스트를 한다고 할 때 자동화는 어렵다. 런칭 전 개발 시기에는 게임 플레이 시퀀스가 자꾸 변해서 테스트 범위을 정의하기가 어렵고 서버 프로토콜이나 클라 측 인터페이스가 언제 어떻게 변할지 예측할 수 없다. 음... 이제서야 레이턴시 취약점이 발견된 것을 너무 문제 삼는 것은 너무 과한 지적일까?

개발 과정에서 중간중간 주기적으로 레이턴시 안정성 체크해 줬어도 좋았을 것이다. 어려울 것 없다. 이번 네트워크 레이턴시 테스트에서는 요 툴을 사용했다. [Clumsy](https://jagt.github.io/clumsy/)

## 22/10/26

메이플 스토리 같은 경우는 이벤트 기간에 DB 응답 시간이 1시간 까지 지연되는 케이스가 있다고 한다. 인프라 조직에서 DB 응답성은 굉장히 예민한 주제라서 우리 서버 팀에게도 이런 저런 요구사항이 밀려오는 모양이다. 트래픽이 몰리는 상황에서도 최대한 빨리 대응할 수 있어야 한다. 캐시 효율을 최대한 높여야 할 것이다.

- 카카오에서는 모든 DB 마다 캐시를 달아놓는다고 한다. 적어도 우리 서버에서는 계정 접속 관련한 DB 요청에는 이런 처리가 들어가야 하지 않을까... 아니다. 첫 로그인 시점에서는 계정 정보를 캐싱한다는 게 어려울 수 있겠구나.

- 지스타에 작품 출품할 때에는 별의 별 상황이 다 있다고 한다. 보안문제가 대표적이다. 시연 기기에서는 와이파이를 차단해버리고서는 시연 기기들은 폐쇄망에 배포된 서버에 접속하게 하거나, 심지어는 기기마다 자체적으로 로컬 서버를 돌리고서는 룩백 ip로 서버 접속했다고 한다...

## 22/10/27

가끔 이름을 고민할 땐 대상의 성질이 아니라, 대상을 대하는 주체의 태도를 고려하는 것이 좋을 수 있다.

## 22/10/31

중간 상태를 주의하자. 클래스 타입 네이밍을 결정할 때, 약점이 있다면 숨기지 말고 드러내자. 만약 자기 완결성을 보장하지 못하는 객체가 거짓 네이밍으로 작업자를 속인 때, 여러 사람을 고생시킬 가장 쓰라린 버그가 나타난다.

## 22/11/01

서버-클라 이동 동기화 전략 Interpolation / Extrapolation 기법 중, Interpolation 전략이 프로젝트에서 사용되기로 채택되었다. (액터 간 충돌처리를 연산하기 위해서)

이런 내삽 동기화(Interpolation 동기화를 프로젝트 내부 용어로) 기법의 문제점은 서버와 클라의 위치 동기화 과정 중 차이가 발생할 수 있는 것이고, 이것을 극복하고자 점진적으로 동기화 위치로 슬슬 맞춰가는 지연 처리 과정이 있다. 

더 큰 문제점은 내삽 동기화의 기술적 맥락을 컨텐츠 기획자/개발자가 사전에 인지하고 있어야 한다는 것이다. 작업 중인 컨텐츠가 이동 기능을 베이스로 깔고 있다면!! 물론 스킬이나 자동 이동 부터 시작해서 이동 시스템은 모든 컨텐츠에서 한 부분을 차지하고 있다. 물론 작업자들이 이런 깊은 부분까지 인지하고 있을 리 없다!! 당연히 버그는 하루가 지나기 무섭게 터져나온다. 

아이러니하게도 이런 약점을 지적하면서 내삽 동기화를 반대했던 개발자에게 이동 버그 일감이 쏟아지는 중이다 ㅠㅠ

## 22/11/04

- 멀티스레딩 코드를 짤 때는 스레드를 잘 재울 줄도 알아야 한다. 너무 열심히 일 시키면 CPU를 잠식해버릴 수 있다. 그렇게 된다면 다른 스레드가 자기 할 일을 못하고 컴퓨터가 열을 낸다.
- 사내테스트 중... 클라이언트 메모리 이슈가 있어서 모바일 기기는 아이폰 프로 말고는 사용하지 말라는 지침이 있다....
- 클라이언트 UI 이벤트에서 타이밍 문제가 발생했다. 로그인 버튼을 누른 뒤에 서버로 로그인 요청을 보내게 되는데, 로그인 요청을 동시에 여러 개를 보낼 이유는 없으니 한번 누른 버튼을 또 누르지 않게끔 락을 걸어야 한다.
  - ui 이벤트는 큐를 거쳐서 지연 처리되고 있는데 락 거는 시점이 이벤트 지연 처리될 때이다. 그러니 로그인 버튼을 동시에 따닥 연타했을 때 운이 나쁘다면 서버로 로그인 요청을 두 번 보내서 말썽을 일으키게 된다.
- 과거 클라이언트 프로파일링을 진행하면서 화면에 다수의 캐릭터가 있을 때 메모리 점유정도를 측정했는데, 시연기기 기준 화면에 캐릭터 10명이 넘어가면 메모리 크래시가 발생하는 모양이다. 그래서 서버팀에게 미션이 내려왔는데, 채널에 캐릭터를 분배할 때 가급적이면 미리 결정된 정원 수 (10명)을 넘기지 않게끔 조치하는 것

## 22/11/07

- .NET 의 시스템 타이머는 15.6msec 마다 운영체제로 부터 인터럽트를 받는다. 즉... 1msec 단위의 해상도가 필요하다면 큰 곤란을 겪게 될 것이라는 것...

- [AutoResetEvent.WaitOne Intervals](https://social.msdn.microsoft.com/Forums/vstudio/en-US/2befa8c3-7be6-48ca-b999-46697c78d55b/autoreseteventwaitone-intervals?forum=vbgeneral)
- 윈도우 환경이라면 일단 대안이 있다. [how to set timer resolution from C# to 1 ms?](https://stackoverflow.com/questions/15071359/how-to-set-timer-resolution-from-c-sharp-to-1-ms)
- 리눅스라면 커널 옵션을 수정할 수 있다고 한다.

## 22/11/08

- [Change assembly name](https://answers.unity.com/questions/1200398/change-assembly-name.html)
- 유니티의 어셈블리 이름 (Assembly-CSharp)을 수정하는 방법. 참 보면서 어떻게 바꾸는 건가 싶었다.

## 22/11/11

- 서버가 cpu를 많이 잡아먹는다. 전사테스트 당시 200 여 명의 플레이어가 입장했는데, 8코어 cpu 20%를 사용하고 있었다고 한다. 16코어 cpu에서는 지금에 반 정도해서 10% 정도를 사용하게 될 것이고 평균 cpu 사용량을 50~60% 로 유지한다고하면 게임서버 1대 당 1000명의 플레이어를 감당할 수 있다.
- 자, 우리 게임의 동접 목표치는 30만 명이다. 단순 계산해서 게임 서버는 300대가 필요한 것.
- 초당 프레임 레이트를 줄여야 할 지도 모르겠다. 캐릭터 충돌 처리를 위해 cpu 부하를 감수하고 있지만 언제 타협이 시작될 지 모른다...

## 22/11/14

- 서버에서 클라가 보낸 패킷을 처리하는데 패킷 핸들링 동작을 수행하는 스레드는 중간에 다른 스레드로 교체되지 말아야 하는 대전제가 깨졌다. DB 정보를 기록하는 패킷은 금전적 가치를 가진다. 절대 안전이 철칙인데, 이런 현상이 발생하자 DB 데이터 갱신 순서가 꼬여버렸다.
- 라이브에서 발생했다면 얼마나 끔찍했을지 상상이 안가는 수준이다. 가챠 패킷에서 터진다면 회사로 소송이 들어올 수도 있다...

## 22/11/15

- 클라이언트 쪽에 메모리 풀 관련 이야기가 나왔다.
  - 풀에서 꺼낸 자원을 돌려보내야 하는데 그냥 버렸다. -> GC가 처리하므로 크게 문제가 아님
  - 풀로 돌려보낸 뒤에 건드렸다. -> 고약한 버그가 터질 수 있음.

대략 보니 풀로 돌아간 객체 참조가 남아서 문제가 생겼던 모양이다. 레퍼런스 버전을 관리하는 래퍼 타입이 해결책으로 제시됐다.

```cs
struct UniquePtr<T>
    where T: class
{
    public T Ref =>
    {
        get
        {
        #if UNITY_EDITOR
            if (vholder.Version != this.version) { throw new NullException(); }
        #endif
            return this.ptr;
        }
    }

    private T ptr;
    
    #if UNITY_EDITOR
        private VersionHolder vholder;
        int version;
    #endif
}
```

## 22/11/17

유니티 플레이 장면을 녹화하기가 까다롭다. 고해상도 녹화가 필요한 상황에서 해상도가 너무 높다면 프레임 스킵이 발생해서 실시간 촬영이 안되고, 유니티에서는 게이뷰를 가로 4000 픽셀까지 밖에 쓰지 못하는 제약이 있다.

지스타 때 시연 영상이 퀄리티가 낮아서 다시 촬영해야 했다. 지스타 2022 현장용 영상 해상도가 무려 (17056 * 1248) 이다.

https://github.com/paraself/HiResRecorder-for-unity

여기서 도움이 되는 자료를 볼 수 있다.


++ 지스타 마비노기 모바일 시연장에는 시연 기기가 200대 씩이나 준비됐댄다. 이태원 참사 이후 안전 규정이 빡빡해져서 여기 저기 대기하고 사람 몰리지 않게끔 통제 받다보니 한 번에 150명 정도씩 자리를 잡고 플레이한 것 같다고 한다. 서버 동접이 그 정도 나왔다. 그리고 기어이 시연 중에 서버가 터지는 사고가 있었다. 서버 로직에서 무한루프 로직이 있어서 스택 오버플로우로 서버가 터져버린 것

## 22/11/18

마비노기 모바일은 가로 / 세로 모드 둘 다 지원한다. 마비노기는 만남을 중요한 요소로 다룬다. 세로 모드로 게임을 즐긴다면 다른 유저와 만났을 때 채팅하기가 편하다. 게임의 코어 요소를 중요하게 여긴다면 가로 모드로 즐기면 된다.

- [지스타 마비노기 모바일 인터뷰](https://bbs.ruliweb.com/news/read/174701)

## 22/11/25

- MM 게임 서버는 수평 확장 방식이다. 다수의 서버 프로세스가 존재하고 상호 의존적이지 않다.
  - 그러니까 돈을 들이부어서 다수의 서버 기기만 준비한다면 동접자가 아무리 많아도 대처할 수 있는 셈.
  - 개인 거래 컨텐츠의 경우 상호 유저의 DB 데이터 수정이 필요하고, 당연히 거래는 굉장히 중요한 로직이니 원자성을 보장해야 하는데 만약 두 유저의 데이터를 서비스하는 DB 샤드가 다르면 골치아픈 상황이 된다. 수평 확장의 제일 큰 약점. 하지만 MM에서는 이런 시스템이 없을 예정이랬다.

- 어딘가의 유니티 최적화 노하우
  - UI 는 UGUI를 사용한다. 그런데 일부 UI는 레이아웃 재계산이 느려서 (데미지 표기) 자체 구현을 도입했다고 한다. 저수준 그래픽스 api를 가져다가 직접 그린다. 속도가 50%가 빨라졌다고...
  - 텍스터는 안드로이드: ETC2(호환성 때문), IOS: ASTC. 텍스처 크기는 power of two.
  - 로직 영역에서 코루틴을 사용할 일이 굉장히 많았고 유니티 내장 코루틴은 가비지 범벅으로 끔찍하기 때문에 자체 코루틴을 도입했다.
  - 던전 진입할 때 GC를 한번 돌리고, 할당을 왕창 한 후 다시 GC를 돌리고 게임에 진입하고 있다. 유니티는 managed heap을 다 쓰면 일단 GC를 먼저 시도해보고 그 다음에 힙을 더 할당받는데 이렇게 하면 GC가 덜 돌게 할 수 있다.
  - 유니티 코리아의 답변은 믿지 않는다.

## 22/11/28

MM에 또 신규 피처가 추가되는데 이거 굉장히 기대된다. 모바일 게임인데도 보면 설레네.

여기는 공유 리포지토리니까 자세히 작성하지는 않는다.



온라인 게임은 어디까지의 재난에 대비해야 할까??
- 아마존 / 구글이 죽는다. -> 이 정도면 온라인 게임은 죽어도 된다.
  - 하지만 카카오톡 같은 범국가적 서비스는 그러면 안된다.
- 회사에 불이 난다 -> 그래도 게임은 죽지 말아야 한다.

판교 데이터센터 화재 이후 카카오 서비스 복구가 느렸던 이유에 대해 설명이 돌아다니는데,

- 인프라 자체는 이중화되어 있다. -> 인프라에 서비스가 배포되지 않은 상태지만 올리면 바로 돌아가게 할 수 있는 상태
- 사고가 난 곳에 깃 저장소가 있었다. -> 배포 가능한 서비스의 최신 상태와 빌드 & 배포 스크립트가 깃에 있었어서 그날 전부 유실해버린 것
- 각각의 서비스들에 대한 자동 빌드 및 디플로이가 불가능하고 배포 가능한 최신본들을 파악하기도 어려운 상태에서, 인력으로 순서를 맞춰서 수동 빌드 후 배포

## 22/12/02

애플리케이션의 컴포넌트를 다루는 시스템 코드가 있다고 하자.

상위 로직 영역에게 인터페이스를 제공해주는데, 동일한 컴포넌트 타입의 객체가 다수 존재할 수 있다면, (Multiple Component) 이쪽에는 또 다른 Multiple Component 컬렉션을 그대로 제공해주지 않는다. MultipleComponent 를 순회하면서 각 객체에게 MultipleComponent를 제공하는 흐름에서는 가장 큰 문제가 상위 로직 레이어에서 어느 순간 N^2 복잡도 코드를 작성할 수 있기 때문이다.

- 그렇다고 너무 고지식하게 제약을 두면 로직 프로그래머가 불편해지는데, 순회를 금지하고 핀포인트 룩업만 제공할 수 있겠다.

## 22/12/05

- 게임을 플레이하지 않는 사람에게 게임은 어떤 것일까?
  - [유튜브](https://www.youtube.com/watch?v=ax7f3JZJHSw)
  - 게임플레이에는 고유의 언어가 있습니다. 분명 영화나 소설과는 다른 형태의 문법입니다. 이런 언어는 분명 게임에 익숙하지 않은 사람들에게는 굉장히 생소한 것이라서 게이머 입장에서는 이것을 낯설어 하는 사람들의 반응에 의아함을 느낄지도 모르겠습니다.
    - 왜 붉은색 게이지는 체력을 의미하는 걸까요? 이동 매커니즘에는 걷기 / 달리기 / 슬라이딩 / 점프 .... 너무 많은 종류가 있고 하나하나 단숨에 파악할 수는 없습니다. 게임 컨트롤러의 다양한 형태의 버튼은 각각 무엇을 의미하는지도 잘 모르겠고요. FPS 게임에서는 마우스를 사용해야 하는 지 조차 몰랐을 수도 있습니다.


- 날카로운 게임과 넓은 게임
  - 날카로운 게임은 창작자 보인이 가장 잘 아는 욕망 & 취향으로부터 게임을 만들면 비슷한 욕망 & 취향을 가진 고객깅 그 게임을 사랑할 가능성이 높겠지요. 인디 게임들은 잠재 고객이 얼마나 있을지는 알지 못하더라도 개발 비용을 적게 들여서 비즈니스 리스크를 낮게 유지할 수 있습니다.
  - 모든 날카로운 게임이 저자본으로 만들어지는 것은 아닌데, 대표적으로는 리니지가 있습니다. 플레이어 집단으로부터 소속감과 우월감을 이끌어내는 데 탁월한 노하우가 있고 이런 게임 플레이에 호응하는 유저 시장을 파악하고 있기 때문에 대규모 자본으로 날카로운 게임을 만든다는 전략을 택할 수 있었지요.
  - 넓은 게임은 많드는 데 대단히 큰 비용을 들지만, 한번 기본이 완성되고 나면 그 안에서 비교적 적은 비용으로 무궁무진한 파생 플레이를 만들어낼 수 있습니다. 그렇다면 일단 대자본을 투입해서 만들기로 했다면 가능한 한 많은 고객을 만족시키려 하는 것이 합리적이 비즈니스 선택입니다. 단 평균적인 존재하지 않는 점을 염두에 두어야 합니다.
  - 날카로운 게임에서 넓은 게임으로 개발 중간에 노선을 변경한 사례가 있을 수 있습니다. 이 과정을 위해 긴 시간을 들여야 할 테지요. (MM)
  - 
**애플 프로파일링 세미나**

- Instrument App 에 여러가지 기능이 있다. 문화 충격이었던 것은 프로세스 코어 별로 처리되는 스레드 상태와 컨텍스트 스위칭 시점을 전부 추적할 수 있다는 것. 시스템 콜도 기록되고 있다.
- gpu 아키텍처에 대한 설명 세션이 있다. 다수 gpu 코어의 역할이 각자 달랐다. (Alu 전용, 텍스처 프로세싱 전용, 메모리 버퍼 전용 등등) 캐시도 두 종류가 있어서 텍스쳐 캐시와 메모리 버퍼 캐시가 있다. 이 두 종류를 효율적으로 활용해서 캐시 히트 비중을 늘려야하겠다. 
 - 발열 상태 모니터링 기능도 포함한다. 삼성 갤럭시에서도 발열 상태를 우려해서 기기 성능을 의도적으로 낮추고 그랬는데(gos game optimization service??) 애플에서도 비슷하게 발열상태가 우려 수준이 되면 자동적으로 기기 성능을 낮추는 옵션을 제공하는 모양이다.
 - 유니티에 xcode 까지 붙일 시 유니티 네이티브 레벨의 코드까지 퍼포먼스 측정이 가능하다. 자체 프로파일러를 팀에서 제작했었는데, 네이티브 코드는 확인 할 수 없는 한계가 있었다. 

## 22/12/06

뉴비와 고인물의 격차를 줄이는 매커니즘

- 와우: 새 시즌이 시작되면 이전 시즌의 졸업템에 준하는 성능의 아이템을 아주 쉽게 (퀘스트 보상으로) 얻을 수 있습니다.
- 리니지: 계속 새로운 성장축을 추가하며, 이전 성장축을 따라잡는 비용을 크게 줄입니다.
- 확산성 밀리언 아서: 새로운 카드는 요정(몬스터)에게 훨씬 높은 대미지를 주는데, 일정 기간이 지나면 원래 대미지로 돌아갑니다.
- 피파온라인: 몇 년 지나면 새 게임을 출시하고 이전 게임을 서비스 종료합니다.
- 매직 더 개더링: 스탠다드 게임 포맷에서는 최근 2년간 출시된 카드만을 사용할 수 있습니다.
- 유희왕: 3개월마다 금지 카드의 목록을 발표합니다. OP 카드는 보통 금지되는데, 다시 풀리는 경우도 있기 때문에 그런 카드를 가진 플레이어들은 희망고문 당한다고 하네요.
- 글로벌향 게임들 중 일부는 서버(라고 쓰고 사실상 일종의 랭킹 그룹)을 계속 늘리고 가입 시 신규 서버가 자동 선택이 되도록 해서 뉴비를 기존 유저들과 격리해둡니다. (ex. afk아레나, 라이즈 오브 킹덤즈, 니케 등) 이런 게임들은 보통 크로스 서버로 길드 같은 소셜 기능을 쓸 수 있고, 장기적으로 서버 간 경쟁을 늘려서 기존 유저를 케어합니다. 이 게임들 중 일부는 기존 유저 대상으로 서버 선택 후 다시 시작 기능을 제공하면서, 시작 서버에서 낙오된 플레이어가 신규 서버에서 다시 시작하기 좋게 부가 편의 기능을 더 제공합니다.
- SLG 장르에서는 시즌에 따라서 진행도와 보유 재화를 거의 대부분 리셋시켜 버리는 경우가 있습니다. (ex. 삼국지 전략판, 최근에 나온 넥슨 게임인 문명: 레인 오브 파워 등) 유지되는 것은 유료 재화와 유료 재화를 써서 얻은 결과물들이고, 지난 시즌의 결과에 따라 기존 유저가 약간의 버프를 받고 새 시즌을 시작합니다. 이런 게임들에서는 신규 유저들이 시즌 리셋에 맞춰서 격차가 크지 않은 상태로 시작할 수 있습니다. 시즌 리셋에 맞춰서 새로운 피쳐들이 도입되거나 규칙이 바뀌기 때문에 기존 유저들은 지난 시즌과는 다른 경험을 기대하고 게임에 잔존하게 됩니다.

## 22/12/12

와... 유니티 과거 버전에서는 string.operator == 가 GC 를 발생시켰다. 정말 끔찍하다. 고성능 게임 개발자들은 울며 겨자먹기로 string.Equals 를 사용해야 했다.

- 별개로 Dictionary에서 string 해시 찾을 때는 인자로 StringComparison.Ordinal 을 주면 성능이 조금 개선된다고 한다.

## 22/12/20

- UIStateRule
- UIInstance
- 애플리케이션 실행 후 런타임을 각 구간별로 구분하고, (실행 중, 메인 씬 진입 등) 각 구간별로 적용할 대전제들을 IUIStateRule이 작성합니다.
- ui 상태 관리와 ui 오브젝트 로드/ 언로드를 구분된 동작으로 구현합니다. ui 개체는 복합적으로 엮어있을 수 있다. 하나의 이벤트에 대응해서 다수의 ui 개체를 올려야 된다던가 하는데 이런 구현에 대응해서 load/unload를 분리한 것.


회로애략은~~~

```
희노애락이라고 4가지라고 하기도 하고

행복, 슬픔, 분노, 놀람, 두려움, 혐오 등 6가지로 나누기도 합니다.

더 나가서 27개로 나눈 것도 있습니다. (감탄, 동경, 심미적 감상, 즐거움, 분노, 불안, 경외, 어색함, 지루함, 평온함, 혼란, 갈망, 혐오, 공감성 고통, 몰입, 흥분, 두려움, 공포, 흥미, 기쁨, 향수, 안도, 로맨스, 슬픔, 만족, 성적 욕망, 놀람)

 

그런데 최근의 연구에 따르면

이 많은 여러가지 감정이 사실은 사랑과 두려움에서 출발한다고 합니다.


과격한 연구자들은 사랑도 두려움에서 출발한다고 주장하기도 합니다.
(더 좋은 유전자를 남기지 못할 것에 대한 두려움)

삶을 위협하는 여러 두려움을 처리하는 과정이 바로 감정이라는 주장입니다.

두려움을 잘 처리하고 대응할 수록 생명체는 더 잘 살아남을 것이므로 이 주장은 꽤 설득력이 있어보입니다.

1. 생존에 대한 위협의 경험이 몸에 쌓이면
2. 몸이 위협에 대해 반응을 하고 
3. 그 반응을 뇌(생각)가 해석하면서 다양한 감정으로 인식되는 것
이라고 합니다.
```

## 22/12/22

수요 주도 경매장 시스템 vs 공급 주도 경매장 시스템

- 자신이 필요로 하는 물품과 지불하겠다는 값을 경매장에 올리고 공급자가 선택하는 것이 수요 주도
- 공급자가 제공하는 물품과 판매가를 올리고 구매자가 선택하는 것이 공급 주도
  - 수요 주도는 뉴비 친화적으로 작용할 수 있다. 공급 주도의 시스템에서 공급자들은 보통 어느 정도 스펙을 갖춘 이후에 물품을 제공하기 때문에, 경매장 주도권이 기득권 위주로 흘러가는 셈.
  - 그렇지만 수요자들이 줄어든다면??? 게임이 인기가 없을 시기에 경매장에 가뭄이 온다면??? (보통 시들어가는 게임에 고인물은 남아있지만 뉴비가 없다)
  - 작업장은 어떻게 반응할까?? 저레벨 캐릭터를 대량 양산한다 해도 수요 주도 경매장에서는 뭔가를 살 수만 있다. 이제까지와는 다른 어뷰징 패턴이 나올 것이다.

이거 기대된다. 초심자 친화적인 시스템이라 서비스 초기에는 아주 흥하겠지만 시간이 지나면 어떤 양상이 나타날까?? 새로 등장할 어뷰징 패턴이 제일 기대된다.

## 22/12/26

넥슨의 게임 서버 구현이란... 클라 요청을 받으면 비동기 처리하고 공유 자원 접근할 때 동시성 문제 주의하고 시간을 대기해야 하면 요청 처리자가 자체 타이머를 세팅하고 등등... 이런 패턴이 왕도였던 모양이다. MM 서버에서 각 채널 업데이트 틱을 도입해서 병렬 스레드들이 채널을 하나씩 맡아서 update 를 돌리는 이런 구현은 낯설었는지, 넥슨 코리아 인프라팀에서 질문을 무지하게 많이 했다고 하더라. 맥락을 이해 못한 질문도 끼어 있어서 질문 하는 쪽도 답하는 쪽도 둘다 황당해 했다더라.

이렇게 채널 업데이트 틱을 도입하는 형태는 FPS 게임 서버 말고는 별로 없다. 생각해보면 굳이 뭣하러 부하 큰 업데이트 시퀀스를 서버에 적용해야 할까.

우리 프로젝트가 별난 이유는 아무래도 유저간 끈끈한 상호작용을 욕심내는 대표님 고집이 아니었을까. (캐릭터간 세밀한 충돌 처리 등....) 멀티스레딩 코드를 짜는 것은 굉장히 위험성이 높다는 말이 있지만, 시스템 코드를 잘 짠다면 넘지 못할 허들은 아니다.

## 23/01/03

문제의 유니티가 c# Dictionary 구현을 써먹을 때 또 골치를 썩히는지 프로젝트 차원에서 해시맵 자체 구현을 고민중이신가 보다

- Code Bloat : 제네릭 타입 인자가 struct 이면 코드를 찍어낸다. 문제는 내부적으로 타입 의존적이지 않은 코드가 많다는 것. 코드가 너무 비대해진다. 프로젝트 코드의 30%를 차지할 정도로
- 긴 배열 하나를 사용함 : 최대 50%의 용량 오버헤드가 있다. 그리고 유니티의 경우 재할당이 발생하면 끔찍한 메모리 단편화가 생깁니다. 메모리에 크레바스가 하나 생기는 겁니다.
- Dictionary 자체 구현의 오버헤드가 크다. : Tkey 값을 보관하는 등. bucketIndex 같이 고정 오버헤드가 붙는 등.
- 가비지를 만드는 실수를 하기 쉽다. : IReadOnly시리즈에 foreach를 쓰는 등

해시 처리 구현을 이것저것 찾아보고 괜찮은 거 있으면 도입하라는 미션이 떨어진 듯... 주로 고려하는 부분은 역시 메모리. 메모리. 메모리

성능을 희생하더라도 메모리를 챙기는 해시 구현을 찾아 도입한다.

**닷넷**

해시 충돌 해결기법으로는 open Address, Seperate Chaining, 이차 조사 등등 이 대표적이다.

.NET dictionary의 방식은 SeperateChaining 이다. 컨테이너 안에서는 해쉬 키 값을 모듈러 해서 보관하는 bucket 이 있고, 실제 데이터가 들어가는 Entry가 있다. 해시 충돌이 나면 bucket을 링크드 리스트 방식으로 연결해준다.

- 삽입, 삭제가 빈번할 시 메모리 단편화를 대비한 전략이 준비되어 있다. free Count / free List를 활용하는데, 놀고 있는 bucket 이 없도록 한다.
- 해시 알고리즘은 메모리 <-> 성능을 트레이드 한다. 닷넷 딕셔너리는 메모리를 희생하고 성능을 챙기는 쪽에 속한다.
- 해시 컨테이너 전체에서 사용량이 50 ~ 60% 를 넘어가게 되면 슬슬 해시 충돌이 많아져서 오버헤드가 발생하고 키 탐색 비용이 O(1) 을 보장하지 못하게 된다. Resize 정책도 중요한 부분.
- [참고: dotnetos.org/blog](https://dotnetos.org/blog/2022-03-28-dictionary-implementation/)

![](DotnetDictionaryImpl.png)


**해시 알고리즘 탐색 중**

- [patchmap 해시 알고리즘 벤치마크](https://1ykos.github.io/patchmap/#The%20algorithm)
- Facebook 의 F14
- 구글의 Sparsehash
- c++ stl


## 23/01/04

테스트 데이터 관리

- 테스트 데이터는 어디에 위치시키는 것이 좋은가
- 실제 라이브 데이터와 정합을 자연스럽게 맞출 수 있는가. (데이터 형태가 달라질 때 쉽게 대응가능한가)
- 잘못 수정할 가능성을 방지할 수 있는가 (예를 들어 테스트 데이터와 라이브 데이터가 한 파일에 같이 작성되고 있다고 하자. 어느 날 작업자가 모든 '라이브' 데이터의 값 하나를 일괄 수정하려는데 실수로 테스트 데이터까지 건드리고 말았다.)
- 라이브 로직이 자라날 때 테스트 데이터가 반드시 같이 추가되어야 한다면, 이게 너무 번거롭지는 않은가. 그 로직에 대해서 반드시 테스트를 작성할 필요는 없을 수 있다.
- 테스트 데이터는 코드로 자동생성할 수는 없는 걸까?

## 23/01/09

관리 힙과 GC 라는 강력한 도구를 활용하는 C#은 시스템 도구를 구현할 때 내부적으로 자잘한 메모리를 자주 할당하는 구현을 채택했고, 닷넷 프레임워크에서는 납득할 만한 내용이지만 유니티에서는 아니다. 유니티의 GC는 메모리 컴팩트 절차가 없어서 메모리 단편화에 끔찍하게 취약하다.

- 그러니 순진하게 작성된 c# 코드들은 유니티 환경에서 메모리를 무자비하게 잡아먹기 쉽상이다. 베스트 프랙티스에 맞게 작성된 C# 코드가 난데없이 유니티에서 사고를 칠 것을 IDE들이 어떻게 알겠는가. 불필요한 메모리 할당 동작이 섞여 있어도 IDE 들이 문제를 지적하지는 않는다.
- 이래서 Rider를 같이 쓰라는 것인데 Rider는 유니티를 위한 C# 에디터이다. 닷넷 환경에서는 문제없지만 유니티에서는 문제가 되는 코드들을 잘 찝어서 작성자에게 경고를 준다.... 왜 이런 일이 있어야 한단 말인가...

## 23/01/10

리소스 패키징

- READ: 파일을 읽을 때 스토리지에 다녀오는 핑퐁 빈번도를 최소화시켜야 한다.
  - 이를 테면 패치 다운로드 도중에 특정 파일이 있나없나 들여다볼 때마다 시스템 콜 부른다면 비용이 클 수 있겠다.
  - fopen 시스템콜이 굉장히 비용이 크다. 그래서 파일을 한번 열면 되도록 닫지 않도록 한다.
  - blob 파일과 인덱스 파일들로 구성할 수 있겠다.
  - 프로젝트 개별적으로 파일시스템을 구현하고 os 파일시스템을 대신하도록 하는 방법론이 많은 것 같다. 
- WRITE: 개발 / 라이브 단계에서 배포 프로세스와 잘 맞물려 돌아가야 하겠다. 예를 들어 증분 빌드 프로세스에서도 패키지 재구성이 가능해야 한다.
  - 만약 개발 단계에서 매번 변경점이 저장소에 올라올 때마다 패키징을 다시 해줘야 하는 번거로움이 있다면 곤란할 것.

## 23/01/16

유니티 코리아

- 넥슨은 유니티의 기술 지원 클라이언트이다.
  - 유니티로 개발된 게임 (하스스톤 / 원신) 중 일부는 대규모 프로젝트로, 프로젝트 과정에서 마주친 문제와 모법적인 해결법이 있었겠지만, 유니티에서는 이때 활용한 기능을 문서화하지 않음. 애초에 코드 공개를 하지 않았고 알려지지 않은 기능들이 많은 것 같다.
  - 접근성이 굉장히 떨어진다.
- 프로젝트 초반에는 발견되지 못한 문제들이 프로젝트 중 / 후반에 나타난다. 이전에 유니티 코리아로 문의를 넣은 적이 여러 번 있었지만, 유니티 코리아 측 답변 중 일부는 개발자에게 오히려 혼동을 주었고 품질도 실망적임
- 넥슨 측은 광범위한 퍼포먼스 이슈 외에도 유니티 코리아의 알맹이 없는 답변에 분통을 터뜨릴 수 밖에 없는 상황...

## 23/01/31

- [DevTech 게시물: 쿠키런 킹덤 출시 후 DB 날려먹을 뻔한 사건](https://tech.devsisters.com/posts/bit-level-database-hacking/)
- [NDC 발표](https://youtu.be/FUEZibcZEkg)

CockroachDB 를 사용했다. (consensus Algorithm 기반, 메인 노드의 데이터로 일관성을 확보한다.) 출시 후 주말, 사용자가 폭증한 상황에서 데이터베이스 설정 미스로 DB 노드가 다운되었다. 메인 노드에 들어간 데이터는 일관성을 보장하지 못하는 것이 CockroachDB 의 철학이기 때문에 DB 노드 다운 이후 발생한 모든 트랜잭션은 DB에 정상 반영되지 못했다. 장애가 발생하지 않았던 노드 어딘가에 Raw 형태로 남겨져 있는 상태였다고 한다. 공식적으로 지원하는 기능 중에 메인 노드에 들어가지 못한 이 데이터를 확인하는 기능은 없다. 단지 덜렁 있는 원시 데이터 파일만 확인할 수 있는 상황

이 원시데이터를 끄집어내서 bit 레벨에서 파싱하는 코드를 짜냈다는 일화.

- [DevTech 게시물](https://tech.devsisters.com/posts/crk-launch-storage-postmortem/)

그 DB 설정 미스가 뭔가 찾아보니까, out of disk 상황에 대비해 ballast 파일(사전에 미리 공간을 점유해두는 더미 파일을 만들어 두는데, 디스크가 가득차면 이 더미 파일을 지우면서 공간을 확보하고 스토리지 증설에 필요한 명령 등을 실행한다. 이후 다시 클러스터에 join 한다.) 경로가 잘못되었다고 한다. 리눅스 환경에서는 디스크 가득 찬 상황에서는 운영체제의 정상 동작을 보장 못하기 때문에 이런 형태의 보험이 있다. ballst 파일의 경로가 잘못되었으니, 더미 파일로 착각하고 제거한 곳에는 실제 DB 작동을 위해 필요한 파일이 있었던 것. DB 노드는 마비되기 시작한다.

## 23/02/03

나타났던 버그들

- 항상 필드에 있어야 할 npc 가 플레이어의 공격을 받고 사망한다. 그 플레이어는 힐러였는데, 특수 스킬 중 일부가 '우호적인' 대상에게도 영향을 미치는 특징이 있다.
- 메쉬와 본 : 삼각형이 이리 저리 튀는 현상과, 상 / 하체 본 조합이 따로 놀아서 괴상한 춤을 추는 것처럼 보인다던가
- 리소스 잔류. 스킬 이펙트가 타이틀 화면에 나타난다.
- 무한 루프 / 스택 오버플로우 : 코드 논리 상의 문제. 가장 대응하기가 골치아픈 문제인데, 무한루프에 빠지면 해당 프로세스를 강제로 셧다운 시키는 수 밖에 없다.
- 리소스 누락 : 종종 이것 때문에 게임의 룩이 심각하게 망가지는 일이 있다.

## 23/02/15

**[Unity의 Fast Script Reload](https://assetstore.unity.com/packages/tools/utilities/fast-script-reload-239351)**

Fast Reload 그러니까 유니티 런타임 동작 중에 코드를 수정해도 플레이 세션을 중단할 필요가 없다. 수정된 코드는 즉각 반영된다. 개발자의 소개 문구대로 동작한다면 팀에서는 커다란 생산성 개선을 기대할 수 있겠다.

그렇지만 팀의 사용 소감은 네거티브하다.

- Obsolete 메서드 사용. 그리고 대체 메서드를 알려주지 않는다. 유니티 업데이트가 더 진행되면 이 문제는 심해질 것이다.
- 동작 원리를 살펴보니, 도메인 리로드 시점을 빠르게 해주는 것이 아니라 현재 플레이 중인 상태에서 단순히 도메인을 핫리로드 해주는 도구이다. (c# 모딩 라이브러리인 하모니를 사용하는 것 같다) 따라서 플레이 버튼을 눌러 게임을 실행하고 코드를 변경하고 결과를 봐야 한다. 코드 변경점만 확인할 수 있는 것과 같다. 만약 프리팹 변경이 포함되었으면 혜택을 받기 어려울 수 있겠다.
- 유니티 컴포넌트 수정을 잘 갱신된다.
- 코드 제약 사항이 많은데 제네릭 / this 객체 전달 등이 안된다.
- 에디터 로딩 시 Fast Script Reload 기동 시간이 추가된다.
- 디버거가 매끈하게 붙는다고 보기 어렵다. Fast Script Reload 로 생성된 컴파일 코드에만 디버거를 붙일 수 있다고 한다. 수정된 파일 원본에는 디버거를 붙일 수 없다. 핫리로드 된 파일을 잘 찾아봐서 디버거를 붙여야 한다. (로그를 뒤적거려야 하는 수고가 든다.)
