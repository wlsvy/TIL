# C

## 25.01.09

- 게임물관리위원회 ( 줄여서 게등위 ) 에서는 등급 심사를 위해 인 게임 텍스트 추출 요청을 하기도 한다.
- 이 경우 게임 데이터에서 텍스트 추출 도구가 준비되어야 함.

## 25.01.20

[넥슨 '마비노기', NPC 상점 설정 오류 발생…디렉터 사과](https://www.msn.com/ko-kr/news/other/%EB%84%A5%EC%8A%A8-%EB%A7%88%EB%B9%84%EB%85%B8%EA%B8%B0-npc-%EC%83%81%EC%A0%90-%EC%84%A4%EC%A0%95-%EC%98%A4%EB%A5%98-%EB%B0%9C%EC%83%9D-%EB%94%94%EB%A0%89%ED%84%B0-%EC%82%AC%EA%B3%BC/ar-AA1xucKS?ocid=BingNewsSerp)

    관련 내용은 지난 16일 업데이트로 추가된 고가 아이템 2종인 ‘마력이 깃든 융합제’와 ‘무리아스의 성수 효과 제거 주문서’가 추가되면서 발생한 것으로 조사됐다.

    민 디렉터는 “해당 내용은 NPC 상점에서 구매할 수 있는 아이템 중 높은 가격 혹은 높은 묶음 개수를 가지고 있는 아이템에서 발생했다”며 “구매 가격과 개수로 계산되는 중간값이 42억을 넘어가는 경우, 코드에서 결과 값을 도출하면서 오버플로우가 발생해 부끄럽게도 이번과 같은 문제가 발생하게 됐다”고 설명했다.

    마비노기 측은 디렉터의 공지 전 오류와 관련해 긴급 점검 및 조치 안내를 통해 부당한 이득을 취한 캐릭터에 26명의 게임이용제한을 발표했다. 그러나 마비노기 커뮤니티에서는 이번 오류가 발생하기 전부터 이를 악용한 이용자가 있다는 제보와 함께 적극적인 대응을 요구하기도 했다.

- int32 형 오버플로우가 유발한 돈 복사 버그.

---

[Please Don't Force Dark Mode — Vishnu's Pages](https://iamvishnu.com/posts/please-dont-force-dark-mode)

**My Eyes! My Eyes! 😵💫**

    Reading in dark mode doesn’t just mess with my eyes while I’m at it — it sticks around afterward too. 
    Every time I finish a long article, I end up seeing horizontal stripes everywhere I look, like my eyes just won’t let it go.

**What’s the real problem with the dark mode?**

    The real problem is the contrast ratio between the text and the background when using dark mode.

    For example, pure white text on a pitch black background can strain my eyes and be very difficult to read. The contrast ratio of this combination is 21:1

    However, light gray text on a dark gray background is easy on my eyes.
    Here the background is #666 and the text is #E0E0E0 which creates a contrast ratio of 4.34:1.

**higher contrast ratios in dark mode cause discomfort for my eyes. But when I say ‘higher’, just how high can it go?**

    The Web Content Accessibility Guidelines (WCAG) version 2.1 recommends a minimum contrast ratio of 4.5:1 for normal texts (SC 1.4.3) but not a maximum.
    The current guidelines makes pure white text on pitch black background completely accessible, even if the contrast ratio is an unbearable 21:1. 
    But the more comfortable contrast ratio of 4.34:1 from the above example fails according to the guidelines.

> That means, currently, there are no standards or guidelines that address contrast ratios in dark mode.

---

[Project Lombok](https://projectlombok.org/#)

- java 의 롬복
- [Introduction to Project Lombok  Baeldung](https://www.baeldung.com/intro-to-project-lombok)

java 코드 작성 시의 자주 반복되는 코드 boilerplate 지점들을 자동 작성해주는 도구

- getter, setter, constructor, toString, Equal 등등,
- c# 의 record 개념이 가지는 컴파일러 매직과 비슷하다는 느낌을 받음.

---

[On Long Term Software Development - Bert Hubert's writings](https://berthub.eu/articles/posts/on-long-term-software-development/)

- [장기적(long term) 소프트웨어 개발  GeekNews](https://news.hada.io/topic?id=18407)

테스트, 테스트, 그리고 테스트

    테스트의 필요성은 모두가 동의하는 기본 원칙:
        가능한 많은 테스트를 작성.
        모든 테스트가 동등하게 가치 있는 것은 아니지만, 테스트 자체를 후회할 일은 거의 없음.
    특히 의존성이 많은 프로젝트에서 테스트는 필수:
        의존성이 변경되거나 드리프트될 경우, 문제를 조기에 감지하는 데 도움.
    테스트의 역할
        문제 해결 지원:
            변경 상황에 맞춰 빠르게 조정 가능.
        리팩토링 지원:
            코드 의존성을 제거하거나 변경할 때 자신감을 제공.
        장기 유지보수에 유용:
            개발이 3년 이상 중단된 이후에도 테스트를 통해 시스템이 여전히 작동하는지 확인.
            새 컴파일러, 런타임, 운영체제에서도 기능 유지 여부를 확인.
    테스트는 비용이 아니라 투자
        더 많은 테스트를 작성:
            테스트는 유지보수와 안정성의 기반.
            코드 수정 또는 확장 시 테스트는 큰 정신적 지지 역할.

복잡성: 소프트웨어 개발의 최종 보스

    복잡성은 소프트웨어 개발의 궁극적 적:
        최고의 개발자나 팀도 복잡성에 의해 무너질 수 있음.
        엔트로피와 인간 행동의 영향으로 복잡성은 항상 증가.
        복잡성을 의식적으로 관리하지 않으면, 프로젝트는 유지 불가능한 상태로 빠질 수 있음.
    복잡성과 코드 양의 상관관계
        코드 양과 복잡성:
            코드가 적을 때는 다소 복잡하더라도 관리 가능.
            코드가 늘어날수록 단순성을 유지해야 제어 가능.
            관리 가능한 복잡성은 팀의 역량과 "초록 삼각형" 안에 있어야 함.
        복잡성의 한계:
            팀 인원을 늘리거나 뛰어난 역량의 개발자를 고용하더라도 복잡성 처리에는 한계가 있음.
            한계를 넘어서면 프로젝트는 유지보수 불가능한 상태에 빠짐.
    코드가 항상 ‘오른쪽 위’로 움직이는 이유:(그래프에서)
        더 많은 기능 요청.
        불필요한 최적화 시도.
        버그 수정 시 기존 복잡성을 줄이는 대신 새로운 코드 추가.
    잘못된 API 설계의 비용:
        예: CreateFile 함수가 대부분의 경우 파일을 생성하지 않음.
        이러한 혼란은 추가적인 인지적 부담과 실수 가능성을 높임.
    복잡성 관리 전략
        리팩토링은 조기에, 그리고 자주:
            불필요한 코드를 제거하고, 단순화에 시간 투자.
        테스트에 투자:
            테스트가 많을수록 복잡성을 줄이는 작업이 쉬워짐.
        복잡성 관리의 중요성:
            단순화를 위해 미리 노력하지 않으면, 장기 프로젝트는 결국 "유지보수 불가 상태"로 빠질 위험이 있음.

지루하고 간단한 코드를 작성하라. 그보다 더 간단하게. 그리고 더 지루하게.

    "디버깅은 프로그램을 작성하는 것보다 두 배 더 어렵다. 따라서 코드를 작성할 때 최대한 똑똑하게 만들면, 그것을 디버깅할 방법은 무엇인가?" - Brian Kernighan

    슈퍼 지루하고 명확한 코드 작성:
        나이브(näive)하지만 직관적으로 이해 가능한 코드를 선호.
        "프리미엄 최적화는 모든 악의 근원이다."
    최적화는 반드시 필요할 때만:
        너무 간단해서 문제가 될 경우, 나중에 복잡성을 추가하는 건 어렵지 않음.
        그 순간이 오지 않을 수도 있음.
    복잡한 코드 작성을 지양:
        반드시 필요한 시점까지 기다릴 것.
        단순한 코드를 작성한 것에 대해 후회할 가능성은 매우 낮음.
    고성능 코드나 기능은 특정한 환경에서만 작동할 수 있음.
        예:
            LMDB: PowerDNS에서 안정적으로 사용하기까지 많은 어려움 겪음.
            RapidJSON: SIMD 가속 JSON 라이브러리. 성능은 뛰어나지만 사용 조건이 까다로움.
    "나는 이 제약을 극복할 수 있다"는 자신감이 있더라도:
        올해는 가능하더라도 5년 후 자신 혹은 후임 개발자는 어려움을 겪을 수 있음.
        복잡한 프로그래밍 언어도 동일한 원칙이 적용됨.
    결론:
        코드를 단순화하라:
            정말 간단하게. 그보다 더 간단하게.
        최적화는 나중으로 미뤄라:
            복잡성은 필요할 때 추가 가능하지만, 초기에 복잡하게 만들면 유지보수가 어려워짐.

## 25.01.23

**DR (Disaster Recovery) / 네이버 데이터센터 각(GAK)**

[“카카오와는 다르다”··· 네이버클라우드, ‘재해에도 무너지지 않는 기술’ 선봬 - 디지털데일리](https://ddaily.co.kr/page/view/2022121416313195562)

    15일 SK C&C 판교 데이터 센터 화재로 카카오 서비스 장애가 일부 지속되고 있는 가운데, 동일한 데이터센터를 사용함에도 네이버와 카카오의 서비스 복구 대응이 다른 이유에 이목이 쏠린다.

    네이버는 주요 서비스의 이원화를 꾸준히 대비해 왔기 때문에 한곳의 데이터센터 장애에도 서비스 정상화가 빠르게 이뤄질 수 있었다는 설명이다. 카카오는 여러 데이터 센터에 데이터를 분할 백업하고 있고 이원화 시스템을 갖췄지만, 이를 적용하는 데 시간이 오래 걸린다는 설명이다.

    이번 화재로 네이버는 뉴스 서비스 댓글 팔로우, 스마트스토어, 쇼핑라이브 등 일부 기능이 원활하지 못했지만 카카오톡처럼 본 서비스 자체가 장시간 먹통이 되지 않았다. 뉴스 팔로우 기능은 아직 점검 중이나, 쇼핑라이브는 장애 발생 세 시간 만에 복구됐고, 스마트스토어도 지난 밤사이 복구가 완료됐다.

    카카오톡의 경우 16일 오전 텍스트 메시지 송수신, PC 버전 로그인 기능 등을 복구했으나, 오후 1시 기준 이미지, 동영상 메시지 송수신은 현재까지도 작동하지 않고 있다. 카카오톡 최장 시간 장애에 이용자들은 전국구 서비스인 카카오톡이 재난 대응에 미흡했다며 목소리를 높이고 있다.

- [네이버 ‘각 세종’, LEED 플래티넘 획득… “지속가능 IDC 운영 인정” - 더나은미래](https://www.futurechosun.com/archives/89862)

    이번 각 세종의 LEED 플래티넘 인증까지 더해지며, 네이버는 모든 건축물에 대해 LEED 플래티넘을 획득하게 됐다. 2013년 각 춘천의 LEED 플래티넘 획득을 시작으로 그린팩토리(2014년), 커넥트원(2015년)에 이어 제2사옥 1784(2022년), 이번 각 세종까지 모두 ‘친환경’ 인증을 받게 된 셈이다.

## 25.01.26

[Performance Improvements in .NET 9 - .NET Blog](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/#gc)

- Object Stack Allocation
- https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/#object-stack-allocation

> For years, .NET has explored the possibility of stack-allocating managed objects.

제한적인 상황에서 .NET 9 은 참조타입의 스택할당을 지원한다.

```cs
// dotnet run -c Release -f net8.0 --filter "*" --runtimes net8.0 net9.0

using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args);

[MemoryDiagnoser(false)]
[DisassemblyDiagnoser]
[HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")]
public class Tests
{
    [Benchmark]
    public int GetValue() => new MyObj(42).Value;

    private class MyObj
    {
        public MyObj(int value) => Value = value;
        public int Value { get; }
    }
}
```
위의 코드가 어떻게 번역되느냐 하면

```
; Tests.GetValue()
       push      rax
       mov       rdi,offset MT_Tests+MyObj
       call      CORINFO_HELP_NEWSFAST
       mov       dword ptr [rax+8],2A
       mov       eax,[rax+8]
       add       rsp,8
       ret
; Total bytes of code 31
```
^ .NET 8

```
; Tests.GetValue()
       mov       eax,2A
       ret
; Total bytes of code 6
```

^ .NET 9

결론적으로 생성자를 호출하지 않게 되면서 .NET 9 기준 위 코드에는 가비지가 발생하지 않는다.

---

- GC
- https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/#gc

Applications end up having different needs when it comes to memory management. Would you be willing to throw more memory at maximizing throughput, or do you care more about minimizing working set?

애플리케이션은 메모리 관리와 관련하여 서로 다른 요구 사항을 갖게 됩니다. 처리량 극대화에 더 많은 메모리를 투입할 의향이 있습니까, 아니면 워킹셋 최소화에 더 신경을 쓰시나요?

Workstation GC optimizes for reduced memory consumption, while server GC optimizes for maximum throughput. Historically, workstation employs a single heap, whereas server employs a heap per core. That typically represents a tradeoff between amount of memory consumed and the overhead of accessing a heap, such as the cost of allocating. If a bunch of threads are all trying to allocate at the same time, with server GC they’re very likely to all be accessing different heaps, thereby reducing contention, whereas with workstation GC, they’re all going to be fighting for access. Conversely, more heaps generally means more memory consumed (even though each heap could be smaller than the single one), especially in lull periods where the system might not be fully loaded, yet is paying in working set for those extra heaps.

- workstation GC : 하나의 힙이 존재함. 만약 cpu core 가 힙에 접근할 때는 경합이 발생할 수 있다. 성능손실 가능성이 있음
- server GC : cpu core 마다 힙이 존재함. 그러니 각 코어는 힙에 접근할 때 거의 경합을 겪지 않을 것임. 대신에 메모리 오버헤드가 있음.

- [Dynamically Adapting To Application Sizes | by Maoni0 | Medium](https://maoni0.medium.com/dynamically-adapting-to-application-sizes-2d72fcb6f1ea)
- 만약 중간 타협점을 원한다면 DATAS (Dynamically Adapting To Application Sizes) 방법이 있음.

---

Chat GPT 한테 질문.

### .NET Workstation GC vs Server GC 비교

### 🔹 1. Workstation GC  
📌 **싱글스레드 환경**(또는 가벼운 멀티스레드 환경)에 최적화됨.  
📌 **UI 기반 애플리케이션(WPF, WinForms)**에서 사용됨.  

#### **특징**  
- 기본적으로 **싱글 GC 스레드**만 사용  
- UI 애플리케이션에서 **응답성을 유지**하는 것이 목표  
- GC 실행 시 **애플리케이션이 멈추는 시간을 최소화**  
- 멀티코어 시스템에서도 기본적으로 **하나의 GC 스레드**만 사용  

#### **장점**  
✅ UI 애플리케이션에서 멈추는 시간이 짧음 → 부드러운 UX  
✅ 낮은 메모리 사용량  

#### **단점**  
❌ 멀티코어 서버 환경에서는 성능이 떨어질 수 있음  
❌ GC 성능이 낮아 대량 객체 할당/해제 시 비효율적  

---

### 🔹 2. Server GC  
📌 **멀티스레드 환경**(특히 서버 애플리케이션)에 최적화됨.  
📌 **ASP.NET, .NET Core Web API, 백엔드 서버 프로세스**에서 사용됨.  

#### **특징**  
- **각 논리적 프로세서(코어)마다 하나의 GC 스레드**를 생성  
- GC 실행 시 **모든 코어를 활용하여 병렬로 동작**  
- **더 많은 메모리 힙**을 지원  
- **스레드 풀을 적극 활용**하여 대량 요청을 빠르게 처리  

#### **장점**  
✅ GC가 여러 코어를 활용하여 빠르게 실행됨 → **GC 속도가 빠름**  
✅ **멀티스레드 환경에서 뛰어난 성능**  
✅ **큰 메모리 힙을 효율적으로 관리**  

#### **단점**  
❌ 멀티스레드를 활용하기 때문에 **메모리 사용량 증가**  
❌ GC 실행 시 **CPU 사용량이 순간적으로 높아질 수 있음**  

---

### 🔹 성능 비교  

|                   | **Workstation GC** | **Server GC**           |
| ---               | ------------------ | ------------------      |
| **적용 대상**     | 데스크톱 앱, UI 앱 | 서버 앱, 백엔드 API     |
| **멀티코어 지원** | 제한적             | 코어마다 GC 스레드 할당 |
| **GC 속도**       | 느림               | 빠름                    |
| **CPU 활용도**    | 낮음               | 높음                    |
| **메모리 사용량** | 적음               | 많음                    |
| **응답성**        | UI 지연 최소화     | 서버 처리량 증가        |

## 25.01.29

[(211) 유튜버 모두가 속은 Honey 사기사건](https://www.youtube.com/watch?v=EsqBuwOuXB0)

- 허니 제휴 사기 사건
- [간단하게 알아보는 허니 사기 사건 - 미스터리/공포 - 에펨코리아](https://www.fmkorea.com/7899142524)
- [(219) Exposing the Honey Influencer Scam](https://www.youtube.com/watch?v=vc4yL3YTwWk)
- [uBO Quick Filters list being stolen by team behind Honey browser extension (Pie Adblock extension) : uBlockOrigin](https://old.reddit.com/r/uBlockOrigin/comments/1hr6xjc/ubo_quick_filters_list_being_stolen_by_team/)

- MegaLag에 따르면, Honey는 인플루언서의 제휴 링크를 클릭하면, 결제 시 Honey의 팝업과 상호작용할 때 자체 추적 링크로 교체하여 제휴 수익을 가로챔.
- 이로 인해 Honey가 판매에 대한 크레딧을 받게 되며, 이는 유튜버나 웹사이트가 아닌 Honey가 이익을 얻는 결과를 초래함.
- 애드온이 제휴 링크를 교체하여 수익을 훔치는 것으로 밝혀졌으며, 코드도 훔친다는 의혹이 있음.

![image_2025-01-29-19-33-14](img/image_2025-01-29-19-33-14.png)

    비유하자면, 적립 받아야할 주체가 있는데, 이걸 알바가 빼돌려서 자기껄로 적립하는 것과 똑같음

    어떤 식이냐면

    쿠폰이나 리워드를 제공한다면서 이거 할래? 라고 알림이 뜨는데

    이걸 누르는 순간 수수료를 받는 주체가 저 Honey로 바뀌게 됨

    쿠폰이나 최저가를 찾아주지도 못하고 다른 혜택을 못 받는다고 해도

    자기들을 통해 이 매출이 발생했다고 조작함

    나는 인플루언서 팬심 겸 혜택도 받을 겸 해당 링크를 통해 물건을 구매했는데

    정작, 이 행동으로 인한 수익은 엉뚱한 놈이 채간거라는 얘기

## 25.02.06

**비동기 상호작용**

- 트릭컬 pvp 등등
- [비동기 파티플레이와 PvP가 매력, 트라하 인피니티 - 에누리 쇼핑지식 뉴스](https://m.enuri.com/knowcom/detail.jsp?kbno=2279615&bbsname=news)
- [도대체 pvp를 왜 비동기로 만들었는지 이해가 안가네 - 대항해시대 오리진 마이너 갤러리](https://gall.dcinside.com/mgallery/board/view/?id=bigtimeofnavigation&no=7018)

    그냥 유저스펙의 컴까기면 상대랑 싸우는게 아니잖아 ㅋㅋㅋㅋㅋㅋㅋ 턴제라도 동일스펙 상대랑은 전략싸움으로 가르는 재미를 줄 수 있고 뜻밖의 전략으로 이겨버리거나 하는 등등 훨신 재밌고 깊은 전투를 만들 수 있었을텐데 턴제면 턴제답게 전략쪽으로 재미를 추구할 수 있는데 왜 그런거지

**비대칭 상호작용**

- [비대칭 PvP - 나무위키](https://namu.wiki/w/%EB%B9%84%EB%8C%80%EC%B9%AD%20PvP)

    각 팀이 동등한 조건으로 시작하는 일반적인 PvP 장르와 달리, 다수/약자 플레이어 팀[1]이 소수/강자 플레이어[2]와 대결하는 게임이다. 일명 나쁜 녀석(Bad Guy) VS 좋은 녀석들(Good Guys) 게임

## 25.02.07

[How I got here - Inside thoughts](https://pthorpe92.dev/intro/my-story/)

- Preston Thorpe : 백엔드 시니어 프로그래머

> EDIT: Wow.. I definitely wasn’t expecting this to get to the front page of HN. In light of this, and some harsh, but undoubtedly fair comments that were made(as well as some completely ignorant ones). I would like to add some clarification on a few things.

    I have been an opioid addict for over 10 years, and to this day prescribed suboxone, being treated for OUD as well as recently having been cured of HEP C from years of drug abuse.
    As an addict and someone that has seen this lifestyle, and drugs in particular claim the lives of countless friends (2 of them extremely close to me. RIP Mark Bochner, Scott Young.) 
    I am absolutely, and forever will be ashamed of any participation I had in that lifestyle and for perpetuating the scourge of addiction.
    I would like to apologize publicly to anyone that has been affected by this, and there is no excuse for my actions, other than the same (terrible) one I give am forced to give for all of them.
    That I was young, ignorant, addicted, and I held absolutely no value for own life, nor lives of others.
    I am genuinely sorry and ashamed on a level that could never be properly communicated, and I understand that although I will have to live with that for the rest of my life, many others will not get that chance.

    In the system, people are very open and accepting of their fate.
    Jokes are often made about how short someone was ‘on the street’, or bets will be placed how quickly someone will be back (always in months).
    Everyone speaks about release as if it is temporary, like a vacation from their accepted fate of prison or death.
    This is contagious, and when someone loses all value for their own life in acceptance of that fate, it creates a population of miserable, hopeless people with nothing to lose.
    As stated in the original post: I did not value my own life, nor did I believe I was capable of anything more than the life I had resided to.

- 십대 시절 마약 거래 범죄를 저지른 혐의로 수감됨. 그 후 출소 후 빈털터리 상태로 인생이 끝나버릴 줄 알았지만, 메인 주 (State Of Maine) 의 대학에서 교육을 받을 기회를 얻음.
- 이 시기에 다시 개과천선 할 수 있었다고 회상함.

    I enrolled in College through the University of Maine Augusta, and before classes even started, I was completely enthralled with the idea of learning how to program again (it had been 15 years since I had done some PHP/Perl + simple websites, so not a lot had left over)

- 출소 이후 빈털터리 상태라 갈 곳이 없었는데, 그 시절에 지냈던 아파트 이야기가 섬뜩했음

    A few years later, I left prison with $0 in my pocket (lawyers and commissary are expensive, and nobody pays you what they owe you when you come in), to a rooming house with hallways that smelled like crack-smoke and were filled with parole officers and junkies. I was left with the difficult choice of either living there and walking to a temp agency with hopes of making $10.50/hour doing manual labor (without an ID or social security card at this point), or getting on a bus to NYC to see some associates, and coming back in a week or so with $15-25k in my pocket and living in comfy luxury hotels until I could rent an apartment… I chose the latter: and obviously, was back in prison after a short 14 months of addiction and misery.

    I have been incarcerated now on this sentence since May of 2017, I came in with a terrible attitude, a terrible outlook on life, and no hope for my future. I have spent almost 3 years all-together in 22-23hr solitary confinement over the years (10% of my life?), and at one point I had truly become one of the people that looked at me when I first came to prison at age 20, and asked “Is this your first bid?”, to which everyone replies “first? I”m not coming back here!”, to which there is always laughter from the older heads. Everyone says that, but everyone comes back…

---

[1인 여성 개발팀으로 2백만명 사용자 달성하기  GeekNews](https://news.hada.io/topic?id=18932)

- [The StoryGraph  Because life's too short for a book you're not in the mood for](https://www.thestorygraph.com/)

> Nadia Odunayo는 The StoryGraph의 창립자이자 CEO로, 이 앱은 사용자가 독서를 추적하고 기분과 선호하는 주제에 따라 다음에 읽을 책을 선택할 수 있도록 도움을 줌. 그녀는 Pivotal Labs에서 소프트웨어 엔지니어로 일했으며, 런던의 Makers Academy에서 코딩을 배움. 여가 시간에는 춤 수업을 듣고 독서를 즐김.
>
> The StoryGraph는 100만 명 이상의 독서 애호가들이 모인 커뮤니티로, Nadia가 혼자서 개발한 앱임. 그녀의 이야기는 "1인 프레임워크"를 실행하는 데 필요한 끈기와 통찰력을 보여줌.

## 25.02.11

[You should write without bugs](https://korshakov.com/posts/no-bugs)

- 버그가 나지 않는 코드를 짜면 개발 속도가 더 빨라진다.

    Over the years, when I led or joined a team, I would say, “We write code without bugs.” Everyone would laugh, but then we would actually ship without bugs. Why is that?

    ...

    If you search this topic online, you’ll find many people arguing that bugs aren’t a big deal and that you should focus on shipping features. On the other side, there are purists who want to cover 99.99% of the code with tests and verify that their code works all the time. The thing is, this isn’t a binary question — whether buggy software is acceptable or not — but rather a spectrum. Still, people prefer binary thinking, and there are very few nuanced discussions on this topic.

    People on the purist side of things are usually obsessed with processes, not with making a product. Conversely, there are people with commitment issues; they want to experiment non-stop and thus have no faith in robustness. People in the middle typically don’t hold a strong opinion—they just try to be non-contrarian, unifying beings.

> 순수주의자들은 보통 제품을 만드는 것보다 프로세스에 집착합니다. 반대로, 헌신에 문제가 있는 사람들은 끊임없이 실험하고 싶어 하며, 따라서 견고성에 대한 신뢰가 없습니다. 중간에 있는 사람들은 보통 강한 의견을 가지지 않으며, 단지 반대하지 않고 통합하려고 노력합니다.

- 꼼꼼히 테스트를 작성하거나, 단순 개발을 빠르게 하기 위해 스파게티 코드를 작성하거나
- 어느 쪽이나 극단적으로 추구하면 문제가 생김. 프로세스에 너무 집착하면 개발 진척이 더뎌지고
- 너무 빠르게 만들려고 하면 버그투성이가 된다.
  - 중간의 사람들은 보통 강한 의견을 가지지 않음. 전체 의견에 동조하려 함.

    ...

    Over the years, both extremes have proven to be wrong, and the most important thing is that both tend to end up with very slow performance, high costs, low quality, and a high risk of burnout.

    While the reason for the purists’ slowness is obvious, the slowness of the other side is less so. On that side, people keep shipping features and slamming them together, which quickly makes the codebase unmaintainable. How quickly? Within a few weeks, many parts can become so convoluted that you can’t isolate problematic areas to rewrite them—everything depends on everything else. Meanwhile, some “successful” experiments also turn out to be problematic: they’re neither robust nor scalable and eventually require a full rewrite, costing a lot of time and money and, more importantly, posing a risky move for the business and the team’s mental health.

    You might think it’s possible to balance these two extremes: some people rapidly ship features, while others focus on making the product robust, scalable, and maintainable. In my experience, this never works for a simple reason: business people don’t usually care about the second group, and that group will feel they’re not really part of the company. You see this in big tech companies, too—nobody cares about fixing bugs because you only get rewarded for shipping new features. That’s probably why some Google apps are such a mess.

    **So what’s the way out? In my opinion, the only way is to write code “without bugs.”**

    A short story: I was almost kicked out of school for low performance in Russian language (even though I was excelling at programming). However, I managed to pass the exit exam and ended up as one of the best performers in the school. My “trick” during that final year was simple: I always tried to write correctly, not just when I was asked to, but all the time. After a year of subconscious improvements, I aced the exam.

- 피쳐 구현 조직과 유지 보수 조직을 분리해버리면, 유지 보수를 맡은 인원들 사이에서 불만이 생김. 유지 보수 작업은 스포트라이트를 받는 일이 드물다. 자신이 중요하지 않은 일을 하고 있다고 생각하게 됨
- 글쓴이가 생각하는 결론은... 그냥 처음부터 버그 없는 코드를 짜는 것


    When I’m thinking about tech design decisions,
    I think a few steps ahead but not too far, i am thinking about ergonomics of developer.
    It may take minutes or even hours, but it’s a good investment.

    Sometimes, to bootstrap a project, I’ll spend a couple of days figuring out a solid initial approach.
    It won’t be permanent, but it’s a good starting point that I continue to refine in the same manner.
    Let’s say you have a project: you want to check that the compiler works, that tests can be written easily, and you discard anything that will slow you down (looking at you, React Server Components).
    Maybe you slap some CI onto it (it’s free now and often just a one-click setup).
    Some days, I’m obsessed with reducing development complexity.
    I have yet to see such obsession being waste of time - almost always projects started to slow down to halt and needed it anyway.
    Instead of hacking something together, I’ll spend a bit more time making it reliable and flexible.
    Sometimes it feels like overkill, but it’s much better than spending weeks later on a convoluted codebase that doesn’t work. 
    I might wrap certain libraries in simpler interfaces so they can be used everywhere without adding too much complexity. 
    Isolate code that changes every day from the one that wouldn't at all. 
    Sorry for generic advices: it is all common knowledge, no secrets here.

- 본인은 인간 공학(ergonomics) 을 항상 고려함. 프로젝트 초창기에 설계를 다듬을 때 인간 공학 관점에서 시간을 좀 더 투자하는데, 이것을 효율적인 투자라고 생각함
- 의식적(consciousness)으로 하나 하나 다루다 보면 속도가 느려진다. 무의식(subconscious) / 근육 기억의 영역에서 자연스럽게 이어지도록 구조를 설계하는 것이 더 유연한 소프트웨어를 위한 방법임
- 뭔가를 학습(study)에 사용하는 시간을 최소화 해야함. 학습은 의식적인 것(conscious). 조금만 보더라도 자연스럽게 개념과 경험이 이어진다면 무의식의 영역에서 깨닫게 할 수 있음(subconscious)

## 25.02.14

**멀티 코어 기준 CPU 사용량 측정 방식 및 Windows에서 CPU 계측 값 종류**

by ChatGPT

- **1. 멀티 코어 기준 CPU 사용량 측정 방식**

| 항목                           | 설명                                                                                                   |
| --------------------------     | ----------------------------------------------------------                                             |
| **전체 CPU 사용률**            | 모든 논리 코어의 CPU 사용률을 합산하여 전체 사용률을 계산 (각 코어의 사용률을 모두 더함).              |
| **개별 코어 사용률**           | 각 논리 코어의 사용률을 개별적으로 측정 (예: 코어 1, 코어 2, 코어 3...).                               |
| **논리 프로세서**              | 멀티 코어 시스템에서 각 코어는 하나의 논리 프로세서로 처리됨. 각 프로세서에 대한 독립적인 사용률 측정. |

- **2. Windows에서 CPU 계측 값 종류**

| 계측 값                                   | 설명                                                        |
| ----------------------------------        | ----------------------------------------------------------  |
| **Processor(_Total)\ % Processor Time**  | 전체 CPU 사용률을 측정. 모든 코어의 평균 CPU 사용률.        |
| **Processor(_Total)\% User Time**        | 사용자 모드에서 실행되는 프로세스의 CPU 사용률.             |
| **Processor(_Total)\% Privileged Time**  | 커널 모드에서 실행되는 프로세스의 CPU 사용률.               |
| **Processor(<CoreX>)\% Processor Time**  | 특정 코어의 CPU 사용률을 측정 (X는 코어 번호).              |
| **Processor(<CoreX>)\% User Time**       | 특정 코어에서 실행되는 사용자 모드 프로세스의 CPU 사용률.   |
| **Processor(<CoreX>)\% Privileged Time** | 특정 코어에서 실행되는 커널 모드 프로세스의 CPU 사용률.     |
| **Processor(_Total)\% Idle Time**        | CPU가 유휴 상태에 있을 때의 시간 비율 (사용되지 않는 시간). |
| **Processor(_Total)\% Interrupt Time**   | 인터럽트 처리에 소비된 CPU 시간 비율.                       |
| **Processor(_Total)\% DPC Time**         | Deferred Procedure Call(DPC)에서 소비된 CPU 시간 비율.      |

- Processor Time = User Time(Application) + Privileged Time (Kernel)

- **3. 기타 계측 값**

| 계측 값                                   | 설명                                                            |
| ----------------------------------        | ----------------------------------------------------------      |
| **\System\Processor Queue Length**        | CPU가 처리할 준비가 된 작업 큐의 길이를 측정.                   |
| **\Processor(_Total)\% Hypervisor Time**  | 하이퍼바이저에서 처리된 CPU 시간 비율 (가상화 환경에서만 유효). |
| **\Processor(<CoreX>)\% Hypervisor Time** | 특정 코어에서 하이퍼바이저가 차지하는 CPU 시간 비율.            |

---

in powerShell

`Get-Counter '\Processor(_Total)\% Idle Time', '\Processor(_Total)\% Processor Time', '\Processor(_Total)\% Privileged Time', '\Processor(_Total)\% User Time', '\Processor(_Total)\% Interrupt Time'`

^ 이걸로 측정 가능

## 25.02.17

[(281) The Aging Programmer - Kate Gregory - NDC TechTown 2024 - YouTube](https://www.youtube.com/watch?v=mVWQQeSOD0M)

- [나이 들어가는 프로그래머 - 발표영상 요약  GeekNews](https://news.hada.io/topic?id=19034)
- 시력 등의 건강 / 직장 내 에서의 환경과 대우의 변화 등등 에 관한 내용

**야간 운전**

    50대에 접어들면 야간 운전 문제가 생길 수 있음
        TV 광고에 나오는 노란색 선글라스 등은 효과가 없으니 구입하지 않는 것이 좋음

    야간 시야 문제 중 하나인 백내장(cataract)은 정기적인 시력 검사를 통해 조기 발견 가능하며, 수술로 개선될 수 있음
        또한 야간 시야 문제의 원인은 다양하며 백내장이 아닌 경우도 많음

    주요 문제는 대비 변화로, 어두운 길을 운전하다가 밝은 화면을 보면 시야가 흐려질 수 있음
        차량 선택 시 큰 화면 대신 조작이 쉬운 물리적 버튼이나 슬라이더가 있는 차량을 고려하는 것이 좋음
        화면에서 번지는 빛이나 반사로 인해 시야가 방해받을 수 있음

    안경, 차량의 유리창, 헤드라이트를 깨끗하게 유지하는 것이 중요함
        시력에 어려움이 있을수록 먼지와 얼룩의 영향이 커짐
        나이가 들수록 청결에 더 신경을 쓰는 이유는 이러한 문제를 줄이기 위함임

    비타민 A가 풍부한 음식을 섭취하면 시력 유지와 개선에 긍정적인 영향을 줌
        당근, 빨간 피망, 토마토와 같은 채소 및 짙은 녹색 채소는 야간 시야와 대비 문제를 개선하는 데 도움을 줄 수 있음

        야간 운전을 피하기 위해 도보로 이동하거나 대중교통을 이용할 수 있는 거리에 거주하는 것도 한 가지 방법임
    이러한 변화는 긴 시간 동안 신중하게 계획하여 스트레스 없이 적응하는 것이 바람직함
        갑작스러운 상황에서 비합리적인 결정을 내리기보다는 장기적인 계획이 필요함

**운동은 신체와 정신을 건강하게 함**

    난 그냥 운동 안하고도 건강하기를 바랬지만, 안타깝게도 운동은 실제로 좋음
    단순히 활동적인 생활방식(도보 이동, 카약 등 취미)만으로는 충분하지 않을 수 있음
    건강한 몸을 유지하기 위해 의도적으로 반복적인 운동을 해야 함

        반복적인 움직임은 통증을 줄이고 유연성을 향상시킴

            “움직임은 윤활제Motion is lotion 

            - 히포크라테스hippocrates

        라는 표현처럼, 꾸준히 움직이는 것이 통증 완화와 체력 증진에 도움을 줌
        노화와 함께 몸을 굽히거나 높은 곳에 손을 뻗는 기본적인 능력이 감소하며, 운동을 통해 이를 유지 가능함

    면역 체계의 많은 부분이 근육에서 작동하며, 운동을 통해 면역력이 강화됨

        운동은 기분을 개선하고, 학습 능력을 높이며, 건강에 긍정적인 영향을 미침

        “운동할 시간이 없다고 생각하는 사람들은, 결국 언젠가는 병을 앓을 시간을 마련하게 될 것” 

        — 에드워드 스탠리(edward stanley, 1826–1893)

**다른 사람들(Other People)의 인식**

    설문 조사에서 "연령 차별"에 대해 물어 봤는데 실제로 차별이 있음
        "내가 배우지 못할거라 가정함" : 새로운 기술에 대해 학습 여부를 묻지 않고, 배우고 싶다는 의사가 있다고도 생각하지 않음
        "유능하다면 지금쯤 관리자가 되었어야 한다"는 고정관념으로 인해 기술적 역량이 평가절하됨
            비관리자인 상태가 브랜드에 부정적 영향을 준다는 편견이 있음
        이메일 및 음성 통화로 진행된 채용 과정이 비디오 인터뷰로 전환되면서 기회가 사라지기도 함
            이는 외모, 특히 머리 색 등 연령과 관련된 편견에 기인
        "회사 문화에 맞지 않을것 같아요":

            이 표현은 종종 나이가 많다는 이유로 지원자를 배제하기 위한 명분으로 사용됨
            이러한 연령 차별은 고령자의 전문성과 경험이 간과되는 문제를 초래함

    남성과 여성 모두 노화에 따른 어려움을 겪지만, 여성에게 더 큰 영향을 미침
        남성은 가끔 "경험이 풍부한" 또는 "존경받는" 이미지를 얻는 반면, 여성은 거의 해당되지 않음

    소규모 회사에서는 개별적으로 평가될 가능성이 높지만, 대규모 회사에서는 연령에 따른 고정관념에 더 쉽게 묶임
        그러나 대규모 회사는 기술적 경력 개발을 위한 "기술적 승진 제도(Ladder)"를 제공할 수도 있음
        그래서 사람들이 종종 컨설팅으로 많이 옮겨감
            내부 직원으로는 "63세인 당신에게 왜 교육을 제공해야 하나?"라는 편견에 직면할 수 있음
            외부 컨설턴트로 활동하면 "63세라면 정말 많은 것을 알겠군요!"라는 긍정적인 인식을 받을 가능성이 높음

**만약 당신이 "Other People" 이라면**

    예를 들어 당신이 ‘나이 든 사람들은 배울 수 없다’, ‘나이 든 사람들은 회사 문화와 어울리지 않는다’거나, ‘소프트웨어 개발 과정에서 4층 계단쯤은 뛰어오를 수 있어야 한다’고 생각하는 사람이라면?
    그런 생각이 못되고 잘못되었다고 굳이 말하고 싶지는 않음

    대신, 그게 여러분에게 어떤 결과를 가져다줄지를 말씀드리고 싶음
    만약 여러분이 ‘나이 드는 건 끔찍해’라고 믿는다면, 실제로 끔찍한 노년을 맞이하게 될 것
        그리고 그건 단순히 기분이 우울하고 외로워진다는 차원만이 아님

    나이든 사람들에 대한 당신의 태도가, 당신의 나이에 영향을 미침
        노화에 대해 부정적 고정관념을 가진 사람은 심장마비나 뇌졸중의 위험이 더 높으며, 입원 가능성도 50% 증가
        노화에 대한 긍정적 관점이 스트레스와 고통을 줄이고 더 건강한 노년을 보장

    "나는 할 수 없다"는 태도는 삶의 범위를 좁히며, 부정적인 노년을 초래함
        반대로, "새로운 방법을 배우거나 적응할 수 있다"는 사고방식은 긍정적이고 활기찬 노년을 만듦
        기여할 수 있는 역량이 여전히 많다고 믿는 태도가 중요

**단기 기억과 작업 메모리(Short term memory, working set)**

    단순한 건망증(예: 왜 여기에 왔는지 잊는 경우)은 치매의 신호가 아님
    빈번한 건망증의 원인은 물리적 또는 환경적 요인일 수 있음
        시각적 정보 부족: 작성한 목록이 읽기 어렵거나 잊어버림
        청각적 정보 부족: 요청 내용을 제대로 듣지 못하고 추측하는 경우
        수면 부족: 수면이 부족하면 기억력과 집중력 저하 발생

    해결 방법은 습관과 루틴 형성:
        모든 것에 대해서 지정된 위치를 만들고 거기에다 두는 물리적인 부분 부터 시작
        알람, 일정 관리 앱, 스크립트 등 기술을 활용할 것

    체크리스트와 프로세스 만들기
        복잡한 절차 대신 단순한 방식으로 작업을 처리하면 실수를 줄이고 부담을 완화 가능
            예: 27단계의 복잡한 절차 대신 간소화된 프로세스를 사용하여 중간에 방해받아도 쉽게 재개 가능

    멀티태스킹에 너무 의존하지 말 것
        나이에 따라 멀티태스킹에서 단일 작업에 집중하는 방식으로 작업 스타일을 조정해야 할 필요가 있음
        나도 한때는 멀티태스킹(예: 컨퍼런스 청취 중 이메일 정리, 소셜 미디어 확인)이 효과적이었음
            대화 내용을 듣다가 중요한 시점에만 화면을 확인하며 작업을 병행
        그러나 멀티태스킹은 중요한 정보를 놓치게 만들 가능성이 높음
            예: "누가 모듈 얘기했지?"처럼 정보를 놓쳐 다시 확인해야 하는 상황 발생
        현재는 한 가지 작업에 완전히 집중하는 방법으로 전환
            컨퍼런스 영상을 빠른 속도로 재생하여 모든 주의를 기울이는 방식 채택
            화면에 표시된 단서(슬라이드 내용, 코드 등)를 함께 보며 더 깊이 이해

        멀티태스킹을 줄이고 집중력을 높이는 습관이 작업 효율성을 향상시킴
        영상을 빠른 재생 속도로 시청하면 집중력을 유지하면서도 시간을 절약 가능
            예: 1.5배속으로 시청하면 1시간짜리 강연을 더 짧은 시간 내에 완료

        집중력을 완전히 투자하여 멀티태스킹을 피하는 방식이 효율적인 학습에 도움이 됨

    개인의 뇌 구조와 기능의 다양성을 이해하고 수용

        ADHD나 자폐 스펙트럼을 가진 사람들은 독창적인 대처 기술을 통해 어려움을 극복
            뇌가 즉각적인 도움을 주지 않을 때도 작업을 완료하는 방법을 알고 있음
        이러한 특성은 일부 사람들에게 익숙하지 않을 수 있지만, 이러한 기술은 자신에게도 유익하며 적용 가능
        인터넷 검색, 친구들과의 대화를 통해 다양한 대처 기술을 발견 가능
            기억력 부족이나 여러 단계의 작업을 중간에 멈추는 문제를 해결하기 위한 도구와 팁이 다수 존재

    뇌 훈련 게임이 도움이 될까?
        색깔 맞추기, 단어 찾기 등은 게임 자체의 실력을 높이는 데는 도움되지만, 전반적인 인지 능력이나 처리 속도를 향상시키지는 않음
        광고에서 주장하는 효과와 실제 효과가 다름

    즐겁게 읽는 독서나 흥미로운 학습은 인지 능력과 처리 능력에 실질적인 도움을 줌

        예: 그림 그리기 배우기, 스탠드업 패들보드 배우기, 소설 읽기 등
        독서는 창의력과 인지 능력을 자극하며, 스트레스를 줄이고 삶의 질을 향상

**계속해서 등장하는 "새로운 것(New Stuff)" 따라잡기**

    "또 다른 프로그래밍 언어를 배워야 해" 같은 이야기를 하자는 게 아님
        이미 직장에서 충분히 스트레스 받고 있음

    많은 사람들이 계속해서 새로운 것들을 익혀야 한다는 데 대해 불평을 함
        그것도 꼭 필요한 이유가 있어서라기보다는, 단지 ‘8년째 이 패러다임을 쓰고 있으니 이제 다른 패러다임으로 갈 때가 됐다’ 같은 이유일 때가 많음

    사실 배우려고만 하면 대부분 배울 수 있음 (그렇게 하고 싶지 않은건 다른 문제)

    ‘Git 같은 건 배우고 싶지 않아’라고 느끼는 건, 사실 Git 자체가 어려워서가 아님
        우리는 이미 어떻게 학습해야 하는지 알고, 빠르게 훑어보고 과거의 경험과 연결 지을 수 있음
        ‘아, 이건 내가 대학 시절에 쓰던 그거랑 비슷하네?’

    그럼에도, ‘나는 웹 같은 건 안 다뤄. 데스크톱만 하는 사람이야, C++만 쓰는 사람이야. 그런 바보 같은 웹 기술은 필요 없어’라는 식으로 스스로를 정의해버리면, 새로운 걸 받아들이기 싫어질 수밖에 없음
    하지만 변화 자체를 기꺼이 수용한다면, 그게 새로운 언어든, 새로운 프레임워크든, 새로운 패러다임이나 툴이든, 혹은 완전히 다른 사고방식이든, 훨씬 유연해질 수 있음

        같은 도구일지라도 생각하는 새로운 방법이 있을 수 있음

    자신의 업무 정체성(Identity)을 사용하는 도구가 아니라, 달성한 성과와 해결한 문제로 정의해야 함

**기분(Moods)**

    많은 사람들이 자신이 늙으면 짜증을 잘 내고, 조급해지고, 냉소적이고, 집중력이 약해질까 봐 걱정함
    보통은 ‘나는 저 사람처럼 되고 싶지 않아’ 같은 구체적인 모델이 있기도 함
    하지만 치매와 마찬가지로, 이런 성격 변화도 불가피한 건 아님

    20대에 다정하고 관대한 사람이라면, 대체로 80대에도 여전히 그렇게 지낼 가능성이 높음
    다만 한 가지 전제조건이 있음
        생계에 대한 걱정이 없고, 필요한 게 충족될 때 우리는 쉽게 따뜻하고 너그럽고 친절할 수 있음

    삶의 기본 안정성이 부족할 경우, 긍정적인 태도를 유지하거나 다른 사람에게 관대해지기가 어려움
        예: 생계 유지에 대한 불안, 집을 잃을 걱정, 지지해 줄 사람들의 부재 등은 부정적인 태도를 유발할 수 있음
        이런 환경에서 계속 환하게 웃고 친절하기는 정말 어렵고, 사람은 당연히 짜증과 우울감에 빠지게 됨

    결국, 젊을 때부터 안정적인 노년을 위한 계획을 세우고 편안한 노후를 준비해둬야, 그 시기에 여유롭게 다른 이들에게 따뜻함과 관용을 베풀 수 있음
    지금 친절하지 않다면, 나이가 든다고 해서 마법처럼 "친절한 사람"이 되는 것은 아님
        친절해지고 싶다면 지금부터 실천하면 됨; 특별한 면허가 필요하지 않음

**수면(Sleep)**

    수면은 최고의 디버거이며, 신체가 상처를 치유하고 회복하는 시간
        나이가 들면서 수면 필요량이 증가하거나 감소하는 것은 정상적인 현상

    더 많은 수면이 필요한 사람은 게으른 것이 아니며, 더 적게 자는 사람이 특별히 미덕을 가진 것도 아님
        수면 시간은 개인마다 다르며, 자신의 필요에 맞는 만큼 자는 것이 중요
        예: 88세인 내 어머니는 하루 일찍 일어나기 위해 알람을 설정하지만, 더 늦게 자는 사람이 게으른 것은 아님

    좋은 수면은 신체적, 정신적 젊음을 유지하는 데 기여
        연구에 따르면, 한 달간 양질의 수면은 6년 젊어진 기분을 느끼게 하고, 단 이틀의 수면 부족은 4.5년 더 나이 든 것 같은 피로감을 줌

**상실(Loss)**

    상실은 삶의 일부이며, 누구도 피할 수 없음
        예: 장례식 참석, 회사 폐업, 친구와 멀어지고/바꾸거나/죽기도 함
        어떤 상실은 예상 가능하고, 어떤 상실은 갑작스럽게 찾아옴

    일상에서도 작은 상실을 경험:
        좋아하던 아이스크림이 단종됨
        신체적 한계로 더 이상 좋아하던 활동(예: 등산, 스키)을 할 수 없게 됨

    작은 상실도 축적되며 감정적으로 영향을 줄 수 있음
    상실을 치유하는 유일한 방법은 새로운 것을 얻는 것임 (The only cure for loss is gain)

    "Well something's lost, but something's gained In living every day" — Joni Mitchell, Both Sides Now
    “뭔가는 잃게 되고 또 뭔가는 얻게 되지, 매일을 살아가는 동안에”

    조니 미첼이 20대에 쓴 노랫말인데 혹자는 20대가 무슨 인생경험을 알겠어?라고도 함
        그녀는 20대에 캐나다 중부에서 대도시 토론토로 이주했다가, 아이를 낳고, 위탁 가정에서 그 아이를 데려오기 위해 누군가와 결혼도 함. 그가 아이에 관심이 없다는 사실을 알고 이혼하고 다시 입양을 보냄. 이후 뉴욕을 거쳐 캘리포니아로 이주한 뒤에야 이 곡을 썼음
        생각보다 인생의 ‘잃음과 얻음’을 잘 알고 있었던 것. 그로부터 훨씬 나중에는 뇌동맥류를 겪어서 걷거나 말하는 능력을 잃을 뻔했지만, 다시 무대에 서서 이 노랫말을 직접 부를 정도로 회복해냄

    하지만 중요한 것은 이거임:
        상실은 저절로 우리에게 찾아오지만, 무언가를 얻는 건 결국 우리가 직접 해내야 함

## 25.02.20

**인프라 테스트에서 에러 발생하는 케이스**

- failover 이후 Lazy Loading: 장애 상황이 발생한 서비스 프로세스는 종료되고, 예비 프로세스가 이어서 대응
  - 이때 예비 프로세스가 기존 접속했던 사용자들의 요청을 이어서 처리하게 되는데, LazyLoading 방식을 사용하고 있었다면 이 상황에 취약함
  - 기존 접속 사용자들의 요청 처리를 해야하는데, 이전 서비스는 LazyLoading 을 전부 완료하고 캐시 데이터를 사용하고 있었다면 장애 이후 새로 동작하는 프로세스는 아직 캐시가 비워져 있어서 LazyLoading 절차를 처음부터 해야하기 때문
  - DB 쿼리 등 LazyLoading 부하가 순간적으로 스파이크 튈 수 있다.
- failover 이후 일부 서비스 기능 이상: 메모리에 저장하는 자원들이 있었음
  - 만나봤던 케이스는 사용자들의 접속 여부를 메모리에만 저장하는데 페일오버 이후 휘발되어버린다.
  - 유저의 접속 상태를 집계하는 방식이 -> 첫 접속시 set, 접속해제 시 offline 상태로 set 하고 있었던 상태
    - 하트비트 방식으로 접속 중에는 주기적으로 online 상태를 갱신하는 방식이 견고했을 것 같다.
    - 우선을 빠른 대응을 위해 유저가 요청을 보낼 때마다 online 상태를 set 하는 걸로 대응. 이 방식의 허점은 failover 이후 유저가 첫 요청을 보내기 전까지 offline 상태로 인식함. 유저가 아무것도 안 한다면 서비스가 잘못 인식할 수도 있는 것.

## 25.02.21

[C++ Debugging with AI-Generated breakpoint expressions](https://devblogs.microsoft.com/visualstudio/supercharge-c-debugging-with-ai-generated-breakpoint-expressions/)

> Have you ever spent hours debugging your C++ code, struggling to set up the right conditional breakpoint or tracepoint? Or wished for a smarter way to obtain detailed runtime information without manually crafting complex expressions? You’re in luck! With Visual Studio 2022, the latest GitHub Copilot feature now offers AI-generated expressions for both conditional breakpoints and tracepoints, available from C# 17.10 and now extended to C++. With these AI-generated conditional breakpoints and tracepoints, you can now automate the creation of intelligent expressions tailored to your specific debugging needs, significantly speeding up the process and enhancing your ability to diagnose and resolve issues.

![image_2025-02-21-17-25-37](img/image_2025-02-21-17-25-37.png)

디버그 모드 중단점(breakpont)를 지정할 때, break 조건을 같이 설정할 수 있다.

- 하지만 좀 까다로운 점이, 이 중단점 연산을 input 입력할 때 코드 분석을 지원하지 않아서 정작 필요할 때 컴파일 오류를 낼 때가 허다했는데, ai 가 만들어주면 훨씬 낫겠지 싶은 감상

## 25.02.24

[일러페스 6 '늙은 오타쿠'가 '서브컬처 게임' 개발자에게 건네는 조언](https://www.thisisgame.com/webzine/nboard/263?n=205801)

> 2월 10일, 일러스타 페스 6의 부대 행사 '일러스타콘'에서 <에버소울>의 김철희 총괄 PD가 '늙은 오타쿠의 서브컬처 게임 개발기'를 주제로 강연했다

- [(312) 늙은 오타쿠가 늙은 오타쿠를 공감하는 영상 - YouTube](https://www.youtube.com/watch?v=-FvSRrSdBJc)

**서브컬처 게임은 레드오션 "투자자가 꺼린다"**

김철희 디렉터는 "불편한 이야기지만, 최근 서브컬처 게임은 투자를 받기 어렵다"고 했다. 이유는 다음과 같다.

1. 디테일이 중요해 초기 개발 비용이 크다.
2. PvE나 신규 캐릭터 위주의 BM이 형성되기에 다른 게임에 비해 라이브 서비스 유지 비용이 크다.
3. 그럼에도 수익이 타 장르 게임에 비해 크지 않다. 즉, 가성비가 나쁘다.

    만약 100억을 투자받아 게임을 개발한다고 가정하면, 보통 이 정도의 돈이 들어간다.

    중위연봉 5천만 원 기준 부대비용을 포함해 개발자 1명의 1년 비용은 '대략 1억'이다. 단순 계산으로 기획, 프로그래머, 아트, 기타 인원을 합쳐 50명의 개발진이 딱 2년 개발할 수 있는 비용이다. 이것도 단순 예시를 위한 것일 뿐 실제로는 더욱 어렵다. 서브컬처 게임의 전체적인 퀄리티가 올라가고 디테일이 중요하게 여겨지는 시기에 50명으로 할 수 있는 것은 많지 않다. 2년이라는 개발 기간도 매우 촉박하다.

    여기에 사운드, 외주비, 더빙과 같은 추가 비용까지 고려하면 개발비는 더욱 소모된다. 기획이 중간에 엎어지거나 출시가 연기되면 최소 50억의 개발비가 더 필요해진다. 김철희 디렉터는 "이외로 100억이란 개발비로 할 수 있는 것이 많지 않다"고 했다.

...

**3 - 타 게임과의 비교에 주의**

    서브컬처 게임만의 특징으로는 유사 장르 게임간의 비교가 있다. 

    <에버소울>은 첫 시즌 이벤트에서 마트의 '매대'와 같은 방식으로 이벤트 상점을 구성했다. 여러 가지 상품이 존재하고 플레이어가 사고 싶은 것만 구매해 가는 것이다. 매대 방식으로 마련된 만큼 유저가 이벤트 상점의 모든 것을 구매하기는 어려웠다. 김철희 디렉터는 "엄청나게 허튼 생각이었다. 살면서 먹을 욕을 다 먹고 정신이 혼미해졌다"고 말했다.

    김철희 디렉터는 나중에 분석을 해 본 결과, 다른 유사 장르와 비교하면서 게임을 플레이한다는 사실을 알았다고 했다. 서브컬처 게임 소비자는 게임의 정책이나 규칙 뿐만 아니라, 스토리 퀄리티와 과금 효율 등등 많은 것을 타 게임과 비교한다.

    "이 게임은 트럭 하나(대략 10만원 이상)에 뽑기 몇 번을 할 수 있냐"는 질문이 통용되는 곳이 서브컬처다. 그래서 타 게임과 비교하며 자신의 게임이 특별이 불합리한 부분이 없나 살펴야 한다.

...

**4 - 게임 엔진 업데이트는 신중히**

    <에버소울>은 유니티 엔진 2020년 버전으로 개발됐으나, 2022년 버전으로 크게 업데이트를 한 적이 있다. 2020년 엔진의 서포트가 중단되기도 했고, 유니티의 정책 업데이트로 인해 필수불가결한 상황이었다. 엔진 업데이트는 중요한 만큼 오랜 시간을 투자해 클라이언트에 업데이트됐다. 

    초기에는 큰 문제가 없었지만, 게임의 메모리 점유율이 급증하고, 알 수 없는 렉, 크래시, 45프레임 설정 불가 등 온갖 문제가 터져나왔다.

    김철희 디렉터는 "지옥 같은 시간이었다"고 당시를 회고했다. 모든 캐릭터의 최적화를 다시 하고, 캐릭터마다 전투용과 컷신용 모델링을 구분했다. 45프레임 지원은 연구 끝에 포기했다. 프리징 문제는 도저히 고쳐지지 않아 머리를 싸맸는데, 어느 날 유니티에서 "엔진에 버그가 있었다"는 연락이 오며 해결됐다.


## 25.02.25

[Please stop recommending Git Flow! – George Stocker](https://georgestocker.com/2020/03/04/please-stop-recommending-git-flow/)

- [Git 브랜치 전략 Git Flow와 GitHub Flow](https://f-lab.kr/insight/git-branch-strategy-20240523)
- git flow 와 github flow 라고 국내 개발 블로그 사이에서는 유명한 듯 한데, Hacker News 나 Wikipedia 에서 찾아보면 그렇게 내용이 많진 않다.

![image_2025-02-25-15-20-04](img/image_2025-02-25-15-20-04.png)

- Gitflow violates the “Short-lived” branches rule
- Gitflow abandons rebasing
- Gitflow makes Continuous Delivery Improbable

그리고 국내 개발 블로그에서 `github flow` 라고 말하는 것은 아무래도 Trunk-Based Development(TBD) 가 더 직관적인 표현인 듯

- [GitHub flow - GitHub Docs](https://docs.github.com/en/get-started/using-github/github-flow)
- 정작 github 공식 문서의 gitHub flow 설명을 보면
  - pull request 생성 -> 리뷰 -> merge -> source branch 제거 
  - 위 워크플로에 대해서만 서술하고 있음.

- [What is Trunk-Based Development](https://paulhammant.com/2013/04/05/what-is-trunk-based-development/)

Quick reminder of what TBD is:

- Developers commit to a single trunk more or less exclusively
- Release engineers (or build-cop) create branches, and cherry-pick to branches more or less exclusively
- Only if a defect cannot be reproduced on trunk, is permission given to fix it on the release branch, and cherry-pick back to trunk.
- And if you get the release branch concept, it’s worth remembering:

- Trunk-Based Development means regular developers don’t commit to a release branch.
- Trunk-Based Development means you’re going to delete ‘old’ release branches, without merging them back to trunk.

## 25.03.02

[(347) 첫 직장이 별로라면? 이렇게 하세요](https://www.youtube.com/watch?v=flo9XZCPPKw)

- 그냥 가라.
- 인사팀 관점을 생각해야 함. 인사 관리자도 리스크를 회피하고 싶어함. 대부분 커리어가 아직 없는 지원자보다 한번이라도 있다면 '다른 곳에서 한번 합격점을 받았다면 최소한의 보장이 되겠지' 라는 의견이 많음. 아직 레퍼런스가 없는 사람에게 기회를 줬다가 일이 잘못되는 상황을 두려워함.
  - 과거 회사가 영 좋지 못한 회사였다...??
  - 그래도 그 회사가 범법적인 활동으로 문제를 생긴것이 아니라면 그렇게 부정적이지 않음
  - 실제 면접에서도 이렇게 대답한다면 인사팀이 긍정적으로 볼 수 있다.
    - 첫 직장으로 들어간 곳이 좋은 곳이라고 할 수는 없습니다. 하지만 당시에는 금전적으로 여유가 없어서 조금이라도 빨리 취업을 해야 겠다는 생각이었습니다. 하지만 이제 커리어 연차가 쌓이고 금전적으로 급한 상황에서 벗어나고 보니 제 커리어를 좀더 발전시키고 싶은 욕심이 생겼습니다. 그래서 좀 더 여건이 좋은 회사에 지원하게 되었습니다.
  - 라고 말하면 인사팀 입장에서는 끄덕여줌. 첫 취업이 쉽지 않다는 것은 다 알고 있음.
- 첫 직장 입사 후 바로 더 좋은 회사에 붙어서 이직하는 것도 가능한 이야기임. 1개월 차부터 이직 준비할 수 도 있는 것임. 나가겠다는 걸 말리진 못함.
  - 과거 직장경력이 문제가 될 것 같으면 애초에 지원서에 적지 않으면 됨.
  - 취준생으로 시간을 보내는 것 보다 직장에 있으면 수입도 있고 실무 경력도 얻게 됨.

## 25.03.05

[(381) 데이터 정규화가 뭔지 설명해보세요 (개발면접타임) - YouTube](https://www.youtube.com/watch?v=Y1FbowQRcmI&list=WL&index=21)

- 1NF: [First normal form - Wikipedia](https://en.wikipedia.org/wiki/First_normal_form)
- 2NF: [Second normal form - Wikipedia](https://en.wikipedia.org/wiki/Second_normal_form)
- 3NF: [Third normal form - Wikipedia](https://en.wikipedia.org/wiki/Third_normal_form)

**1정규형**

> A relation is in first normal form if and only if **no attribute domain has relations as elements.**[1] Or more informally, that **no table column can have tables as values.**

- 속성(attribute) 즉 컬럼 값은 관계(relation) 을 가질 수 없다. 즉 테이블의 컬럼 값은 테이블을 포함할 수 없다.
- 하나의 행에는 atomic 원소를 가져야 한다. 

**2정규형**

- It is in first normal form.
- It does not have any non-prime attribute that is functionally dependent on any proper subset of any candidate key of the relation (i.e. it lacks partial dependencies). A non-prime attribute of a relation is an attribute that is not a part of any candidate key of the relation.

Put simply, a relation (or table) is in 2NF if:

- It is in 1NF and has a single attribute unique identifier (UID) (in which case every non key attribute is dependent on the entire UID), or
- It is in 1NF and has a multi-attribute unique identifier, and every regular attribute (not part of the UID) is dependent on all attributes in the multi-attribute UID, not just one attribute (or part) of the UID.

- 1정규형을 만족하며, 단일컬럼의 PrimaryKey를 가지는 경우
- 1정규형을 만족하며, 복합 컬럼(compsite key)의 PrimaryKey를 가지는 면서 partial dependency를 관계의 컬럼이 없어야 한다.
  - PrimaryKey 가 아닌 다른 컬럼이 복합 컬럼 중 어느 하나의 컬럼과도 종속 관계여선 안된다.

**3정규형**

Codd's definition states that a table is in 3NF if and only if both of the following conditions hold:

- The relation R (table) is in second normal form (2NF).
- No non-prime attribute of R is transitively dependent on the primary key.

- 제 2 정규형을 만족하며, 이행적 종속 관계(transitive dependency) 인 컬럼이 없어야 한다.
  - 모든 비주요 컬럼은 primary key 에 직접적으로 종속되어야 한다.

## 25.03.06

[Git 코어 개발자는 Git을 어떻게 설정하고 사용할까  GeekNews](https://news.hada.io/topic?id=19441)

- "Pro Git" 저자인 Scott Chacon이 글로벌로 활성화한 몇 가지 Git 설정과 그 이유를 설명
- Git 을 더 좋게 만드는 ~/.gitconfig 설정을 소개함.

```
[column]  
ui = auto  
[branch]  
sort = -committerdate  
[tag]  
sort = version:refname  
[init]  
defaultBranch = main  
[diff]  
algorithm = histogram  
colorMoved = plain  
mnemonicPrefix = true  
renames = true  
[push]  
default = simple  
autoSetupRemote = true  
followTags = true  
[fetch]  
prune = true  
pruneTags = true  
all = true  

# 쓰지 않을 이유가?  

[help]  
autocorrect = prompt  
[commit]  
verbose = true  
[rerere]  
enabled = true  
autoupdate = true  
[core]  
excludesfile = ~/.gitignore  
[rebase]  
autoSquash = true  
autoStash = true  
updateRefs = true  

# 개인 취향에 따른 설정 (필요 시 주석 해제하고 사용)  

[core]  
# fsmonitor = true  
# untrackedCache = true  
[merge]  
# (Git 버전이 2.3 미만인 경우 ‘diff3’ 사용)  
# conflictstyle = zdiff3  
[pull]  
# rebase = true  
```
## 25.03.12

[catsriding  백엔드 개발자를 위한 유용한 터미널 CLI 도구 정리하기](https://www.catsriding.com/posts/terminal-cli-tools-for-backend-developers)

- [GitHub - junegunnfzf cherry_blossom A command-line fuzzy finder](https://github.com/junegunn/fzf)
  - fuzzy finder
- [GitHub - rupaz z - jump around](https://github.com/rupa/z)
  - z : 터미널 cd 기능을 좀더 편리하게
- [GitHub - ajeetdsouzazoxide A smarter cd command. Supports all major shells.](https://github.com/ajeetdsouza/zoxide)
  - zoxide : z 의 영향을 받음. 마찬가지로 터미널 cd 기능을 좀더 편리하게
- [GitHub - jqlangjq Command-line JSON processor](https://github.com/jqlang/jq)
  - jq : cli 기반 json 처리

## 25.03.13

[Improving Search Ranking for Maps  by Malay Haldar  The Airbnb Tech Blog  Medium](https://medium.com/airbnb-engineering/improving-search-ranking-for-maps-13b03f2c2cca)

- [Airbnb가 지도 검색을 개선한 방법  GeekNews](https://news.hada.io/topic?id=19177)

- Airbnb의 검색 결과는 두가지로 제공됨
  - 목록 형식 (list-results, 숙소 이미지·가격·평점 등이 표시된 카드 형태)
  - 지도 형식 (map-results, 지도를 기반으로 가격이 표시된 핀 형태)
- 기존 검색 랭킹 알고리듬은 두 형식 모두 예약 확률에 따라 정렬해 목록을 생성하는 방식이었지만, 지도에서는 개별 핀(pint) 으로 표시되므로 새로운 접근 방법이 필요


- 목록 형식에서는 위에서부터 사용자 주의가 점차 감소한다는 전제가 있음
  - 실제로 목록에서 순위가 높을수록 CTR(Click-Through Rate)이 높은 모습이 나타남
- 지도 형식에서는 숙소가 지도 위에 핀으로 흩어져 있어 순위에 따른 주의 감소가 성립하지 않고, 균등하게 분산
  - 따라서 지도 위에 노출되는 숙소를 예약 확률 순으로 제한하는 단순한 방식은 효과가 떨어짐

**균등한 사용자 주의(Uniform User Attention) 모델링**

- 지도에서 사용자 주의가 모든 핀에 균등하게 분산된다고 가정하는 접근
- 하지만 실제로 Guest는 몇 개의 핀만 클릭하기 때문에, 너무 많은 핀을 보여주면 좋은 숙소를 놓칠 수 있고, 너무 적게 보여주면 사용자가 원하는 숙소를 제외할 위험이 생김
- 지도에 표시할 핀의 수를 제한하고, 최상위 예약 확률을 가진 항목만 선택하여 노출하는 방식

**계층화된 사용자 주의(Tiered User Attention)**

![image_2025-03-13-18-37-45](img/image_2025-03-13-18-37-45.png)

- 지도 핀을 두 가지 계층으로 구분:
  - 일반 핀: 예약 확률이 높은 숙소를 가격과 함께 표시(regular oval pins with price)
  - 미니 핀: 예약 확률이 상대적으로 낮은 숙소를 작은 아이콘으로 표시 (smaller oval pin without price)

- 일반 핀은 미니 핀보다 8배 높은 클릭률을 가져서, 사용자 시선을 상위 예약 확률 숙소로 더 집중시킬 수 있음
  - 특히 데스크톱 검색에서 더 적절한 결과 제공 가능 

**할인된 사용자 주의(Discounted User Attention) 모델링**

![image_2025-03-13-18-41-32](img/image_2025-03-13-18-41-32.png)

- 사용자는 지도에서 중앙에 위치한 핀을 더 많이 클릭하는 경향이 있음
- 따라서 최적의 중심 좌표를 찾는 알고리즘을 개발하여, 예약 확률이 높은 숙소를 지도 중앙에 배치
  - 다양한 좌표 후보를 평가하여, 가장 높은 예약 확률 숙소들과의 거리가 가까운 위치를 새로운 중심으로 삼음

---

**Command & Conquer 소스코드 공개 (GPL license)**

- [EA releases recovered source code for its Command & Conquer franchise  Polygon](https://www.polygon.com/news/531365/command-and-conquer-open-source-code-ea)
- 4 타이틀이 공개됨
  - [GitHub - electronicartsCnC_Tiberian_Dawn Command and Conquer Tiberian Dawn](https://github.com/electronicarts/CnC_Tiberian_Dawn)
  - [GitHub - electronicartsCnC_Red_Alert Command and Conquer Red Alert](https://github.com/electronicarts/CnC_Red_Alert)
  - [GitHub - electronicartsCnC_Renegade Command and Conquer Renegade](https://github.com/electronicarts/CnC_Renegade)
  - [GitHub - electronicartsCnC_Generals_Zero_Hour Command and Conquer Generals - Zero Hour](https://github.com/electronicarts/CnC_Generals_Zero_Hour)

---

**업계 6년차 때 생각들, 그리고 10년차 때 생각들**

- 6년차, 10년차에 썼고 15년차에 한번 더 쓴다고 함

[업계에서 6년 있은 뒤, 마음이 바뀐 소프트웨어 개발 토픽들  GeekNews](https://news.hada.io/topic?id=3635)

- [Software development topics I've changed my mind on after 6 years in the industry - Blogomatano](https://chriskiehl.com/article/thoughts-after-6-years)

**마음을 바꾼 것들: 과거엔 싸웠지만, 이제는 믿게된 것들**

- 다양한 경험 수준을 가진 사람들로 구성된 팀에서는 Typed 언어가 더 좋음
- 스탠드업 미팅은 신참들을 살펴보는데 유용
- 스프린트 회고는 유용한 것과 좋지 않은 것(애자일/스크럼 마스터가 모든 사람의 시간을 낭비하는)이 따로 있음
- 소프트웨어 아키텍쳐가 다른 무엇보다 중요. 좋은 추상화의 나쁜 구현은 코드 베이스에 해를 입히지 않음. 나쁜 추상화나 누락된 레이어들 때문에 모든 것이 안 좋아짐
- 자바는 그렇게 나쁜 언어가 아님
- 재치있는 코드는 보통 좋은 코드가 아님. 명확성이 모든 것보다 우선
- 어떤 패러다임에서도 잘못된 코드를 작성 가능
- "베스트 프랙티스"는 상황마다 다르고, 모든것에 적용가능하지 않음. 맹목적으로 따라가면 바보가 됨
- 필요가 없는데 확장 가능한 시스템을 설계하면 나쁜 엔지니어가 됨
- 정적 분석은 유용함
- DRY는 최종 목표가 아닌 특정 문제를 피하는 것
- 일반적으로 RDBMS > NoSQL
- 함수형 프로그래밍은 만병 통치약이 아닌 또 다른 도구임

**도중에 내가 픽한 의견들 :**

- YAGNI > SOLID > DRY : 이 순서대로
     ㅤ→ You Aren't Gonna Need It : XP의 원칙중 하나
     ㅤ→ SOLID : 객체지향 설계 5대원칙
     ㅤㅤSigle responsiblity
     ㅤㅤOpen-close
     ㅤㅤLiskov substitution
     ㅤㅤInterface segregation
     ㅤㅤDependency inversion
     ㅤ→ DRY : Don't Repeat Yourself
- 연필과 종이는 잘 사용되지 않는 최고의 프로그래밍 도구
- 실용성을 얻기위해 순수성을 거래하는 것은 일반적으로 좋은 선택
- 더 많은 기술을 추가하는 것은 좋은 선택이 아님
- 고객과 직접 대화하면 더 적은 시간으로 더 정확하게 문제에 대해서 더 많이 알 수 있음
- "Scalable" 이란 단어는 소프트웨어 엔지니어의 마음에 신비롭고 깜짝 놀라게 하는 힘이 있음. 살짝 입밖에 내는 것만으로 그들을 타락한 광란에 빠져들게 함. 이 단어를 사용함으로써 무자비한 행동들이 정당화 됨
- "엔지니어"라고 불림에도 불구하고, 대부분의 결정은 뒷받침하는 분석,데이터,숫자가 없는 화물숭배(cargo-cult) 임
  - → 화물숭배: 기술적으로 진보한 누군가(사회/선조)가 배나 비행기에 특별한 화물을 가지고 실어 올 것이라고 믿으면서 기다리는 풍습
- 90% 어쩌면 93%의 프로젝트 매니저들은 효과나 효율성면에서 이득이 없어서 내일이라도 없어질수 있음
- 100번의 인터뷰를 하고나니, 인터뷰방식은 완전히 망가져 있음. 나 역시 이걸 개선할 방법을 모르겠음

**바뀌지 않은 예전 의견들:**

- 코드 스타일, 린팅 규칙 및 기타 사소한 것들을 강조하는 사람들은 미친 괴짜들임
- 코드 커버리지는 코드 품질과는 전혀 상관없음
- 모노리스들은 대부분의 상황에서 꽤 좋음
- TDD 순수주의자들은 최악임. 그들의 연약한 작은 마음은 다른 워크플로우가 존재한다는 것을 처리할 수 없음
- 10년차가 되었을때 뭐가 또 바뀌거나 뒤집혔는지 살펴보겠음

[업계에서 10년 있은 뒤, 마음이 바뀐 소프트웨어 개발 토픽들  GeekNews](https://news.hada.io/topic?id=19081)

- [Software development topics I've changed my mind on after 10 years in the industry - Blogomatano](https://chriskiehl.com/article/thoughts-after-10-years)

**바뀐 생각들**

- 단순함은 저절로 주어지지 않고, 지속적 노력이 필요한 요소임
- **복잡성을 관리하거나 이해하는 것에 자부심을 가질 이유가 없음을 깨달았음**
- 다양한 경험 수준이 섞인 팀에서는 Typed 언어가 필수적임
- Java는 재미없어서 오히려 훌륭한 언어임
- REPL은 설계 도구로서는 유용하지 않지만 탐색적 용도로는 유용함
- **실제 프로그래밍은 코드를 작성하기 전 단계에서 거의 다 이루어져야 함**
- Frontend 개발은 Kafkaesque 악몽과 같은 영역이 되었고, 더 이상 즐겁지 않음
- 우아함이라는 개념은 실제 측정 지표가 되지 못함
- 제대로 된 매니지먼트는 매우 귀중한 존재임 (오랜 경력 동안 제대로 된 매니지먼트를 거의 보지 못했음)
- DynamoDB는 특정 워크로드에 정확히 부합한다면 좋은 데이터베이스임
- 객체지향은 잘 맞는 영역에서 탁월한 방식임. Functional만 맹신하는 태도는 어리석음

**얻게 된 의견들**

- 엔지니어링의 핵심은 소통
- Java에서 Monad 개념을 너무 심하게 적용하면 안 됨
- Query Planner는 혹독한 존재임
- **어떤 것이 '쉽다'고 느끼는 순간은 사실 제대로 이해하지 못했다는 신호임**
- 신입 개발자에게 탐구와 실수를 할 수 있는 여유를 주어야 함
- **Soft skill을 적극적으로 발전시켜야 함. 투자 효과가 즉각적으로 나타남**
- 일반 애플리케이션 개발에서는 '진짜 범용 추상화'라는 것이 거의 없음. 필요한 코드만 작성하는 편이 좋음
- 반면, 라이브러리 개발은 추상을 설계하는 일임. 올바른 구조(알제브라적 형태)를 찾는 데 시간을 들여야 함
- **ORM은 모든 언어, 모든 구현에서 문제가 많음. 그냥 SQL을 직접 작성하는 편이 나음**
- Functional 프로그래밍의 문제는 종종 그 신봉자들 때문임
- **충분히 오랜 기간이 지나면 Serverless Functions 위에 시스템을 쌓은 것을 크게 후회하게 됨**
- Type은 우리가 세상을 바라보며 내리는 단언임
- 분산 락은 여전히 대단히 어려운 문제임
- 형식적 모델링과 분석 능력은 반드시 갖춰야 할 역량임
- 통합 테스트 스위트에서 가장 중요한 특성은 격리성임
- DynamoDB는 일반 애플리케이션 개발을 위한 최악의 선택이 될 수도 있음
- **대부분의 사람들은 코드 '장인 정신'에 크게 관심이 없음. 관심을 가지는 사람을 소중히 대하되, 나머지 사람들과는 그들이 있는 자리에서 협업해야 함**
- Gradual, dependently typed 언어가 미래라는 생각임
- 테스트 코드에는 아무리 많은 주석을 달아도 부족함이 없다는 확신임

**바뀌지 않은 의견들**

- 코드 스타일, 린팅 규칙 등 사소한 문제에 집착하는 사람들은 여전히 이상한 부류라고 생각함. 더 중요한 것에 집중해야 함
- 코드 커버리지는 코드 품질과 무관하다는 입장을 유지함 (많은 경우 반비례하는 경향도 있음)
- Monolith는 여전히 괜찮은 선택이라고 여김
- 수십 년간 축적된 RDBMS 연구와 개선을 이기는 것은 어렵다는 점을 인정함
- Micro-service를 적용하려면 합당한 이유가 필수적임 (요즘 점점 당연시되는 경향이 아쉬움)
- 대부분의 프로젝트(심지어 AWS 내부 프로젝트도 마찬가지)는 실제로 '스케일링'이 필요 없고, 오히려 스케일링을 전제로 설계하면 해가 되는 경우가 많음
- 프로젝트 매니저의 93%, 어쩌면 95.2% 정도는 사라져도 별 영향이 없거나 오히려 효율성이 높아질 것이라는 생각임 (4년 전보다 비율이 상승했음)

## 25.03.14

**Unity / Android - Optimized Frame Pacing (OFP)**

> 항상 느끼지만 모바일 디바이스 세부적인 옵션들을 조율하는 것은 고통스럽다. 매번 옵션을 키고 끄면서 빌드 & 프로파일링을 해봐야 하고,
>
> 더 짜증나는 것은 유니티가 내부 코드를 공개하지 않아서 맨땅에 헤딩하지 않고서야 뭐 알 수 있는게 없다.

- [Android 플레이어 설정 - Unity 매뉴얼](https://docs.unity3d.com/kr/2020.1/Manual/class-PlayerSettingsAndroid.html)
> Optimized Frame Pacing : 이 옵션을 활성화하면 Unity가 프레임 속도의 편차를 줄이기 위해 프레임을 균등하게 분배하므로 더 부드러운 게임플레이를 구현할 수 있습니다.

- 뭐 이런 옵션이 필요한가 싶은 항목
  - discussion 페이지와 issue tracker 에서 파편적인 내용을 확인할 수 있었음.
  - [Unity Issue Tracker - Optimized Frame Pacing increases APK file size when Project is Built](https://issuetracker.unity3d.com/issues/optimized-frame-pacing-increases-apk-file-size-when-project-is-built)
  - [What's the Optimized Frame Pacing feature - Unity Engine - Unity Discussions](https://discussions.unity.com/t/whats-the-optimized-frame-pacing-feature/733882)


    Optimized Frame Pacing prevents a queue of frames building up by synchronizing the time at which a game submits a frame with the time at which the display hardware consumes that frame. With Optimized Frame Pacing enabled, frames spend less time in the queue, decreasing input latency. The effects of a player’s input events are reflected sooner on the screen.

    This is achieved by wrapping rendering calls and employing a variety of techniques which combine the use of APIs such as the Java Choreographer, the Native Choreographer and the EGL_ANDROID_presentation_time GL extension on devices where these are available in order to provide a consistent API from the perspective of the Engine Developer.

    On devices where these techniques are not possible Optimized Frame Pacing will fall back to the original implementations of the wrapped functions, providing no regression of framerate on those devices (i.e. Frame Pacing will remain non-optimal but the code will function as before).

- 뭔가 프레임 큐 지연 시간을 조절한다고 하는데, 유니티는 코드를 공개하지 않는 블랙박스이기 때문에 동작원리를 가늠할 수 없다.
- 실제 OFP 를 활성화한 프로젝트에서는 오히려 프레임 레이트가 떨어져서 이슈가 되었다.
  - 옵션 비활성화를 하는 경우 프레임 레이트 변동이 작고, 옵션을 활성화한 경우 프레임 레이트 변동이 더 크다는 프로파일링 보고서가 있었다. (Galaxy s22)

- [Variable Refresh Rate API  Adaptive Performance Samsung Android  4.0.2](https://docs.unity3d.com/Packages/com.unity.adaptiveperformance.samsung.android@4.0/manual/vrr.html)
  - Variable Refresh Rate(VRR) 과는 또 호환되지 않는 옵션이다.

## 25.03.16

**가장 흔한 웹 공격**

- 정말 초보적인 실수로 발생할 수도, 쉽게 예방할 수도 있지만
- 꽤 알려진 문제임에도 끊임없이 발생하고 있다...

- **SQL Injection**

- [SQL injection](https://en.wikipedia.org/wiki/SQL_injection)

    In computing, SQL injection is a code injection technique used to attack data-driven applications, in which malicious SQL statements are inserted into an entry field for execution (e.g. to dump the database contents to the attacker) SQL injection must exploit a security vulnerability in an application's software, for example, when user input is either incorrectly filtered for string literal escape characters embedded in SQL statements or user input is not strongly typed and unexpectedly executed. SQL injection is mostly known as an attack vector for websites but can be used to attack any type of SQL database.

- 사용자 요청 인풋으로 악의적인 sql 문을 보냈을 때 이를 그대로 실행시켜 버려 서비스 데이터를 노출시키는 등의 공격
- 문자열 이스케이프 처리 조차 하지 않는 경우 다분히 공격에 노출된다.

  - `var statement = "SELECT * FROM users WHERE name = '" + userName + "'";`
  - ^ 위 코드에서 userNames 필드를 `' OR '1'='1` 로 세팅한다. 아래 모습처럼 되는데
  - `SELECT * FROM users WHERE name = '' OR '1'='1';`
  - 모든 사용자명을 반환하는 sql 문이 완성되어버린다.

- ORM (Object-Relation Mapping) 을 사용하면 부분적으로 예방이 가능하다고 한다. 인풋을 객체로 다루는 과정해서 필터링이 되는 것.

- **XSS(Cross-site scripting)**

- [Cross-site scripting](https://en.wikipedia.org/wiki/Cross-site_scripting)

    Cross-site scripting (XSS)[a] is a type of security vulnerability that can be found in some web applications. XSS attacks enable attackers to inject client-side scripts into web pages viewed by other users. A cross-site scripting vulnerability may be used by attackers to bypass access controls such as the same-origin policy.

- [XSS(크로스사이트스크립팅) 기본 우회 방법 및 스킬업](https://jjang-joon.tistory.com/122)

코드를 아래 처럼 작성한 뒤

```https
<form action="search.php" method="GET">
  <input type="text" name="query">
  <input type="submit" value="Search">
</form>
```

text 필드에 악성 스크립트를 넣으면 

예시: `https://example.com/search?query=<script>alert('XSS');</script>`

url 페이지를 열 때 'alert' 코드가 실행되어버린다.

- 다른 예로 커뮤니티 게시판 글에 코드를 삽입했는데, 다른 유저가 게시판 글을 열 때 발생되어비리는 경우도 있다.

## 25.03.17

**Model Context Protocol(MCP)**

우리가 외부 서비스 API를 사용할 때는 서비스 별로 다루는 API 모양새가 각각 다르지만

MCP 는 이 다양한 API들을 하나의 정형화된 형태로 다룰 수 있게하는 방법이다.

- 아직 이 모델의 잠재력을 잘 모르게따. 사실 AI 써봐야 내가 모르거나 잊어버린 정보를 찾아주거나 (도서관 사서), 글 번역 / 요약 기능 이상으로 사용해본 적이 없다.
- AI 잠재력에 제일 공감했던 부분은 ChatGPT 4o 가 나올 무렵, gpt가 내가 말한 내용을 듣고 그 답변을 스피커로 들려줄 때. 
  - 실시간으로 ai 와 사람처럼 대화가 가능한 시대가 열렸다 <- 이 부분

[What is Model Context Protocol (MCP) How it simplifies AI integrations compared to APIs  AI Agents That Work](https://norahsakal.com/blog/mcp-vs-api-model-context-protocol-explained/)

- [Model Context Protocol, MCP - 🤖 AIMLLM 소모임 - 닷넷데브](https://forum.dotnetdev.kr/t/model-context-protocol-mcp/12711)

![image_2025-03-17-17-15-16](img/image_2025-03-17-17-15-16.png)

^ Traditional APIs require developers to write custom integrations for each service or data source

![image_2025-03-17-17-11-48](img/image_2025-03-17-17-11-48.png)

^ The Model Context Protocol (MCP) is a standardized protocol that connects AI agents to various external tools and data sources

Just as USB-C simplifies how you connect different devices to your computer, MCP simplifies how AI models interact with your data, tools, and services.

